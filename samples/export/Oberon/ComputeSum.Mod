(*
  Computes the sum and average of the numbers read from a user-specified
  text file (which might have been created via generateRandomNumberFile(4)).
  
  This program is part of an arrangement used to test group code export (issue
  #828) with FileAPI dependency.
  The input check loop has been disabled (replaced by a simple unchecked input
  instruction) in order to test the effect of indirect FileAPI dependency (only the
  called subroutine directly requires FileAPI now).
 *)
MODULE ComputeSum;
(* Generated by Structorizer 3.32-32 *)
IMPORT In,Out;

(* Copyright (C) 2020-03-21 Kay GÃ¼rtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  values: ARRAY 50 OF ???;	(* FIXME! *)
  sum: LONGREAL;
  nValues: INTEGER;
  k: INTEGER;
  (* Disable this if you enable the loop below! *)
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  failure: Exception;

(*
  Tries to read as many integer values as possible upto maxNumbers
  from file fileName into the given array numbers.
  Returns the number of the actually read numbers. May cause an exception.
 *)
PROCEDURE readNumbers(fileName: ARRAY 128 OF CHAR; VAR numbers: ARRAY 50 OF INTEGER; maxNumbers: INTEGER): INTEGER;
VAR
  (* TODO: check and accomplish variable declarations *)
  number: INTEGER;
  nNumbers: INTEGER;
  fileNo: INTEGER;
BEGIN
  nNumbers := 0;
  fileNo := fileOpen(fileName);
  IF fileNo <= 0 THEN
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw "File could not be opened!" *)
  END;
  (* try (FIXME!) *)
    WHILE ~ fileEOF(fileNo) & nNumbers < maxNumbers DO
      number := fileReadInt(fileNo);
      numbers[nNumbers] := number;
      nNumbers := nNumbers + 1;
    END;
  (* catch error (FIXME!) *)
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw *)
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN nNumbers;
END readNumbers;

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := 1000;
  (* Disable this if you enable the loop below! *)
  (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
  Out.String("Name/path of the number file"); In.TYPE(file_name);
  (*
    If you enable this loop, then the preceding input instruction is to be disabled
    and the fileClose instruction in the alternative below is to be enabled.
   *)
(*   REPEAT *)
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
(*     Out.String("Name/path of the number file"); In.TYPE(file_name); *)
(*     fileNo := fileOpen(file_name); *)
(*   UNTIL fileNo > 0 OR file_name = ""; *)
  IF fileNo > 0 THEN
    (* This should be enabled if the input check loop above gets enabled. *)
(*     fileClose(fileNo); *)
    (* Hint: Automatically decomposed array initialization *)
    nValues := 0;
    (* try (FIXME!) *)
      nValues := readNumbers(file_name, values, 1000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
      HALT(-7);
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    sum := 0.0;
    FOR k := 0 TO nValues-1 DO
      sum := sum + values[k];
    END;
    Out.String("sum = ");
    Out.Real(sum, 10);
    Out.Ln;
    Out.String("average = ");
    (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
    Out.TYPE(sum / nValues);
    Out.Ln;
  END;
END ComputeSum.
