MODULE ComputeSum;
(* Generated by Structorizer 3.30-07 *)
IMPORT In,Out;
(*
 * Computes the sum and average of the numbers read from a user-specified
 * text file (which might have been created via generateRandomNumberFile(4)).
 * 
 * This program is part of an arrangement used to test group code export (issue
 * #828) with FileAPI dependency.
 * The input check loop has been disabled (replaced by a simple unchecked input
 * instruction) in order to test the effect of indirect FileAPI dependency (only the
 * called subroutine directly requires FileAPI now).
 *)

(* Copyright (C) 2020-03-21 Kay GÃ¼rtzig *)
(* License: GPLv3-link *)
(*
 * GNU General Public License (V 3)
 * https://www.gnu.org/licenses/gpl.html
 * http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  values: ARRAY OF ???;	(* FIXME! *)
  sum: LONGREAL;
  nValues: INTEGER;
  k: INTEGER;
  (* Disable this if you enable the loop below! *)
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  failure: Exception;

PROCEDURE readNumbers(fileName: ARRAY 100 OF CHAR; VAR numbers: ARRAY OF INTEGER; maxNumbers: INTEGER): INTEGER;
(*
 * Tries to read as many integer values as possible upto maxNumbers
 * from file fileName into the given array numbers.
 * Returns the number of the actually read numbers. May cause an exception.
 *)
VAR
  (* TODO: check and accomplish variable declarations *)
  number: INTEGER;
  nNumbers: INTEGER;
  fileNo: INTEGER;
BEGIN
  nNumbers := 0;
  fileNo := fileOpen(fileName);
  IF fileNo <= 0 THEN
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw "File could not be opened!" *)
  END;
  (* try (FIXME!) *)
    WHILE ~ fileEOF(fileNo) & nNumbers < maxNumbers DO
      number := fileReadInt(fileNo);
      numbers[nNumbers] := number;
      nNumbers := nNumbers + 1;
    END;
  (* catch error (FIXME!) *)
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw *)
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN nNumbers;
END readNumbers;

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := 1000;
  (* Disable this if you enable the loop below! *)
  (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
  Out.String("Name/path of the number file"); In.TYPE(file_name);
  (*
   * If you enable this loop, then the preceding input instruction is to be disabled
   * and the fileClose instruction in the alternative below is to be enabled.
   *)
(*   REPEAT *)
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
(*     Out.String("Name/path of the number file"); In.TYPE(file_name); *)
(*     fileNo := fileOpen(file_name); *)
(*   UNTIL fileNo > 0 OR file_name = ""; *)
  IF fileNo > 0 THEN
    (* This should be enabled if the input check loop above gets enabled. *)
(*     fileClose(fileNo); *)
    (* Hint: Automatically decomposed array initialization *)
    nValues := 0;
    (* try (FIXME!) *)
      nValues := readNumbers(file_name, values, 1000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
      (* FIXME: Find a solution to exit the program here! *)
      (* exit -7 *)
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    sum := 0.0;
    FOR k := 0 TO nValues-1 DO
      sum := sum + values[k];
    END;
    Out.String("sum = ");
    Out.Real(sum, 10);
    Out.Ln;
    Out.String("average = ");
    (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
    Out.TYPE(sum / nValues);
    Out.Ln;
  END;
END ComputeSum.
