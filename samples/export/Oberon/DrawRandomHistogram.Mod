(*
  Reads a random number file and draws a histogram accotrding to the
  user specifications
 *)
MODULE DrawRandomHistogram;
(* Generated by Structorizer 3.32-01 *)
IMPORT In,Out;

(* Copyright (C) 2020-03-21 Kay GÃ¼rtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  (* Interval width *)
  width: ???;	(* FIXME! *)
  value: ???;	(* FIXME! *)
  numberArray: ARRAY 50 OF ???;	(* FIXME! *)
  nObtained: INTEGER;
  nIntervals: ???;	(* FIXME! *)
  min: ???;	(* FIXME! *)
  max: ???;	(* FIXME! *)
  kMaxCount: INTEGER;
  k: INTEGER;
  i: INTEGER;
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  count: ARRAY 50 OF INTEGER;
  failure: Exception;

(*
  Draws a bar chart from the array "values" of size nValues.
  Turtleizer must be activated and will scale the chart into a square of
  500 x 500 pixels
  Note: The function is not robust against empty array or totally equal values.
 *)
PROCEDURE drawBarChart(values: ARRAY 50 OF LONGREAL; nValues: ???);
CONST
  (* Used range of the Turtleizer screen *)
  xSize = 500;
  ySize = 500;

VAR
  (* TODO: check and accomplish variable declarations *)
  yScale: ???;	(* FIXME! *)
  yAxis: ???;	(* FIXME! *)
  valMin: LONGREAL;
  valMax: LONGREAL;
  stripeWidth: ???;	(* FIXME! *)
  stripeHeight: ???;	(* FIXME! *)
  kMin: INTEGER;
  kMax: INTEGER;
  k: INTEGER;
BEGIN
  (* Used range of the Turtleizer screen *)
  kMin := 0;
  kMax := 0;
  FOR k := 1 TO nValues-1 DO
    IF values[k] > values[kMax] THEN
      kMax := k;
    END
    ELSE
      IF values[k] < values[kMin] THEN
        kMin := k;
      END;
    END;
  END;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  IF valMin < 0 THEN
    IF valMax > 0 THEN
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    END
    ELSE
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    END;
  END;
  (* draw coordinate axes *)
  gotoXY(1, ySize - 1);
  forward(ySize -1); (* color = ffffff *)
  penUp();
  backward(yAxis); (* color = ffffff *)
  right(90);
  penDown();
  forward(xSize -1); (* color = ffffff *)
  penUp();
  backward(xSize-1); (* color = ffffff *)
  stripeWidth := xSize / nValues;
  FOR k := 0 TO nValues-1 DO
    stripeHeight := values[k] * 1.0 / yScale;
    CASE k MOD 3 OF
      0:
      setPenColor(255,0,0);
    |
      1:
      setPenColor(0, 255,0);
    |
      2:
      setPenColor(0, 0, 255);
    |
    END;
    fd(1); (* color = ffffff *)
    left(90);
    penDown();
    fd(stripeHeight); (* color = ffffff *)
    right(90);
    fd(stripeWidth - 1); (* color = ffffff *)
    right(90);
    forward(stripeHeight); (* color = ffffff *)
    left(90);
    penUp();
  END;
END drawBarChart;

(*
  Tries to read as many integer values as possible upto maxNumbers
  from file fileName into the given array numbers.
  Returns the number of the actually read numbers. May cause an exception.
 *)
PROCEDURE readNumbers(fileName: ARRAY 128 OF CHAR; VAR numbers: ARRAY 50 OF INTEGER; maxNumbers: INTEGER): INTEGER;
VAR
  (* TODO: check and accomplish variable declarations *)
  number: INTEGER;
  nNumbers: INTEGER;
  fileNo: INTEGER;
BEGIN
  nNumbers := 0;
  fileNo := fileOpen(fileName);
  IF fileNo <= 0 THEN
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw "File could not be opened!" *)
  END;
  (* try (FIXME!) *)
    WHILE ~ fileEOF(fileNo) & nNumbers < maxNumbers DO
      number := fileReadInt(fileNo);
      numbers[nNumbers] := number;
      nNumbers := nNumbers + 1;
    END;
  (* catch error (FIXME!) *)
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw *)
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN nNumbers;
END readNumbers;

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := -10;
  REPEAT
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("Name/path of the number file"); In.TYPE(file_name);
    fileNo := fileOpen(file_name);
  UNTIL fileNo > 0 OR file_name = "";
  IF fileNo > 0 THEN
    fileClose(fileNo);
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("number of intervals"); In.TYPE(nIntervals);
    (* Initialize the interval counters *)
    FOR k := 0 TO nIntervals-1 DO
      count[k] := 0;
    END;
    (* Index of the most populated interval *)
    kMaxCount := 0;
    (* Hint: Automatically decomposed array initialization *)
    nObtained := 0;
    (* try (FIXME!) *)
      nObtained := readNumbers(file_name, numberArray, 10000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    IF nObtained > 0 THEN
      min := numberArray[0];
      max := numberArray[0];
      FOR i := 1 TO nObtained-1 DO
        IF numberArray[i] < min THEN
          min := numberArray[i];
        END
        ELSE
          IF numberArray[i] > max THEN
            max := numberArray[i];
          END;
        END;
      END;
      (* Interval width *)
      width := (max - min) * 1.0 / nIntervals;
      FOR i := 0 TO nObtained - 1 DO
        value := numberArray[i];
        k := 1;
        WHILE k < nIntervals & value > min + k * width DO
          k := k + 1;
        END;
        count[k-1] := count[k-1] + 1;
        IF count[k-1] > count[kMaxCount] THEN
          kMaxCount := k-1;
        END;
      END;
      drawBarChart(count, nIntervals);
      Out.String("Interval with max count: ");
      Out.Int(kMaxCount, 10);
      Out.String(" (");
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(count[kMaxCount]);
      Out.String(")");
      Out.Ln;
      FOR k := 0 TO nIntervals-1 DO
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(count[k]);
        Out.String(" numbers in interval ");
        Out.Int(k, 10);
        Out.String(" (");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + k * width);
        Out.String(" ... ");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + (k+1) * width);
        Out.String(")");
        Out.Ln;
      END;
    END
    ELSE
      Out.String("No numbers read.");
      Out.Ln;
    END;
  END;
END DrawRandomHistogram.
