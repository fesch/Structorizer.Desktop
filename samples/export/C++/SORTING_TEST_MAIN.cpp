// Generated by Structorizer 3.30-03 
//  
// Copyright (C) 2019-10-02 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 
//  
#include <iostream>
#include <thread>


// Implements the well-known BubbleSort algorithm. 
// Compares neigbouring elements and swaps them in case of an inversion. 
// Repeats this while inversions have been found. After every 
// loop passage at least one element (the largest one out of the 
// processed subrange) finds its final place at the end of the 
// subrange. 
// function bubbleSort(values) 
// TODO Revise the return type and declare the parameters! 
void bubbleSort(??? values)
{
	// TODO: Check and accomplish variable declarations: 
	
	??? ende = length(values) - 2;
	do {
		// The index of the most recent swapping (-1 means no swapping done). 
		??? posSwapped = -1;
		for (int i = 0; i <= ende; i += (1)) {
			if (values[i] > values[i+1]) {
				??? temp = values[i];
				values[i] = values[i+1];
				values[i+1] = temp;
				posSwapped = i;
			}
		}
		ende = posSwapped - 1;
	} while (!(posSwapped < 0));
}

// Given a max-heap 'heap´ with element at index 'i´ possibly 
// violating the heap property wrt. its subtree upto and including 
// index range-1, restores heap property in the subtree at index i 
// again. 
// function maxHeapify(heap, i, range) 
// TODO Revise the return type and declare the parameters! 
void maxHeapify(??? heap, ??? i, ??? range)
{
	// TODO: Check and accomplish variable declarations: 
	
	// Indices of left and right child of node i 
	??? right = (i+1) * 2;
	??? left = right - 1;
	// Index of the (local) maximum 
	??? max = i;
	if (left < range && heap[left] > heap[i]) {
		max = left;
	}
	if (right < range && heap[right] > heap[max]) {
		max = right;
	}
	if (max != i) {
		??? temp = heap[i];
		heap[i] = heap[max];
		heap[max] = temp;
		maxHeapify(heap, max, range);
	}
}

// Partitions array values between indices start und stop-1 with 
// respect to the pivot element initially at index p into smaller 
// and greater elements. 
// Returns the new (and final) index of the pivot element (which 
// separates the sequence of smaller from the sequence of greater 
// elements). 
// This is not the most efficient algorithm (about half the swapping 
// might still be avoided) but it is pretty clear. 
// function partition(values, start, stop, p): int 
// TODO Revise the return type and declare the parameters! 
int partition(??? values, ??? start, ??? stop, ??? p)
{
	// TODO: Check and accomplish variable declarations: 
	
	??? pivot = values[p];
	// Tausche das Pivot-Element an den start 
	values[p] = values[start];
	values[start] = pivot;
	p = start;
	// Beginning and end of the remaining unknown range 
	start = start + 1;
	stop = stop - 1;
	// Still unseen elements? 
	while (stop >= start) {
		??? seen = values[start];
		if (values[start] <= pivot) {
			// Swap pivot element with start element 
			values[p] = seen;
			values[start] = pivot;
			p = p + 1;
			start = start + 1;
		}
		else {
			// Put the found element to the end of the unknown area 
			values[start] = values[stop];
			values[stop] = seen;
			stop = stop - 1;
		}
	}
	return p;
}

// Checks whether or not the passed-in array is (ascendingly) sorted. 
// function testSorted(numbers): bool 
// TODO Revise the return type and declare the parameters! 
bool testSorted(??? numbers)
{
	// TODO: Check and accomplish variable declarations: 
	bool isSorted;
	int i;
	
	
	isSorted = true;
	i = 0;
	// As we compare with the following element, we must stop at the penultimate index 
	while (isSorted && (i <= length(numbers)-2)) {
		// Is there an inversion? 
		if (numbers[i] > numbers[i+1]) {
			isSorted = false;
		}
		else {
			i = i + 1;
		}
	}
	return isSorted;
}

// Runs through the array heap and converts it to a max-heap 
// in a bottom-up manner, i.e. starts above the "leaf" level 
// (index >= length(heap) div 2) and goes then up towards 
// the root. 
// function buildMaxHeap(heap) 
// TODO Revise the return type and declare the parameters! 
int buildMaxHeap(??? heap)
{
	// TODO: Check and accomplish variable declarations: 
	int lgth;
	
	
	lgth = length(heap);
	for (int k = lgth / 2 - 1; k >= 0; k += (-1)) {
		maxHeapify(heap, k, lgth);
	}
	
	return 0;
}

// Recursively sorts a subrange of the given array 'values´.  
// start is the first index of the subsequence to be sorted, 
// stop is the index BEHIND the subsequence to be sorted. 
// function quickSort(values, start, stop) 
// TODO Revise the return type and declare the parameters! 
int quickSort(??? values, ??? start, ??? stop)
{
	class ThrFunc7fed1521_0{
	public:
		void operator()(???& values, ???& start, ???& p) {
			// Sort left (lower) array part 
			quickSort(values, start, p);
		}
	};
	
	class ThrFunc7fed1521_1{
	public:
		void operator()(???& values, ???& p, ???& stop) {
			// Sort right (higher) array part 
			quickSort(values, p+1, stop);
		}
	};
	
	// TODO: Check and accomplish variable declarations: 
	
	// At least 2 elements? (Less don't make sense.) 
	if (stop >= start + 2) {
		// Select a pivot element, be p its index. 
		// (here: randomly chosen element out of start ... stop-1) 
		??? p = random(stop-start) + start;
		// Partition the array into smaller and greater elements 
		// Get the resulting (and final) position of the pivot element 
		// Partition the array into smaller and greater elements 
		// Get the resulting (and final) position of the pivot element 
		p = partition(values, start, stop, p);
		// Sort subsequances separately and independently ... 

		// Parallel section 
		{
			ThrFunc7fed1521_0 thrfunc7fed1521_0;
			std::thread thr7fed1521_0(thrfunc7fed1521_0, values, start, p);
		
			ThrFunc7fed1521_1 thrfunc7fed1521_1;
			std::thread thr7fed1521_1(thrfunc7fed1521_1, values, p, stop);
		
			thr7fed1521_0.join();
			thr7fed1521_1.join();
		}

	}
	
	return 0;
}

// Sorts the array 'values´ of numbers according to he heap sort 
// algorithm 
// function heapSort(values) 
// TODO Revise the return type and declare the parameters! 
int heapSort(??? values)
{
	// TODO: Check and accomplish variable declarations: 
	int heapRange;
	
	
	buildMaxHeap(values);
	heapRange = length(values);
	for (int k = heapRange - 1; k >= 1; k += (-1)) {
		heapRange = heapRange - 1;
		// Swap the maximum value (root of the heap) to the heap end 
		??? maximum = values[0];
		values[0] = values[heapRange];
		values[heapRange] = maximum;
		maxHeapify(values, 0, heapRange);
	}
	
	return 0;
}

// Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
// to allow performance comparison via execution counting ("Collect Runtime Data" should 
// sensibly be switched on). 
// Requested input data are: Number of elements (size) and filing mode. 
// program SORTING_TEST_MAIN 
int main(void)
{
	class ThrFunc247e34b9_0{
	public:
		void operator()(int values1[]) {
			bubbleSort(values1);
		}
	};
	
	class ThrFunc247e34b9_1{
	public:
		void operator()(??? values2[], ???& elementCount) {
			quickSort(values2, 0, elementCount);
		}
	};
	
	class ThrFunc247e34b9_2{
	public:
		void operator()(??? values3[]) {
			heapSort(values3);
		}
	};
	
	// TODO: Check and accomplish variable declarations: 
	??? values3[];
	??? values2[];
	int values1[];
	??? show;
	bool ok3;
	bool ok2;
	bool ok1;
	??? modus;
	??? elementCount;
	
	
	do {
		std::cin >> elementCount;
	} while (!(elementCount >= 1));
	do {
		std::cout << "Filling: 1 = random, 2 = increasing, 3 = decreasing"; std::cin >> modus;
	} while (!(modus == 1 || modus == 2 || modus == 3));
	for (int i = 0; i <= elementCount-1; i += (1)) {
		switch (modus) {
		case 1:
			values1[i] = random(10000);
			break;
		case 2:
			values1[i] = i;
			break;
		case 3:
			values1[i] = -i;
			break;
		}
	}
	// Copy the array for exact comparability 
	for (int i = 0; i <= elementCount-1; i += (1)) {
		values2[i] = values1[i];
		values3[i] = values1[i];
	}

	// Parallel section 
	{
		ThrFunc247e34b9_0 thrfunc247e34b9_0;
		std::thread thr247e34b9_0(thrfunc247e34b9_0, values1);
	
		ThrFunc247e34b9_1 thrfunc247e34b9_1;
		std::thread thr247e34b9_1(thrfunc247e34b9_1, values2, elementCount);
	
		ThrFunc247e34b9_2 thrfunc247e34b9_2;
		std::thread thr247e34b9_2(thrfunc247e34b9_2, values3);
	
		thr247e34b9_0.join();
		thr247e34b9_1.join();
		thr247e34b9_2.join();
	}

	ok1 = testSorted(values1);
	ok2 = testSorted(values2);
	ok3 = testSorted(values3);
	if (! ok1 || ! ok2 || ! ok3) {
		for (int i = 0; i <= elementCount-1; i += (1)) {
			if (values1[i] != values2[i] || values1[i] != values3[i]) {
				std::cout << "Difference at [" << i << "]: " << values1[i] << " <-> " << values2[i] << " <-> " << values3[i] << std::endl;
			}
		}
	}
	do {
		std::cout << "Show arrays (yes/no)?"; std::cin >> show;
	} while (!(show == "yes" || show == "no"));
	if (show == "yes") {
		for (int i = 0; i <= elementCount - 1; i += (1)) {
			std::cout << "[" << i << "]:\t" << values1[i] << "\t" << values2[i] << "\t" << values3[i] << std::endl;
		}
	}
	
	return 0;
}
