// program DrawRandomHistogram 
// Generated by Structorizer 3.32-20 

// Copyright (C) 2020-03-21 Kay GÃ¼rtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdbool.h>

/*===== STRUCTORIZER FILE API START =====*/
#define FILE_API_MAX_HANDLES 20
/* Entry type for the file handle map */
struct StructorizerFileAPI_Entry {
	int fileNo;
	FILE* hFile;
};
struct StructorizerFileAPI_Map {
	unsigned int nHandles;
	int nextFileNo;
	struct StructorizerFileAPI_Entry handles[FILE_API_MAX_HANDLES];
} structorizerFileAPI_map = { 0, 1 };

/* Global buffer variable for File-API-internal purposes */
#define FILE_API_BUFFER_SIZE 1024
char structorizerFileAPI_buffer[FILE_API_BUFFER_SIZE];

/* Internal helper function of Structorizer File API, not for customer use! */
int structorizerFileAPI_getHandleIndex(int fileNo)
{
	int index = -1;
	int low = 0, high = structorizerFileAPI_map.nHandles;
	while (index < 0 && low < high) {
		int peek = (low + high) / 2;
		int refNo = structorizerFileAPI_map.handles[peek].fileNo;
		if (fileNo < refNo) { high = peek; }
		else if (fileNo > refNo) { low = peek + 1; }
		else { index = peek; }
	}
	return index;
}

/**
 * Tries to open a text file with given filePath for reading. File must exist.
 * A NULL return value indicates failure.
 * @param filePath - the path of the file (may be absolute or relative to the current directory)
 * @return a valid file handle (> 0) on success or a (negative) error code otherwise
 */
int fileOpen(char* filePath)
{
	struct StructorizerFileAPI_Entry entry = { 0, NULL };
	if (structorizerFileAPI_map.nHandles < FILE_API_MAX_HANDLES
		&& (entry.hFile = fopen(filePath, "r")) != NULL)
	{
		entry.fileNo = structorizerFileAPI_map.nextFileNo++;
		structorizerFileAPI_map.handles[structorizerFileAPI_map.nHandles++] = entry;
	}
	else {
		entry.fileNo = -errno;
	}
	return entry.fileNo;
}

/**
 * Tries to create a text file with given filePath for writing. If the file exists then it will
 * be cleared (without warning!).
 * @param filePath - the path of the file (may be absolute or relative to the current directory)
 * @return a valid file handle (> 0) on success or a (negative) error code otherwise
 */
int fileCreate(char* filePath)
{
	struct StructorizerFileAPI_Entry entry = { 0, NULL };
	if (structorizerFileAPI_map.nHandles < FILE_API_MAX_HANDLES
		&& (entry.hFile = fopen(filePath, "w")) != NULL)
	{
		entry.fileNo = structorizerFileAPI_map.nextFileNo++;
		structorizerFileAPI_map.handles[structorizerFileAPI_map.nHandles++] = entry;
	}
	else {
		entry.fileNo = -errno;
	}
	return entry.fileNo;
}

/**
 * Tries to create or open a text file with given filePath for writing. If the file exists then
 * it will not be cleared but writing starts at previous end.
 * @param filePath - the path of the file (may be absolute or relative to the current directory)
 * @return a valid file handle (> 0) on success or a (negative) error code otherwise
 */
int fileAppend(char* filePath)
{
	struct StructorizerFileAPI_Entry entry = { 0, NULL };
	if (structorizerFileAPI_map.nHandles < FILE_API_MAX_HANDLES
		&& (entry.hFile = fopen(filePath, "a")) != NULL)
	{
		entry.fileNo = structorizerFileAPI_map.nextFileNo++;
		structorizerFileAPI_map.handles[structorizerFileAPI_map.nHandles++] = entry;
	}
	else {
		entry.fileNo = -errno;
	}
	return entry.fileNo;
}

/**
 * Closes the file with given fileNo handle. If fileNo is not associated with an open file
 * then an IOException will be thrown.
 * @param fileNo - file handle as obtained by fileOpen, fileCreate or fileAppend before
 */
void fileClose(int fileNo)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		fclose(structorizerFileAPI_map.handles[index].hFile);
		/* FIXME: The following should be performed as critical section */
		structorizerFileAPI_map.nHandles--;
		for (int i = index; i < structorizerFileAPI_map.nHandles; i++) {
			structorizerFileAPI_map.handles[i] = structorizerFileAPI_map.handles[i + 1];
		}
	}
	else {
		fprintf(stderr, "fileClose: Invalid file number or file not open for reading.");
		exit(-5);
	}
}

/**
 * Checks whether the input file with given hFie handle is exhausted i.e. provides no
 * readable content beyond the current reading position.
 * @param fileNo - file handle as obtained by fileOpen before.
 * @return true iff end of file has been reached.
 */
int fileEOF(int fileNo)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index < 0) {
		fprintf(stderr, "fileEOF: Invalid file number or file not open for reading.");
		exit(-5);
	}
	else {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		int isEOF = feof(hFile);
		if (!isEOF) {
			int ch = getc(hFile);
			if (ch == EOF) {
				isEOF = 1;
			}
			else {
				ungetc(ch, hFile);
			}
		}
		return isEOF;
	}
	return 0;
}

/* Internal helper function of Structorizer File API, not for customer use! */
void* structorizerFileAPI_concatenateTokens(FILE* hFile, char rDelim, int length)
{
	void* pResult = structorizerFileAPI_buffer;
	char formatString[13];
	while (structorizerFileAPI_buffer[length - 1] != rDelim && length + 1 < FILE_API_BUFFER_SIZE) {
		structorizerFileAPI_buffer[length] = getc(hFile);
		if (structorizerFileAPI_buffer[length] == EOF || structorizerFileAPI_buffer[length] == rDelim) {
			structorizerFileAPI_buffer[length++] = rDelim;
			structorizerFileAPI_buffer[length] = '\0';
		}
		else {
			sprintf(formatString, "%%%ds", FILE_API_BUFFER_SIZE - (length + 1));
			if (fscanf(hFile, formatString, structorizerFileAPI_buffer + length + 1) > 0) {
				length = strlen(structorizerFileAPI_buffer);
			}
			else {
				structorizerFileAPI_buffer[length++] = rDelim;
				structorizerFileAPI_buffer[length] = '\0';
			}
		}
	}
	if (rDelim != '}') {
		pResult = structorizerFileAPI_buffer + 1;
		structorizerFileAPI_buffer[length - 1] = '\0';
	}

	return pResult;
}

/**
 * CAUTION: This function returns either NULL or a pointer to the value read from file,
 * never the value itself!
 * In theory, this function should read the next token from the text file given by
 * fileNo handle and return it in the appropriate type.
 * Unfortunately, such a behaviour isn't possible in C. We cannot even return a
 * C-String without being provided with a buffer as argument (unless we were allowed
 * to allocate dynamic memory here).
 * So, this functions scans the file for a token and reads it into a fixed global
 * buffer. Then it tries to convert the content into int and double. If any of these
 * conversions succeeds and is unique then the converted value will be placed at the
 * buffer beginning such that dereferencing the returned pointer will provide the
 * value. It must immediately be copied to a variable because the buffer is volatile.
 * Throws an error if the given handle is not associated to an open text input file.
 * @param fileNo - file handle as obtained by fileOpen before
 * @return POINTER TO an int or double variable or a C-string - to be casted appropriately -, or NULL
 */
void* fileRead(int fileNo)
{
	void* pResult = NULL;
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		char formatString[13];
		int nObtained = 0;
		sprintf(formatString, "%%%ds", FILE_API_BUFFER_SIZE);
		nObtained = fscanf(hFile, formatString, structorizerFileAPI_buffer);
		if (nObtained > 0) {
			/* Try to convert the obtained string... */
			int length = strlen(structorizerFileAPI_buffer);
			int iResult = 0;
			double dResult = 0.0;
			char cTest = '\0';
			int obtainedDbl = 0;
			int obtainedInt = 0;
			pResult = structorizerFileAPI_buffer;
			obtainedInt = sscanf(structorizerFileAPI_buffer, "%d", &iResult);
			if (obtainedInt > 0 && length > 1) {
				char lastCh = structorizerFileAPI_buffer[length - 1];
				structorizerFileAPI_buffer[length - 1] = '\0';
				if (atoi(structorizerFileAPI_buffer) == iResult) {
					// If the last digit doesn't play a role then it is hardly an integer
					obtainedInt = 0;
				}
				structorizerFileAPI_buffer[length - 1] = lastCh;
			}
			if (obtainedInt == 0 && (obtainedDbl = sscanf(pResult, "%lg%1c", &dResult, &cTest)) != 1) {
				obtainedDbl = 0;
			}
			pResult = structorizerFileAPI_buffer;
			if (obtainedInt == 1) {
				memcpy(pResult, &iResult, sizeof(int));
				structorizerFileAPI_buffer[sizeof(int)] = '\0';
			}
			else if (obtainedDbl == 1) {
				memcpy(pResult, &dResult, sizeof(double));
				structorizerFileAPI_buffer[sizeof(double)] = '\0';
			}
			else if (structorizerFileAPI_buffer[0] == '"') {
				pResult = structorizerFileAPI_concatenateTokens(hFile, '"', length);
			}
			else if (structorizerFileAPI_buffer[0] == '\'') {
				pResult = structorizerFileAPI_concatenateTokens(hFile, '\'', length);
			}
			else if (structorizerFileAPI_buffer[0] == '{') {
				pResult = structorizerFileAPI_concatenateTokens(hFile, '}', length);
			}
		}
	}
	else {
		fprintf(stderr, "fileRead: Invalid file number or file not open for reading.");
		exit(-5);
	}
	return pResult;
}

/**
 * Reads the next character from the text file given by fileNo handle and returns it.
 * Throws an error if the given handle is not associated to an open text input file.
 * @param fileNo - file handle as obtained by fileOpen before
 * @return the current character from file input character sequence or '\0'.
 */
int fileReadChar(int fileNo)
{
	char ch = '\0';
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		ch = getc(hFile);
		if (ch == EOF) {
			ch = '\0';
		}
	}
	else {
		fprintf(stderr, "fileReadChar: Invalid file number or file not open for reading.");
		exit(-5);
	}
	return ch;
}

/**
 * Reads the next integer value from the text file given by fileNo handle and returns it.
 * Throws an error if the given handle is not associated to an open text input file.
 * If the file input stream was exhausted (was at end of file) or if the token at reading
 * was not interpretable as integral literal, then the program will be aborted with code EOF.
 * @param fileNo - file handle as obtained by fileOpen before
 * @return the current int number as interpreted from the file input character sequence.
 */
int fileReadInt(int fileNo)
{
	int result = 0;
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		int nObtained = fscanf(hFile, "%d", &result);
		if (nObtained < 1) {
			fprintf(stderr, "fileReadInt: No int value readable from file!");
			exit(EOF);
		}
	}
	else {
		fprintf(stderr, "fileReadInt: Invalid file number or file not open for reading.");
		exit(-5);
	}
	return result;
}

/**
 * Reads the next floating-point value from the text file given by fileNo handle and
 * returns it as double.
 * Throws an error if the given handle is not associated to an open text input file.
 *  If the file input stream was exhausted (was at end of file) or if the token at reading
 * was not interpretable as double literal, then the program will be aborted with code EOF.
 * @param fileNo - file handle as obtained by fileOpen before
 * @return the current floating-point value from the file input character sequence.
 */
double fileReadDouble(int fileNo)
{
	double result = 0;
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		int nObtained = fscanf(hFile, "%lg", &result);
		if (nObtained < 1) {
			fprintf(stderr, "fileReadDouble: No double value readable from file!");
			exit(EOF);
		}
	}
	else {
		fprintf(stderr, "fileReadDouble: Invalid file number or file not open for reading.");
		exit(-5);
	}
	return result;
}

/**
 * Reads the next text line (or the rest of the current text line) from the text file
 * given by fileNo handle and returns it.
 * Throws an error if the given handle is not associated to an open text input file.
 * If the file input stream was exhausted (was at end of file) or if the token at reading
 * was not interpretable as integral literal then null will be returned.
 * @param fileNo - file handle as obtained by fileOpen before
 * @return the current line from file or NULL.
 */
char* fileReadLine(int fileNo)
{
	char* pResult = NULL;
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		pResult = fgets(structorizerFileAPI_buffer, FILE_API_BUFFER_SIZE, hFile);
	}
	else {
		fprintf(stderr, "fileReadLine: Invalid file number or file not open for reading.");
		exit(-5);
	}
	return pResult;
}

/**
 * Writes the given C-string to the file given by handle fileNo.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param str the string to be written to file.
 */
void fileWrite(int fileNo, char* str)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%s", str);
	}
	else {
		fprintf(stderr, "fileWrite: Invalid file number or file not open for writing.");
		exit(-5);
	}
}

/**
 * Writes the given value as character sequence to the file given by handle fileNo.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param value the integer value to be written to file.
 */
void fileWriteInt(int fileNo, int value)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%d", value);
	}
	else {
		fprintf(stderr, "fileWriteInt: Invalid file number or file not open for writing.");
		exit(-5);
	}
}

/**
 * Writes the given value as character sequence to the file given by handle fileNo.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param value the double value to be written to file.
 */
void fileWriteDouble(int fileNo, double value)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%g", value);
	}
	else {
		fprintf(stderr, "fileWriteDouble: Invalid file number or file not open for writing.");
		exit(-5);
	}
}

/**
 * Writes the given character sequence to the file given by handle fileNo
 * and appends a newline character or sequence as value separator.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param str the C-String to be written to file.
 */
void fileWriteLine(int fileNo, char* str)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%s\n", str);
	}
	else {
		fprintf(stderr, "fileWriteLine: Invalid file number or file not open for writing.");
		exit(-5);
	}
}

/**
 * Writes the given value as character sequence to the file given by handle fileNo.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param value the integer value to be written to file.
 */
void fileWriteLineInt(int fileNo, int value)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%d\n", value);
	}
	else {
		fprintf(stderr, "fileWriteLineInt: Invalid file number or file not open for writing.");
		exit(-5);
	}
}

/**
 * Writes the given value as character sequence to the file given by handle fileNo.
 * Throws an error if the given handle is not associated to an open text output file.
 * @param fileNo - file handle as obtained by fileCreate or fileAppend before
 * @param value the double value to be written to file.
 */
void fileWriteLineDouble(int fileNo, double value)
{
	int index = structorizerFileAPI_getHandleIndex(fileNo);
	if (index >= 0) {
		FILE* hFile = structorizerFileAPI_map.handles[index].hFile;
		fprintf(hFile, "%g\n", value);
	}
	else {
		fprintf(stderr, "fileWriteLineDouble: Invalid file number or file not open for writing.");
		exit(-5);
	}
}
/*===== STRUCTORIZER FILE API END =====*/

// function drawBarChart(values: array of double; nValues) 

// Draws a bar chart from the array "values" of size nValues. 
// Turtleizer must be activated and will scale the chart into a square of 
// 500 x 500 pixels 
// Note: The function is not robust against empty array or totally equal values. 
// TODO: Revise the return type and declare the parameters. 
void drawBarChart(double values[50], ??? nValues)
{
	// TODO: Check and accomplish variable declarations: 
	// Used range of the Turtleizer screen 
	const int xSize = 500;
	const int ySize = 500;
	??? yScale;
	??? yAxis;
	double valMin;
	double valMax;
	??? stripeWidth;
	??? stripeHeight;
	int kMin;
	int kMax;
	int k;

	// Used range of the Turtleizer screen 
	kMin = 0;
	kMax = 0;
	for (k = 1; k <= nValues-1; k += (1)) {
		if (values[k] > values[kMax]) {
			kMax = k;
		}
		else if (values[k] < values[kMin]) {
			kMin = k;
		}
	}
	valMin = values[kMin];
	valMax = values[kMax];
	yScale = valMax * 1.0 / (ySize - 1);
	yAxis = ySize - 1;
	if (valMin < 0) {
		if (valMax > 0) {
			yAxis = valMax * ySize * 1.0 / (valMax - valMin);
			yScale = (valMax - valMin) * 1.0 / (ySize - 1);
		}
		else {
			yAxis = 1;
			yScale = valMin * 1.0 / (ySize - 1);
		}
	}
	// draw coordinate axes 
	gotoXY(1, ySize - 1);
	forward(ySize -1); // color = ffffff
	penUp();
	backward(yAxis); // color = ffffff
	right(90);
	penDown();
	forward(xSize -1); // color = ffffff
	penUp();
	backward(xSize-1); // color = ffffff
	stripeWidth = xSize / nValues;
	for (k = 0; k <= nValues-1; k += (1)) {
		stripeHeight = values[k] * 1.0 / yScale;
		switch (k % 3) {
		case 0:
			setPenColor(255,0,0);
			break;
		case 1:
			setPenColor(0, 255,0);
			break;
		case 2:
			setPenColor(0, 0, 255);
			break;
		}
		fd(1); // color = ffffff
		left(90);
		penDown();
		fd(stripeHeight); // color = ffffff
		right(90);
		fd(stripeWidth - 1); // color = ffffff
		right(90);
		forward(stripeHeight); // color = ffffff
		left(90);
		penUp();
	}
}

// function readNumbers(fileName: string; numbers: array of integer; maxNumbers: integer): integer 

// Tries to read as many integer values as possible upto maxNumbers 
// from file fileName into the given array numbers. 
// Returns the number of the actually read numbers. May cause an exception. 
// TODO: Revise the return type and declare the parameters. 
int readNumbers(char* fileName, int numbers[50], int maxNumbers)
{
	// TODO: Check and accomplish variable declarations: 
	int number;
	int nNumbers;
	int fileNo;

	nNumbers = 0;
	fileNo = fileOpen(fileName);
	if (fileNo <= 0) {
		// FIXME: Structorizer detected this illegal jump attempt: 
		// throw "File could not be opened!" 
		goto __ERROR__;
	}
	// TODO: Find an equivalent for this non-supported try / catch block! 
// 	try { 
		while (! fileEOF(fileNo) && nNumbers < maxNumbers) {
			number = fileReadInt(fileNo);
			numbers[nNumbers] = number;
			nNumbers = nNumbers + 1;
		}
// 	} 
// 	catch(char error[]) { 
		// FIXME: jump/exit instruction of unrecognised kind! 
		// throw 
// 	} 
// 	finally { 
		fileClose(fileNo);
// 	} 
	return nNumbers;
}


// Reads a random number file and draws a histogram accotrding to the 
// user specifications 
int main(void)
{
	// TODO: Check and accomplish variable declarations: 
	??? width;
	??? value;
	??? numberArray[50];
	int nObtained;
	??? nIntervals;
	??? min;
	??? max;
	int kMaxCount;
	int k;
	int i;
	??? file_name;
	int fileNo;
	int count[50];

	// TODO: 
	// For any input using the 'scanf' function you need to fill the first argument. 
	// http://en.wikipedia.org/wiki/Scanf#Format_string_specifications 

	// TODO: 
	// For any output using the 'printf' function you need to fill the first argument: 
	// http://en.wikipedia.org/wiki/Printf#printf_format_placeholders 

	fileNo = -10;
	do {
		// TODO: check format specifiers, replace all '?'! 
		printf("Name/path of the number file"); scanf("%?", &file_name);
		fileNo = fileOpen(file_name);
	} while (! (fileNo > 0 || file_name == ""));
	if (fileNo > 0) {
		fileClose(fileNo);
		// TODO: check format specifiers, replace all '?'! 
		printf("number of intervals"); scanf("%?", &nIntervals);
		// Initialize the interval counters 
		for (k = 0; k <= nIntervals-1; k += (1)) {
			count[k] = 0;
		}
		// Index of the most populated interval 
		kMaxCount = 0;
		nObtained = 0;
		// TODO: Find an equivalent for this non-supported try / catch block! 
// 		try { 
			nObtained = readNumbers(file_name, numberArray, 10000);
// 		} 
// 		catch(char failure[]) { 
			// TODO: check format specifiers, replace all '?'! 
// 			printf("%?\n", failure); 
// 		} 
		if (nObtained > 0) {
			min = numberArray[0];
			max = numberArray[0];
			for (i = 1; i <= nObtained-1; i += (1)) {
				if (numberArray[i] < min) {
					min = numberArray[i];
				}
				else if (numberArray[i] > max) {
					max = numberArray[i];
				}
			}
			// Interval width 
			width = (max - min) * 1.0 / nIntervals;
			for (i = 0; i <= nObtained - 1; i += (1)) {
				value = numberArray[i];
				k = 1;
				while (k < nIntervals && value > min + k * width) {
					k = k + 1;
				}
				count[k-1] = count[k-1] + 1;
				if (count[k-1] > count[kMaxCount]) {
					kMaxCount = k-1;
				}
			}
			drawBarChart(count, nIntervals);
			// TODO: check format specifiers, replace all '?'! 
			printf("%s%d%s%?%s\n", "Interval with max count: ", kMaxCount, " (", count[kMaxCount], ")");
			for (k = 0; k <= nIntervals-1; k += (1)) {
				// TODO: check format specifiers, replace all '?'! 
				printf("%?%s%d%s%?%s%?%s\n", count[k], " numbers in interval ", k, " (", min + k * width, " ... ", min + (k+1) * width, ")");
			}
		}
		else {
			// TODO: check format specifiers, replace all '?'! 
			printf("%s\n", "No numbers read.");
		}
	}

	return 0;
}
