10 REM Reads a random number file and draws a histogram accotrding to the 
20 REM user specifications 
30 REM Generated by Structorizer 3.32-26 
40 
50 REM Copyright (C) 2020-03-21 Kay GÃ¼rtzig 
60 REM License: GPLv3-link 
70 REM GNU General Public License (V 3) 
80 REM https://www.gnu.org/licenses/gpl.html 
90 REM http://www.gnu.de/documents/gpl.de.html 
100 
110 REM  
120 REM program DrawRandomHistogram
130 REM TODO: add the respective type suffixes to your variable names if required 
140 DIM numberArray() AS ???
150 DIM count() AS Integer
160 REM  
170 LET fileNo = -10
180 DO
190   PRINT "Name/path of the number file"; : INPUT file_name
200   LET fileNo = fileOpen(file_name)
210 LOOP UNTIL fileNo > 0 OR file_name = ""
220 IF fileNo > 0 THEN
230   fileClose(fileNo)
240   PRINT "number of intervals"; : INPUT nIntervals
250   REM Initialize the interval counters 
260   FOR k = 0 TO nIntervals-1
270     LET count(k) = 0
280   NEXT k
290   REM Index of the most populated interval 
300   LET kMaxCount = 0
310   LET nObtained = 0
320   ON ERROR GOTO 360
330   LET nObtained = readNumbers(file_name, numberArray, 10000)
340   GOTO 380
350   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
360     PRINT failure
370   REM End of error handler, resume here ... 
380   ON ERROR GOTO 0
390   IF nObtained > 0 THEN
400     LET min = numberArray(0)
410     LET max = numberArray(0)
420     FOR i = 1 TO nObtained-1
430       IF numberArray(i) < min THEN
440         LET min = numberArray(i)
450       ELSE
460         IF numberArray(i) > max THEN
470           LET max = numberArray(i)
480         END IF
490       END IF
500     NEXT i
510     REM Interval width 
520     LET width = (max - min) * 1.0 / nIntervals
530     FOR i = 0 TO nObtained - 1
540       LET value = numberArray(i)
550       LET k = 1
560       DO WHILE k < nIntervals AND value > min + k * width
570         LET k = k + 1
580       LOOP
590       LET count(k-1) = count(k-1) + 1
600       IF count(k-1) > count(kMaxCount) THEN
610         LET kMaxCount = k-1
620       END IF
630     NEXT i
640     CALL drawBarChart(count, nIntervals)
650     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
660     FOR k = 0 TO nIntervals-1
670       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
680     NEXT k
690   ELSE
700     PRINT "No numbers read."
710   END IF
720 END IF
730 END
740 REM  
750 REM Draws a bar chart from the array "values" of size nValues. 
760 REM Turtleizer must be activated and will scale the chart into a square of 
770 REM 500 x 500 pixels 
780 REM Note: The function is not robust against empty array or totally equal values. 
790 REM TODO: Add type-specific suffixes where necessary! 
800 SUB drawBarChart(values AS double(50), nValues)
810   REM TODO: add the respective type suffixes to your variable names if required 
820   REM  
830   REM  
840   REM Used range of the Turtleizer screen 
850   LET xSize = 500
860   LET ySize = 500
870   LET kMin = 0
880   LET kMax = 0
890   FOR k = 1 TO nValues-1
900     IF values(k) > values(kMax) THEN
910       LET kMax = k
920     ELSE
930       IF values(k) < values(kMin) THEN
940         LET kMin = k
950       END IF
960     END IF
970   NEXT k
980   LET valMin = values(kMin)
990   LET valMax = values(kMax)
1000   LET yScale = valMax * 1.0 / (ySize - 1)
1010   LET yAxis = ySize - 1
1020   IF valMin < 0 THEN
1030     IF valMax > 0 THEN
1040       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
1050       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
1060     ELSE
1070       LET yAxis = 1
1080       LET yScale = valMin * 1.0 / (ySize - 1)
1090     END IF
1100   END IF
1110   REM draw coordinate axes 
1120   gotoXY(1, ySize - 1)
1130   forward(ySize -1) : REM color = ffffff
1140   penUp()
1150   backward(yAxis) : REM color = ffffff
1160   right(90)
1170   penDown()
1180   forward(xSize -1) : REM color = ffffff
1190   penUp()
1200   backward(xSize-1) : REM color = ffffff
1210   LET stripeWidth = xSize / nValues
1220   FOR k = 0 TO nValues-1
1230     LET stripeHeight = values(k) * 1.0 / yScale
1240     SELECT CASE k % 3
1250       CASE 0
1260         setPenColor(255,0,0)
1270       CASE 1
1280         setPenColor(0, 255,0)
1290       CASE 2
1300         setPenColor(0, 0, 255)
1310     END SELECT
1320     fd(1) : REM color = ffffff
1330     left(90)
1340     penDown()
1350     fd(stripeHeight) : REM color = ffffff
1360     right(90)
1370     fd(stripeWidth - 1) : REM color = ffffff
1380     right(90)
1390     forward(stripeHeight) : REM color = ffffff
1400     left(90)
1410     penUp()
1420   NEXT k
1430 END SUB
1440 REM  
1450 REM Tries to read as many integer values as possible upto maxNumbers 
1460 REM from file fileName into the given array numbers. 
1470 REM Returns the number of the actually read numbers. May cause an exception. 
1480 REM TODO: Add type-specific suffixes where necessary! 
1490 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
1500   REM TODO: add the respective type suffixes to your variable names if required 
1510   REM  
1520   REM  
1530   LET nNumbers = 0
1540   LET fileNo = fileOpen(fileName)
1550   IF fileNo <= 0 THEN
1560     REM FIXME: Only a number is allowed as parameter: 
1570     ERROR "File could not be opened!"
1580   END IF
1590   ON ERROR GOTO 1670
1600   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
1610     LET number = fileReadInt(fileNo)
1620     LET numbers(nNumbers) = number
1630     LET nNumbers = nNumbers + 1
1640   LOOP
1650   GOTO 1700
1660   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
1670     REM FIXME: Only a number is allowed as parameter: 
1680     ERROR 
1690   REM End of error handler, resume here ... 
1700   ON ERROR GOTO 0
1710   fileClose(fileNo)
1720   RETURN nNumbers
1730 END FUNCTION
