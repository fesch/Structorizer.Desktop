10 REM Reads a random number file and draws a histogram accotrding to the 
20 REM user specifications 
30 REM Generated by Structorizer 3.30-11 
40 
50 REM Copyright (C) 2020-03-21 Kay GÃ¼rtzig 
60 REM License: GPLv3-link 
70 REM GNU General Public License (V 3) 
80 REM https://www.gnu.org/licenses/gpl.html 
90 REM http://www.gnu.de/documents/gpl.de.html 
100 
110 REM  
120 REM program DrawRandomHistogram
130 REM TODO: add the respective type suffixes to your variable names if required 
140 LET fileNo = -10
150 DO
160   PRINT "Name/path of the number file"; : INPUT file_name
170   LET fileNo = fileOpen(file_name)
180 LOOP UNTIL fileNo > 0 OR file_name = ""
190 IF fileNo > 0 THEN
200   fileClose(fileNo)
210   PRINT "number of intervals"; : INPUT nIntervals
220   REM Initialize the interval counters 
230   FOR k = 0 TO nIntervals-1
240     LET count(k) = 0
250   NEXT k
260   REM Index of the most populated interval 
270   LET kMaxCount = 0
280   REM TODO: Check indexBase value (automatically generated) 
290   LET indexBase = 0
300   LET nObtained = 0
310   ON ERROR GOTO 350
320   LET nObtained = readNumbers(file_name, numberArray, 10000)
330   GOTO 370
340   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
350     PRINT failure
360   REM End of error handler, resume here ... 
370   ON ERROR GOTO 0
380   IF nObtained > 0 THEN
390     LET min = numberArray(0)
400     LET max = numberArray(0)
410     FOR i = 1 TO nObtained-1
420       IF numberArray(i) < min THEN
430         LET min = numberArray(i)
440       ELSE
450         IF numberArray(i) > max THEN
460           LET max = numberArray(i)
470         END IF
480       END IF
490     NEXT i
500     REM Interval width 
510     LET width = (max - min) * 1.0 / nIntervals
520     FOR i = 0 TO nObtained - 1
530       LET value = numberArray(i)
540       LET k = 1
550       DO WHILE k < nIntervals AND value > min + k * width
560         LET k = k + 1
570       LOOP
580       LET count(k-1) = count(k-1) + 1
590       IF count(k-1) > count(kMaxCount) THEN
600         LET kMaxCount = k-1
610       END IF
620     NEXT i
630     CALL drawBarChart(count, nIntervals)
640     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
650     FOR k = 0 TO nIntervals-1
660       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
670     NEXT k
680   ELSE
690     PRINT "No numbers read."
700   END IF
710 END IF
720 END
730 REM  
740 REM Draws a bar chart from the array "values" of size nValues. 
750 REM Turtleizer must be activated and will scale the chart into a square of 
760 REM 500 x 500 pixels 
770 REM Note: The function is not robust against empty array or totally equal values. 
780 REM TODO: Add type-specific suffixes where necessary! 
790 SUB drawBarChart(values AS array of double, nValues)
800   REM TODO: add the respective type suffixes to your variable names if required 
810   REM Used range of the Turtleizer screen 
820   LET xSize = 500
830   LET ySize = 500
840   LET kMin = 0
850   LET kMax = 0
860   FOR k = 1 TO nValues-1
870     IF values(k) > values(kMax) THEN
880       LET kMax = k
890     ELSE
900       IF values(k) < values(kMin) THEN
910         LET kMin = k
920       END IF
930     END IF
940   NEXT k
950   LET valMin = values(kMin)
960   LET valMax = values(kMax)
970   LET yScale = valMax * 1.0 / (ySize - 1)
980   LET yAxis = ySize - 1
990   IF valMin < 0 THEN
1000     IF valMax > 0 THEN
1010       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
1020       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
1030     ELSE
1040       LET yAxis = 1
1050       LET yScale = valMin * 1.0 / (ySize - 1)
1060     END IF
1070   END IF
1080   REM draw coordinate axes 
1090   gotoXY(1, ySize - 1)
1100   forward(ySize -1) : REM color = ffffff
1110   penUp()
1120   backward(yAxis) : REM color = ffffff
1130   right(90)
1140   penDown()
1150   forward(xSize -1) : REM color = ffffff
1160   penUp()
1170   backward(xSize-1) : REM color = ffffff
1180   LET stripeWidth = xSize / nValues
1190   FOR k = 0 TO nValues-1
1200     LET stripeHeight = values(k) * 1.0 / yScale
1210     SELECT CASE k % 3
1220       CASE 0
1230         setPenColor(255,0,0)
1240       CASE 1
1250         setPenColor(0, 255,0)
1260       CASE 2
1270         setPenColor(0, 0, 255)
1280     END SELECT
1290     fd(1) : REM color = ffffff
1300     left(90)
1310     penDown()
1320     fd(stripeHeight) : REM color = ffffff
1330     right(90)
1340     fd(stripeWidth - 1) : REM color = ffffff
1350     right(90)
1360     forward(stripeHeight) : REM color = ffffff
1370     left(90)
1380     penUp()
1390   NEXT k
1400 END SUB
1410 REM  
1420 REM Tries to read as many integer values as possible upto maxNumbers 
1430 REM from file fileName into the given array numbers. 
1440 REM Returns the number of the actually read numbers. May cause an exception. 
1450 REM TODO: Add type-specific suffixes where necessary! 
1460 FUNCTION readNumbers(fileName AS String, numbers AS array of integer, maxNumbers AS integer) AS integer
1470   REM TODO: add the respective type suffixes to your variable names if required 
1480   LET nNumbers = 0
1490   LET fileNo = fileOpen(fileName)
1500   IF fileNo <= 0 THEN
1510     REM FIXME: Only a number is allowed as parameter: 
1520     ERROR "File could not be opened!"
1530   END IF
1540   ON ERROR GOTO 1620
1550   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
1560     LET number = fileReadInt(fileNo)
1570     LET numbers(nNumbers) = number
1580     LET nNumbers = nNumbers + 1
1590   LOOP
1600   GOTO 1650
1610   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
1620     REM FIXME: Only a number is allowed as parameter: 
1630     ERROR 
1640   REM End of error handler, resume here ... 
1650   ON ERROR GOTO 0
1660   fileClose(fileNo)
1670   RETURN nNumbers
1680 END FUNCTION
