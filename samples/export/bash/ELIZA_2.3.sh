#!/bin/bash

# Concept and lisp implementation published by Joseph Weizenbaum (MIT): 
# "ELIZA - A Computer Program For the Study of Natural Language Communication Between Man and Machine" - In: 
# Computational Linguistis 1(1966)9, pp. 36-45 
# Revision history: 
# 2016-10-06 Initial version 
# 2017-03-29 Two diagrams updated (comments translated to English) 
# 2017-03-29 More keywords and replies added 
# 2019-03-14 Replies and mapping reorganised for easier maintenance 
# 2019-03-15 key map joined from keyword array and index map 
# 2019-03-28 Keyword "bot" inserted (same reply ring as "computer") 
# 2019-11-28 New global type "History" (to ensure a homogenous array) 
# (generated by Structorizer 3.30-05) 
#  
# Copyright (C) 2018-05-14 Kay Gürtzig 
# License: GPLv3-link 
# GNU General Public License (V 3) 
# https://www.gnu.org/licenses/gpl.html 
# http://www.gnu.de/documents/gpl.de.html 
#  

# Cares for correct letter case among others 
adjustSpelling() {
 sentence=$1

# TODO: Check and revise the syntax of all expressions! 

 result=${sentence}
 position=1

 while [[ (${position} <= length(${sentence})) && (copy(${sentence}, ${position}, 1) == " ") ]]
 do
  position=$(( ${position} + 1 ))
 done

 if [[ ${position} <= length(${sentence}) ]]
 then
  start=$( copy "${sentence}" $( 1 ) "${position}" )
  delete "${result}" $( 1 ) "${position}"
  insert $( uppercase "${start}" ) "${result}" $( 1 )
 fi

 for word in " i " " i\'"
 do
  position=$( pos "${word}" "${result}" )

  while (( ${position} > 0 ))
  do
   delete "${result}" $(( ${position}+1 )) $( 1 )
   insert $( "I" ) "${result}" $(( ${position}+1 ))
   position=$( pos "${word}" "${result}" )
  done

 done

}

# Checks whether the given text contains some kind of 
# good-bye phrase inducing the end of the conversation 
# and if so writes a correspding good-bye message and 
# returns true, otherwise false 
checkGoodBye() {
 text=$1
 phrases=$2

# TODO: Check and revise the syntax of all expressions! 

 for pair in ${phrases[@]}
 do

  if [[ pos(${pair[0]}, ${text}) > 0 ]]
  then
   saidBye=1
   echo ${pair[1]}
   result40df09e5=1
   return 0
  fi

 done

 result40df09e5=0
}

# Checks whether newInput has occurred among the recently cached 
# input strings in the histArray component of history and updates the history. 
checkRepetition() {
 history=$1
 newInput=$2

# TODO: Check and revise the syntax of all expressions! 

declare -A history
declare -A history
 hasOccurred=0

 if [[ length(${newInput}) > 4 ]]
 then
  histDepth=$( length $( ${history[histArray]} ) )

  for (( i=0; i<=(( ${histDepth}-1 )); i++ ))
  do

   if [[ ${newInput} == ${history[histArray]}[${i}] ]]
   then
    hasOccurred=1
   fi

  done

  history[histArray][history[histIndex]]=${newInput}
  history[histIndex]=(${history[histIndex]} + 1) % (${histDepth})
 fi

 result4ab376f8=${hasOccurred}
}

conjugateStrings() {
 sentence=$1
 key=$2
 keyPos=$3
 flexions=$4

# TODO: Check and revise the syntax of all expressions! 

 result=" " + copy(${sentence}, ${keyPos} + length(${key}), length(${sentence})) + " "

 for pair in ${flexions[@]}
 do
  left=""
  right=${result}
  position=$( pos $( ${pair[0]} ) "${right}" )

  while (( ${position} > 0 ))
  do
   left=$(( ${left} + copy(${right}, 1, ${position}-1) + ${pair[1]} ))
   right=$( copy "${right}" $(( ${position} + length(${pair[0]}) )) $( length "${right}" ) )
   position=$( pos $( ${pair[0]} ) "${right}" )
  done

  result=$(( ${left} + ${right} ))
 done

 # Eliminate multiple spaces 
 position=$( pos $( "  " ) "${result}" )

 while (( ${position} > 0 ))
 do
  result=$(( copy(${result}, 1, ${position}-1) + copy(${result}, ${position}+1, length(${result})) ))
  position=$( pos $( "  " ) "${result}" )
 done

}

# Looks for the occurrence of the first of the strings 
# contained in keywords within the given sentence (in 
# array order). 
# Returns an array of 
# 0: the index of the first identified keyword (if any, otherwise -1), 
# 1: the position inside sentence (0 if not found) 
findKeyword() {
 keyMap=$1
 sentence=$2

# TODO: Check and revise the syntax of all expressions! 

declare -A entry
 # Contains the index of the keyword and its position in sentence 
 declare -a result=($(( -1 )) $( 0 ))
 i=0

 while [[ (${result[0]} < 0) && (${i} < length(${keyMap})) ]]
 do
  entry=${keyMap[${i}]}
  position=$( pos $( ${entry[keyword]} ) "${sentence}" )

  if (( ${position} > 0 ))
  then
   result[0]=${i}
   result[1]=${position}
  fi

  i=$(( ${i}+1 ))
 done

}

# Converts the sentence to lowercase, eliminates all 
# interpunction (i.e. ',', '.', ';'), and pads the 
# sentence among blanks 
normalizeInput() {
 sentence=$1

# TODO: Check and revise the syntax of all expressions! 

 sentence=$( lowercase "${sentence}" )

 for symbol in '.' ',' ';' '!' '?'
 do
  position=$( pos "${symbol}" "${sentence}" )

  while (( ${position} > 0 ))
  do
   sentence=$(( copy(${sentence}, 1, ${position}-1) + copy(${sentence}, ${position}+1, length(${sentence})) ))
   position=$( pos "${symbol}" "${sentence}" )
  done

 done

 result=" " + ${sentence} + " "
}

setupGoodByePhrases() {

# TODO: Check and revise the syntax of all expressions! 

 declare -a phrases[0]=($( " shut" ) $( "Okay. If you feel that way I\'ll shut up. ... Your choice." ))
 declare -a phrases[1]=($( "bye" ) $( "Well, let\'s end our talk for now. See you later. Bye." ))
 result43f4bc13=${phrases}
}

# The lower the index the higher the rank of the keyword (search is sequential). 
# The index of the first keyword found in a user sentence maps to a respective 
# reply ring as defined in `setupReplies()´. 
setupKeywords() {

# TODO: Check and revise the syntax of all expressions! 

 # The empty key string (last entry) is the default clause - will always be found 
 declare -a keywords[39]=([keyword]="" [index]=29)
 declare -a keywords[0]=([keyword]="can you " [index]=0)
 declare -a keywords[1]=([keyword]="can i " [index]=1)
 declare -a keywords[2]=([keyword]="you are " [index]=2)
 declare -a keywords[3]=([keyword]="you\'re " [index]=2)
 declare -a keywords[4]=([keyword]="i don't " [index]=3)
 declare -a keywords[5]=([keyword]="i feel " [index]=4)
 declare -a keywords[6]=([keyword]="why don\'t you " [index]=5)
 declare -a keywords[7]=([keyword]="why can\'t i " [index]=6)
 declare -a keywords[8]=([keyword]="are you " [index]=7)
 declare -a keywords[9]=([keyword]="i can\'t " [index]=8)
 declare -a keywords[10]=([keyword]="i am " [index]=9)
 declare -a keywords[11]=([keyword]="i\'m " [index]=9)
 declare -a keywords[12]=([keyword]="you " [index]=10)
 declare -a keywords[13]=([keyword]="i want " [index]=11)
 declare -a keywords[14]=([keyword]="what " [index]=12)
 declare -a keywords[15]=([keyword]="how " [index]=12)
 declare -a keywords[16]=([keyword]="who " [index]=12)
 declare -a keywords[17]=([keyword]="where " [index]=12)
 declare -a keywords[18]=([keyword]="when " [index]=12)
 declare -a keywords[19]=([keyword]="why " [index]=12)
 declare -a keywords[20]=([keyword]="name " [index]=13)
 declare -a keywords[21]=([keyword]="cause " [index]=14)
 declare -a keywords[22]=([keyword]="sorry " [index]=15)
 declare -a keywords[23]=([keyword]="dream " [index]=16)
 declare -a keywords[24]=([keyword]="hello " [index]=17)
 declare -a keywords[25]=([keyword]="hi " [index]=17)
 declare -a keywords[26]=([keyword]="maybe " [index]=18)
 declare -a keywords[27]=([keyword]=" no" [index]=19)
 declare -a keywords[28]=([keyword]="your " [index]=20)
 declare -a keywords[29]=([keyword]="always " [index]=21)
 declare -a keywords[30]=([keyword]="think " [index]=22)
 declare -a keywords[31]=([keyword]="alike " [index]=23)
 declare -a keywords[32]=([keyword]="yes " [index]=24)
 declare -a keywords[33]=([keyword]="friend " [index]=25)
 declare -a keywords[34]=([keyword]="computer" [index]=26)
 declare -a keywords[35]=([keyword]="bot " [index]=26)
 declare -a keywords[36]=([keyword]="smartphone" [index]=27)
 declare -a keywords[37]=([keyword]="father " [index]=28)
 declare -a keywords[38]=([keyword]="mother " [index]=28)
 resultf3ad8b75=${keywords}
}

# Returns an array of pairs of mutualy substitutable  
setupReflexions() {

# TODO: Check and revise the syntax of all expressions! 

 declare -a reflexions[0]=($( " are " ) $( " am " ))
 declare -a reflexions[1]=($( " were " ) $( " was " ))
 declare -a reflexions[2]=($( " you " ) $( " I " ))
 declare -a reflexions[3]=($( " your" ) $( " my" ))
 declare -a reflexions[4]=($( " i\'ve " ) $( " you\'ve " ))
 declare -a reflexions[5]=($( " i\'m " ) $( " you\'re " ))
 declare -a reflexions[6]=($( " me " ) $( " you " ))
 declare -a reflexions[7]=($( " my " ) $( " your " ))
 declare -a reflexions[8]=($( " i " ) $( " you " ))
 declare -a reflexions[9]=($( " am " ) $( " are " ))
 result90049b69=${reflexions}
}

# This routine sets up the reply rings addressed by the key words defined in 
# routine `setupKeywords()´ and mapped hitherto by the cross table defined 
# in `setupMapping()´ 
setupReplies() {

# TODO: Check and revise the syntax of all expressions! 

 # We start with the highest index for performance reasons 
 # (is to avoid frequent array resizing) 
 declare -a replies[29]=($( "Say, do you have any psychological problems?" ) $( "What does that suggest to you?" ) $( "I see." ) $( "I'm not sure I understand you fully." ) $( "Come come elucidate your thoughts." ) $( "Can you elaborate on that?" ) $( "That is quite interesting." ))
 declare -a replies[0]=($( "Don't you believe that I can*?" ) $( "Perhaps you would like to be like me?" ) $( "You want me to be able to*?" ))
 declare -a replies[1]=($( "Perhaps you don't want to*?" ) $( "Do you want to be able to*?" ))
 declare -a replies[2]=($( "What makes you think I am*?" ) $( "Does it please you to believe I am*?" ) $( "Perhaps you would like to be*?" ) $( "Do you sometimes wish you were*?" ))
 declare -a replies[3]=($( "Don't you really*?" ) $( "Why don't you*?" ) $( "Do you wish to be able to*?" ) $( "Does that trouble you*?" ))
 declare -a replies[4]=($( "Do you often feel*?" ) $( "Are you afraid of feeling*?" ) $( "Do you enjoy feeling*?" ))
 declare -a replies[5]=($( "Do you really believe I don't*?" ) $( "Perhaps in good time I will*." ) $( "Do you want me to*?" ))
 declare -a replies[6]=($( "Do you think you should be able to*?" ) $( "Why can't you*?" ))
 declare -a replies[7]=($( "Why are you interested in whether or not I am*?" ) $( "Would you prefer if I were not*?" ) $( "Perhaps in your fantasies I am*?" ))
 declare -a replies[8]=($( "How do you know you can't*?" ) $( "Have you tried?" ) $( "Perhaps you can now*." ))
 declare -a replies[9]=($( "Did you come to me because you are*?" ) $( "How long have you been*?" ) $( "Do you believe it is normal to be*?" ) $( "Do you enjoy being*?" ))
 declare -a replies[10]=($( "We were discussing you--not me." ) $( "Oh, I*." ) $( "You're not really talking about me, are you?" ))
 declare -a replies[11]=($( "What would it mean to you if you got*?" ) $( "Why do you want*?" ) $( "Suppose you soon got*..." ) $( "What if you never got*?" ) $( "I sometimes also want*." ))
 declare -a replies[12]=($( "Why do you ask?" ) $( "Does that question interest you?" ) $( "What answer would please you the most?" ) $( "What do you think?" ) $( "Are such questions on your mind often?" ) $( "What is it that you really want to know?" ) $( "Have you asked anyone else?" ) $( "Have you asked such questions before?" ) $( "What else comes to mind when you ask that?" ))
 declare -a replies[13]=($( "Names don't interest me." ) $( "I don't care about names -- please go on." ))
 declare -a replies[14]=($( "Is that the real reason?" ) $( "Don't any other reasons come to mind?" ) $( "Does that reason explain anything else?" ) $( "What other reasons might there be?" ))
 declare -a replies[15]=($( "Please don't apologize!" ) $( "Apologies are not necessary." ) $( "What feelings do you have when you apologize?" ) $( "Don't be so defensive!" ))
 declare -a replies[16]=($( "What does that dream suggest to you?" ) $( "Do you dream often?" ) $( "What persons appear in your dreams?" ) $( "Are you disturbed by your dreams?" ))
 declare -a replies[17]=($( "How do you do ...please state your problem." ))
 declare -a replies[18]=($( "You don't seem quite certain." ) $( "Why the uncertain tone?" ) $( "Can't you be more positive?" ) $( "You aren't sure?" ) $( "Don't you know?" ))
 declare -a replies[19]=($( "Are you saying no just to be negative?" ) $( "You are being a bit negative." ) $( "Why not?" ) $( "Are you sure?" ) $( "Why no?" ))
 declare -a replies[20]=($( "Why are you concerned about my*?" ) $( "What about your own*?" ))
 declare -a replies[21]=($( "Can you think of a specific example?" ) $( "When?" ) $( "What are you thinking of?" ) $( "Really, always?" ))
 declare -a replies[22]=($( "Do you really think so?" ) $( "But you are not sure you*?" ) $( "Do you doubt you*?" ))
 declare -a replies[23]=($( "In what way?" ) $( "What resemblance do you see?" ) $( "What does the similarity suggest to you?" ) $( "What other connections do you see?" ) $( "Could there really be some connection?" ) $( "How?" ) $( "You seem quite positive." ))
 declare -a replies[24]=($( "Are you sure?" ) $( "I see." ) $( "I understand." ))
 declare -a replies[25]=($( "Why do you bring up the topic of friends?" ) $( "Do your friends worry you?" ) $( "Do your friends pick on you?" ) $( "Are you sure you have any friends?" ) $( "Do you impose on your friends?" ) $( "Perhaps your love for friends worries you." ))
 declare -a replies[26]=($( "Do computers worry you?" ) $( "Are you talking about me in particular?" ) $( "Are you frightened by machines?" ) $( "Why do you mention computers?" ) $( "What do you think machines have to do with your problem?" ) $( "Don't you think computers can help people?" ) $( "What is it about machines that worries you?" ))
 declare -a replies[27]=($( "Do you sometimes feel uneasy without a smartphone?" ) $( "Have you had these phantasies before?" ) $( "Does the world seem more real for you via apps?" ))
 declare -a replies[28]=($( "Tell me more about your family." ) $( "Who else in your family*?" ) $( "What does family relations mean for you?" ) $( "Come on, How old are you?" ))
 setupReplies=${replies}
}


# TODO: Check and revise the syntax of all expressions! 

declare -A history
declare -A entry
# Title information 
echo "************* ELIZA **************"
echo "* Original design by J. Weizenbaum"
echo "**********************************"
echo "* Adapted for Basic on IBM PC by"
echo "* - Patricia Danielson"
echo "* - Paul Hashfield"
echo "**********************************"
echo "* Adapted for Structorizer by"
echo "* - Kay Gürtzig / FH Erfurt 2016"
echo "* Version: 2.3 (2019-11-28)"
echo "* (Requires at least Structorizer 3.30-03 to run)"
echo "**********************************"
# Stores the last five inputs of the user in a ring buffer, 
# the second component is the rolling (over-)write index. 
declare -a history=([histArray]={"", "", "", "", ""} [histIndex]=0)
setupReplies
replies=${resultd65407bf}
setupReflexions
reflexions=${result90049b69}
setupGoodByePhrases
byePhrases=${result43f4bc13}
setupKeywords
keyMap=${resultf3ad8b75}
offsets[length(${keyMap})-1]=0
isGone=0
# Starter 
echo "Hi! I\'m your new therapist. My name is Eliza. What\'s your problem?"

# NOTE: This is an automatically inserted copy of the loop body below. 
read userInput
# Converts the input to lowercase, cuts out interpunctation 
# and pads the string 
normalizeInput "${userInput}"
userInput=${result3b9bb2c0}
checkGoodBye "${userInput}" "${byePhrases}"
isGone=${result40df09e5}

if [[ ! ${isGone} ]]
then
 reply="Please don\'t repeat yourself!"
 checkRepetition "${history}" "${userInput}"
 isRepeated=${result4ab376f8}

 if [[ ! ${isRepeated} ]]
 then
  findKeyword "${keyMap}" "${userInput}"
  findInfo=${resulte6dd578d}
  keyIndex=${findInfo[0]}

  if [[ ${keyIndex} < 0 ]]
  then
   # Should never happen... 
   keyIndex=$(( length(${keyMap})-1 ))
  fi

  entry=${keyMap[${keyIndex}]}
  # Variable part of the reply 
  varPart=""

  if [[ length(${entry[keyword]}) > 0 ]]
  then
   conjugateStrings "${userInput}" $( ${entry[keyword]} ) $( ${findInfo[1]} ) "${reflexions}"
   varPart=${result43027daf}
  fi

  replyRing=${replies[${entry[index]}]}
  reply=${replyRing[${offsets[${keyIndex}]}]}
  offsets[${keyIndex}]=(${offsets[${keyIndex}]} + 1) % length(${replyRing})
  posAster=$( pos $( "*" ) "${reply}" )

  if (( ${posAster} > 0 ))
  then

   if [[ ${varPart} == " " ]]
   then
    reply="You will have to elaborate more for me to help you."

   else
    delete "${reply}" "${posAster}" $( 1 )
    insert "${varPart}" "${reply}" "${posAster}"
   fi

  fi

  adjustSpelling "${reply}"
  reply=${resultc70da95b}
 fi

 echo ${reply}
fi

while [[ ${isGone} ]]
do
 read userInput
 # Converts the input to lowercase, cuts out interpunctation 
 # and pads the string 
 normalizeInput "${userInput}"
 userInput=${result3b9bb2c0}
 checkGoodBye "${userInput}" "${byePhrases}"
 isGone=${result40df09e5}

 if [[ ! ${isGone} ]]
 then
  reply="Please don\'t repeat yourself!"
  checkRepetition "${history}" "${userInput}"
  isRepeated=${result4ab376f8}

  if [[ ! ${isRepeated} ]]
  then
   findKeyword "${keyMap}" "${userInput}"
   findInfo=${resulte6dd578d}
   keyIndex=${findInfo[0]}

   if [[ ${keyIndex} < 0 ]]
   then
    # Should never happen... 
    keyIndex=$(( length(${keyMap})-1 ))
   fi

   entry=${keyMap[${keyIndex}]}
   # Variable part of the reply 
   varPart=""

   if [[ length(${entry[keyword]}) > 0 ]]
   then
    conjugateStrings "${userInput}" $( ${entry[keyword]} ) $( ${findInfo[1]} ) "${reflexions}"
    varPart=${result43027daf}
   fi

   replyRing=${replies[${entry[index]}]}
   reply=${replyRing[${offsets[${keyIndex}]}]}
   offsets[${keyIndex}]=(${offsets[${keyIndex}]} + 1) % length(${replyRing})
   posAster=$( pos $( "*" ) "${reply}" )

   if (( ${posAster} > 0 ))
   then

    if [[ ${varPart} == " " ]]
    then
     reply="You will have to elaborate more for me to help you."

    else
     delete "${reply}" "${posAster}" $( 1 )
     insert "${varPart}" "${reply}" "${posAster}"
    fi

   fi

   adjustSpelling "${reply}"
   reply=${resultc70da95b}
  fi

  echo ${reply}
 fi

done

