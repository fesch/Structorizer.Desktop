{
  Concept and lisp implementation published by Joseph Weizenbaum (MIT):
  "ELIZA - A Computer Program For the Study of Natural Language Communication Between Man and Machine" - In:
  Computational Linguistis 1(1966)9, pp. 36-45
  Revision history:
  2016-10-06 Initial version
  2017-03-29 Two diagrams updated (comments translated to English)
  2017-03-29 More keywords and replies added
  2019-03-14 Replies and mapping reorganised for easier maintenance
  2019-03-15 key map joined from keyword array and index map
  2019-03-28 Keyword "bot" inserted (same reply ring as "computer")
  2019-11-28 New global type "History" (to ensure a homogenous array)
}
program ELIZA;
{ Generated by Structorizer 3.32-01 }

{ Copyright (C) 2018-05-14 Kay Gürtzig }
{ License: GPLv3-link }
{
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
}

type
  History = RECORD
      histArray:	array [0..49] of string;
      histIndex:	Longint;
    END;

  KeyMapEntry = RECORD
      keyword:	string;
      index:	Longint;
    END;

const
  replies = setupReplies();
  
  reflexions = setupReflexions();
  
  byePhrases = setupGoodByePhrases();
  
  keyMap = setupKeywords();

var
  varPart: String;
  {
    Converts the input to lowercase, cuts out interpunctation
    and pads the string
  }
  userInput: string;
  replyRing: array [0..49] of string;
  reply: String;
  posAster: Longint;
  offsets: array [0..49] of Longint;
  { Should never happen... }
  keyIndex: Longint;
  isRepeated: boolean;
  isGone: boolean;
  {
    Stores the last five inputs of the user in a ring buffer,
    the second component is the rolling (over-)write index.
  }
  history: History;
  findInfo: array [0..1] of Longint;
  entry: KeyMapEntry;

begin
  { Title information }
  writeln('************* ELIZA **************');
  writeln('* Original design by J. Weizenbaum');
  writeln('**********************************');
  writeln('* Adapted for Basic on IBM PC by');
  writeln('* - Patricia Danielson');
  writeln('* - Paul Hashfield');
  writeln('**********************************');
  writeln('* Adapted for Structorizer by');
  writeln('* - Kay Gürtzig / FH Erfurt 2016');
  writeln('* Version: 2.3 (2020-02-24)');
  writeln('* (Requires at least Structorizer 3.30-03 to run)');
  writeln('**********************************');
  {
    Stores the last five inputs of the user in a ring buffer,
    the second component is the rolling (over-)write index.
  }
  { Hint: Automatically decomposed array initialization }
  history.histArray[0] := '';
  history.histArray[1] := '';
  history.histArray[2] := '';
  history.histArray[3] := '';
  history.histArray[4] := '';
  history.histIndex := 0;
  replies := setupReplies();
  reflexions := setupReflexions();
  byePhrases := setupGoodByePhrases();
  keyMap := setupKeywords();
  offsets[length(keyMap)-1] := 0;
  isGone := false;
  { Starter }
  writeln('Hi! I\''m your new therapist. My name is Eliza. What\''s your problem?');
  repeat
    readln(userInput);
    {
      Converts the input to lowercase, cuts out interpunctation
      and pads the string
    }
    userInput := normalizeInput(userInput);
    isGone := checkGoodBye(userInput, byePhrases);
    if (not isGone) then
    begin
      reply := 'Please don\''t repeat yourself!';
      isRepeated := checkRepetition(history, userInput);
      if (not isRepeated) then
      begin
        findInfo := findKeyword(keyMap, userInput);
        keyIndex := findInfo[0];
        if (keyIndex < 0) then
        begin
          { Should never happen... }
          keyIndex := length(keyMap)-1;
        end;
        entry := keyMap[keyIndex];
        { Variable part of the reply }
        varPart := '';
        if (length(entry.keyword) > 0) then
        begin
          varPart := conjugateStrings(userInput, entry.keyword, findInfo[1], reflexions);
        end;
        replyRing := replies[entry.index];
        reply := replyRing[offsets[keyIndex]];
        offsets[keyIndex] := (offsets[keyIndex] + 1) mod length(replyRing);
        posAster := pos('*', reply);
        if (posAster > 0) then
        begin
          if (varPart = ' ') then
          begin
            reply := 'You will have to elaborate more for me to help you.';
          end
          else
          begin
            delete(reply, posAster, 1);
            insert(varPart, reply, posAster);
          end;
        end;
        reply := adjustSpelling(reply);
      end;
      writeln(reply);
    end;
    until (isGone);
end.
