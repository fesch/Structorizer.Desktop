program SORTING_TEST_MAIN;
{ Generated by Structorizer 3.30-07 }

{ Copyright (C) 2019-10-02 Kay Gürtzig }
{ License: GPLv3-link }
{
* GNU General Public License (V 3)
* https://www.gnu.org/licenses/gpl.html
* http://www.gnu.de/documents/gpl.de.html
}

{
* Creates three equal arrays of numbers and has them sorted with different sorting algorithms
* to allow performance comparison via execution counting ("Collect Runtime Data" should
* sensibly be switched on).
* Requested input data are: Number of elements (size) and filing mode.
}

var
  values3: array of ???;	{ FIXME! }
  values2: array of ???;	{ FIXME! }
  values1: array of Longint;
  show: ???;	{ FIXME! }
  ok3: Boolean;
  ok2: Boolean;
  ok1: Boolean;
  modus: ???;	{ FIXME! }
  i: Longint;
  elementCount: ???;	{ FIXME! }

{
* Implements the well-known BubbleSort algorithm.
* Compares neigbouring elements and swaps them in case of an inversion.
* Repeats this while inversions have been found. After every
* loop passage at least one element (the largest one out of the
* processed subrange) finds its final place at the end of the
* subrange.
}
procedure bubbleSort(values: ???);

var
  temp: ???;	{ FIXME! }
  posSwapped: ???;	{ FIXME! }
  i: Longint;
  ende: ???;	{ FIXME! }

begin
  ende := length(values) - 2;
  repeat
    { The index of the most recent swapping (-1 means no swapping done). }
    posSwapped := -1;
    for i := 0 to ende do
    begin
      if (values[i] > values[i+1]) then
      begin
        temp := values[i];
        values[i] := values[i+1];
        values[i+1] := temp;
        posSwapped := i;
      end;
    end;
    ende := posSwapped - 1;
    until (posSwapped < 0);

end;

{
* Given a max-heap 'heap´ with element at index 'i´ possibly
* violating the heap property wrt. its subtree upto and including
* index range-1, restores heap property in the subtree at index i
* again.
}
procedure maxHeapify(heap: ???; i: ???; range: ???);

var
  temp: ???;	{ FIXME! }
  { Indices of left and right child of node i }
  right: ???;	{ FIXME! }
  max: ???;	{ FIXME! }
  { Indices of left and right child of node i }
  left: ???;	{ FIXME! }

begin
  { Indices of left and right child of node i }
  right := (i+1) * 2;
  left := right - 1;
  { Index of the (local) maximum }
  max := i;
  if (left < range and heap[left] > heap[i]) then
  begin
    max := left;
  end;
  if (right < range and heap[right] > heap[max]) then
  begin
    max := right;
  end;
  if (max <> i) then
  begin
    temp := heap[i];
    heap[i] := heap[max];
    heap[max] := temp;
    maxHeapify(heap, max, range);
  end;

end;

{
* Partitions array 'values´ between indices 'start´ und 'stop´-1 with
* respect to the pivot element initially at index 'p´ into smaller
* and greater elements.
* Returns the new (and final) index of the pivot element (which
* separates the sequence of smaller elements from the sequence
* of greater elements).
* This is not the most efficient algorithm (about half the swapping
* might still be avoided) but it is pretty clear.
}
function partition(values: ???; start: ???; stop: ???; p: ???): Longint;

var
  { Fetch the first element of the undiscovered area }
  seen: ???;	{ FIXME! }
  { Cache the pivot element }
  pivot: ???;	{ FIXME! }

begin
  { Cache the pivot element }
  pivot := values[p];
  { Exchange the pivot element with the start element }
  values[p] := values[start];
  values[start] := pivot;
  p := start;
  { Beginning and end of the remaining undiscovered range }
  start := start + 1;
  stop := stop - 1;
  {
  * Still unseen elements?
  * Loop invariants:
  * 1. p = start - 1
  * 2. pivot = values[p]
  * 3. i < start → values[i] ≤ pivot
  * 4. stop < i → pivot < values[i]
  }
  while (start <= stop) do
  begin
    { Fetch the first element of the undiscovered area }
    seen := values[start];
    { Does the checked element belong to the smaller area? }
    if (seen <= pivot) then
    begin
      { Insert the seen element between smaller area and pivot element }
      values[p] := seen;
      values[start] := pivot;
      {
      * Shift the border between lower and undicovered area,
      * update pivot position.
      }
      p := p + 1;
      start := start + 1;
    end
    else
    begin
      { Insert the checked element between undiscovered and larger area }
      values[start] := values[stop];
      values[stop] := seen;
      { Shift the border between undiscovered and larger area }
      stop := stop - 1;
    end;
  end;
  partition := p;

end;

{ Checks whether or not the passed-in array is (ascendingly) sorted. }
function testSorted(numbers: ???): Boolean;

var
  isSorted: boolean;
  i: Longint;

begin
  isSorted := true;
  i := 0;
  { As we compare with the following element, we must stop at the penultimate index }
  while isSorted and (i <= length(numbers)-2) do
  begin
    { Is there an inversion? }
    if (numbers[i] > numbers[i+1]) then
    begin
      isSorted := false;
    end
    else
    begin
      i := i + 1;
    end;
  end;
  testSorted := isSorted;

end;

{
* Runs through the array heap and converts it to a max-heap
* in a bottom-up manner, i.e. starts above the "leaf" level
* (index >= length(heap) div 2) and goes then up towards
* the root.
}
procedure buildMaxHeap(heap: ???);

var
  lgth: Longint;
  k: Longint;

begin
  lgth := length(heap);
  for k := lgth div 2 - 1 downto 0 do
  begin
    maxHeapify(heap, k, lgth);
  end;

end;

{
* Recursively sorts a subrange of the given array 'values´. 
* start is the first index of the subsequence to be sorted,
* stop is the index BEHIND the subsequence to be sorted.
}
procedure quickSort(values: ???; start: ???; stop: ???);

var
  {
  * Partition the array into smaller and greater elements
  * Get the resulting (and final) position of the pivot element
  }
  p: ???;	{ FIXME! }

begin
  { At least 2 elements? (Less don't make sense.) }
  if (stop >= start + 2) then
  begin
    {
    * Select a pivot element, be p its index.
    * (here: randomly chosen element out of start ... stop-1)
    }
    p := random(stop-start) + start;
    {
    * Partition the array into smaller and greater elements
    * Get the resulting (and final) position of the pivot element
    }
    p := partition(values, start, stop, p);
    { Sort subsequances separately and independently ... }

    { ========================================================== }
    { ================= START PARALLEL SECTION ================= }
    { ========================================================== }
    { TODO: add the necessary code to run the threads concurrently }
    begin

      { ----------------- START THREAD 0 ----------------- }
      begin
        { Sort left (lower) array part }
        quickSort(values, start, p);
      end;
      { ------------------ END THREAD 0 ------------------ }


      { ----------------- START THREAD 1 ----------------- }
      begin
        { Sort right (higher) array part }
        quickSort(values, p+1, stop);
      end;
      { ------------------ END THREAD 1 ------------------ }

    end;
    { ========================================================== }
    { ================== END PARALLEL SECTION ================== }
    { ========================================================== }

  end;

end;

{
* Sorts the array 'values´ of numbers according to he heap sort
* algorithm
}
procedure heapSort(values: ???);

var
  { Swap the maximum value (root of the heap) to the heap end }
  maximum: ???;	{ FIXME! }
  k: Longint;
  heapRange: Longint;

begin
  buildMaxHeap(values);
  heapRange := length(values);
  for k := heapRange - 1 downto 1 do
  begin
    heapRange := heapRange - 1;
    { Swap the maximum value (root of the heap) to the heap end }
    maximum := values[0];
    values[0] := values[heapRange];
    values[heapRange] := maximum;
    maxHeapify(values, 0, heapRange);
  end;

end;

begin
  repeat
    readln(elementCount);
    until (elementCount >= 1);
  repeat
    write('Filling: 1 = random, 2 = increasing, 3 = decreasing'); readln(modus);
    until (modus = 1 or modus = 2 or modus = 3);
  for i := 0 to elementCount-1 do
  begin
    case (modus) of
      1:
        begin
          values1[i] := random(10000);
        end;
      2:
        begin
          values1[i] := i;
        end;
      3:
        begin
          values1[i] := -i;
        end;
    end;
  end;
  { Copy the array for exact comparability }
  for i := 0 to elementCount-1 do
  begin
    values2[i] := values1[i];
    values3[i] := values1[i];
  end;

  { ========================================================== }
  { ================= START PARALLEL SECTION ================= }
  { ========================================================== }
  { TODO: add the necessary code to run the threads concurrently }
  begin

    { ----------------- START THREAD 0 ----------------- }
    begin
      bubbleSort(values1);
    end;
    { ------------------ END THREAD 0 ------------------ }


    { ----------------- START THREAD 1 ----------------- }
    begin
      quickSort(values2, 0, elementCount);
    end;
    { ------------------ END THREAD 1 ------------------ }


    { ----------------- START THREAD 2 ----------------- }
    begin
      heapSort(values3);
    end;
    { ------------------ END THREAD 2 ------------------ }

  end;
  { ========================================================== }
  { ================== END PARALLEL SECTION ================== }
  { ========================================================== }

  ok1 := testSorted(values1);
  ok2 := testSorted(values2);
  ok3 := testSorted(values3);
  if (not ok1 or not ok2 or not ok3) then
  begin
    for i := 0 to elementCount-1 do
    begin
      if (values1[i] <> values2[i] or values1[i] <> values3[i]) then
      begin
        writeln('Difference at [', i, ']: ', values1[i], ' <-> ', values2[i], ' <-> ', values3[i]);
      end;
    end;
  end;
  repeat
    write('Show arrays (yes/no)?'); readln(show);
    until (show = 'yes' or show = 'no');
  if (show = 'yes') then
  begin
    for i := 0 to elementCount - 1 do
    begin
      writeln('[', i, ']:\t', values1[i], '\t', values2[i], '\t', values3[i]);
    end;
  end;
end.
