// Generated by Structorizer 3.32-20 

// Copyright (C) 2024-04-03 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

import lu.fisch.structorizer.generators.StructorizerFileAPI;

/**
 * NOTE:
 * This first module of the file is a library module providing common resources
 * for the following modules, which are separated by comment lines like
 * "======= 8< =======...".
 * You may have to cut this file apart at these lines in order to get the parts
 * running, since the following modules may form sort of mutually independent
 * applications or programs the coexistence of which in a single file might not
 * be sensible.
 */
public class FileApiGroupTest_arrz {

	/**
	 * Flag ensures that initialisation method {@link #initialize_FileApiGroupTest_arrz()}
	 *  runs just one time.
	 */
	private static boolean initDone_FileApiGroupTest_arrz = false;

	/**
	 * Initialisation method for this library class
	 */
	public static void initialize_FileApiGroupTest_arrz() {
		// TODO: Check and accomplish variable declarations: 

		if (!initDone_FileApiGroupTest_arrz) {
			
			initDone_FileApiGroupTest_arrz = true;
		}
	}

	/**
	 * Draws a bar chart from the array "values" of size nValues.
	 * Turtleizer must be activated and will scale the chart into a square of
	 * 500 x 500 pixels
	 * Note: The function is not robust against empty array or totally equal values.
	 * @param values
	 * @param nValues
	 */
	public static void drawBarChart(double[] values, ??? nValues) {
		// TODO: Check and accomplish variable declarations: 
		// Used range of the Turtleizer screen 
		final int xSize = 500;
		final int ySize = 500;
		double valMin;
		double valMax;
		int kMin;
		int kMax;

		kMin = 0;
		kMax = 0;
		for (int k = 1; k <= nValues-1; k += (1)) {
			if (values[k] > values[kMax]) {
				kMax = k;
			}
			else if (values[k] < values[kMin]) {
				kMin = k;
			}
		}
		valMin = values[kMin];
		valMax = values[kMax];
		??? yScale = valMax * 1.0 / (ySize - 1);
		??? yAxis = ySize - 1;
		if (valMin < 0) {
			if (valMax > 0) {
				yAxis = valMax * ySize * 1.0 / (valMax - valMin);
				yScale = (valMax - valMin) * 1.0 / (ySize - 1);
			}
			else {
				yAxis = 1;
				yScale = valMin * 1.0 / (ySize - 1);
			}
		}
		// draw coordinate axes 
		Turtleizer.gotoXY(1, ySize - 1);
		Turtleizer.forward(ySize -1, java.awt.Color.decode("0xffffff"));
		Turtleizer.penUp();
		Turtleizer.backward(yAxis, java.awt.Color.decode("0xffffff"));
		Turtleizer.right(90);
		Turtleizer.penDown();
		Turtleizer.forward(xSize -1, java.awt.Color.decode("0xffffff"));
		Turtleizer.penUp();
		Turtleizer.backward(xSize-1, java.awt.Color.decode("0xffffff"));
		??? stripeWidth = xSize / nValues;
		for (int k = 0; k <= nValues-1; k += (1)) {
			??? stripeHeight = values[k] * 1.0 / yScale;
			switch (k % 3) {
			case 0:
				Turtleizer.setPenColor(255,0,0);
				break;
			case 1:
				Turtleizer.setPenColor(0, 255,0);
				break;
			case 2:
				Turtleizer.setPenColor(0, 0, 255);
				break;
			}
			Turtleizer.fd(1, java.awt.Color.decode("0xffffff"));
			Turtleizer.left(90);
			Turtleizer.penDown();
			Turtleizer.fd(stripeHeight, java.awt.Color.decode("0xffffff"));
			Turtleizer.right(90);
			Turtleizer.fd(stripeWidth - 1, java.awt.Color.decode("0xffffff"));
			Turtleizer.right(90);
			Turtleizer.forward(stripeHeight, java.awt.Color.decode("0xffffff"));
			Turtleizer.left(90);
			Turtleizer.penUp();
		}
	}

	/**
	 * Tries to read as many integer values as possible upto maxNumbers
	 * from file fileName into the given array numbers.
	 * Returns the number of the actually read numbers. May cause an exception.
	 * @param fileName
	 * @param numbers
	 * @param maxNumbers
	 * @return 
	 */
	public static int readNumbers(String fileName, int[] numbers, int maxNumbers) {
		// TODO: Check and accomplish variable declarations: 
		int number;
		int nNumbers;
		int fileNo;

		nNumbers = 0;
		fileNo = fileOpen(fileName);
		if (fileNo <= 0) {
			throw "File could not be opened!";
		}
		try {
			while (! fileEOF(fileNo) && nNumbers < maxNumbers) {
				number = fileReadInt(fileNo);
				numbers[nNumbers] = number;
				nNumbers = nNumbers + 1;
			}
		}
		catch (Exception ex296eb024) {
			String error = ex296eb024.getMessage()
			throw ex296eb024;
		}
		finally {
			fileClose(fileNo);
		}
		return nNumbers;
	}

}

// ======= 8< =========================================================== 

// Generated by Structorizer 3.32-20 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

import FileApiGroupTest_arrz;
import java.util.Scanner;

// TODO: Download the turtle package from https://structorizer.fisch.lu and put it into this project
import lu.fisch.turtle.adapters.Turtleizer;
/**
 * Computes the sum and average of the numbers read from a user-specified
 * text file (which might have been created via generateRandomNumberFile(4)).
 * 
 * This program is part of an arrangement used to test group code export (issue
 * #828) with FileAPI dependency.
 * The input check loop has been disabled (replaced by a simple unchecked input
 * instruction) in order to test the effect of indirect FileAPI dependency (only the
 * called subroutine directly requires FileAPI now).
 */
public class ComputeSum {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		FileApiGroupTest_arrz.initializeFileApiGroupTest_arrz();
		// TODO: Check and accomplish variable declarations: 
		???[] values;
		double sum;
		int nValues;
		??? file_name;
		int fileNo;

		// TODO: You may have to modify input instructions, 
		//       e.g. by replacing nextLine() with a more suitable call 
		//       according to the variable type, say nextInt(). 

		fileNo = 1000;
		// Disable this if you enable the loop below! 
		System.out.print("Name/path of the number file"); file_name = (new Scanner(System.in)).nextLine();
		// If you enable this loop, then the preceding input instruction is to be disabled 
		// and the fileClose instruction in the alternative below is to be enabled. 
// 		do { 
// 			System.out.print("Name/path of the number file"); file_name = (new Scanner(System.in)).nextLine(); 
// 			fileNo = fileOpen(file_name); 
// 		} while (! (fileNo > 0 || file_name == "")); 
		if (fileNo > 0) {
			// This should be enabled if the input check loop above gets enabled. 
// 			fileClose(fileNo); 
			values = new ???[]{};
			nValues = 0;
			try {
				nValues = FileApiGroupTest_arrz.readNumbers(file_name, values, 1000);
			}
			catch (Exception ex8d3ca0d) {
				String failure = ex8d3ca0d.getMessage()
				System.out.println(failure);
				System.exit(-7)
			}
			sum = 0.0;
			for (int k = 0; k <= nValues-1; k += (1)) {
				sum = sum + values[k];
			}
			System.out.println(("sum = ") + (sum));
			System.out.println(("average = ") + (sum / nValues));
		}
	}

}

// ======= 8< =========================================================== 

// Generated by Structorizer 3.32-20 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

import FileApiGroupTest_arrz;
import lu.fisch.structorizer.generators.StructorizerFileAPI;
import java.util.Scanner;

// TODO: Download the turtle package from https://structorizer.fisch.lu and put it into this project
import lu.fisch.turtle.adapters.Turtleizer;
/**
 * Reads a random number file and draws a histogram accotrding to the
 * user specifications
 */
public class DrawRandomHistogram {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		FileApiGroupTest_arrz.initializeFileApiGroupTest_arrz();
		// TODO: Check and accomplish variable declarations: 
		???[] numberArray;
		int nObtained;
		??? nIntervals;
		int kMaxCount;
		??? file_name;
		int fileNo;
		int[] count;

		// TODO: You may have to modify input instructions, 
		//       e.g. by replacing nextLine() with a more suitable call 
		//       according to the variable type, say nextInt(). 

		fileNo = -10;
		do {
			System.out.print("Name/path of the number file"); file_name = (new Scanner(System.in)).nextLine();
			fileNo = StructorizerFileAPI.fileOpen(file_name);
		} while (! (fileNo > 0 || file_name == ""));
		if (fileNo > 0) {
			StructorizerFileAPI.fileClose(fileNo);
			System.out.print("number of intervals"); nIntervals = (new Scanner(System.in)).nextLine();
			// Initialize the interval counters 
			for (int k = 0; k <= nIntervals-1; k += (1)) {
				count[k] = 0;
			}
			// Index of the most populated interval 
			kMaxCount = 0;
			numberArray = new ???[]{};
			nObtained = 0;
			try {
				nObtained = FileApiGroupTest_arrz.readNumbers(file_name, numberArray, 10000);
			}
			catch (Exception ex6d5a8719) {
				String failure = ex6d5a8719.getMessage()
				System.out.println(failure);
			}
			if (nObtained > 0) {
				??? min = numberArray[0];
				??? max = numberArray[0];
				for (int i = 1; i <= nObtained-1; i += (1)) {
					if (numberArray[i] < min) {
						min = numberArray[i];
					}
					else if (numberArray[i] > max) {
						max = numberArray[i];
					}
				}
				// Interval width 
				??? width = (max - min) * 1.0 / nIntervals;
				for (int i = 0; i <= nObtained - 1; i += (1)) {
					??? value = numberArray[i];
					int k = 1;
					while (k < nIntervals && value > min + k * width) {
						k = k + 1;
					}
					count[k-1] = count[k-1] + 1;
					if (count[k-1] > count[kMaxCount]) {
						kMaxCount = k-1;
					}
				}
				FileApiGroupTest_arrz.drawBarChart(count, nIntervals);
				System.out.println(("Interval with max count: ") + (kMaxCount) + (" (") + (count[kMaxCount]) + (")"));
				for (k = 0; k <= nIntervals-1; k += (1)) {
					System.out.println((count[k]) + (" numbers in interval ") + (k) + (" (") + (min + k * width) + (" ... ") + (min + (k+1) * width) + (")"));
				}
			}
			else {
				System.out.println("No numbers read.");
			}
		}
	}

}

// ======= 8< =========================================================== 

// Generated by Structorizer 3.32-20 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

// TODO: Download the turtle package from https://structorizer.fisch.lu and put it into this project
//import lu.fisch.turtle.adapters.Turtleizer;
	/**
	 * Writes a text file with name fileName, consisting of count lines, each containing
	 * a random number in the range from minVal to maxVal (both inclusive).
	 * Returns either the number of written number if all went well or some potential
	 * error code if something went wrong.
	 * @param fileName
	 * @param count
	 * @param minVal
	 * @param maxVal
	 * @return 
	 */
	public static int generateRandomNumberFile(String fileName, int count, int minVal, int maxVal) {
		FileApiGroupTest_arrz.initializeFileApiGroupTest_arrz();
		// TODO: Check and accomplish variable declarations: 
		int fileNo;
		Random randGen = new Random();

		fileNo = StructorizerFileAPI.fileCreate(fileName);
		if (fileNo <= 0) {
			return fileNo;
		}
		try {
			for (int k = 1; k <= count; k += (1)) {
				??? number = minVal + (randGen.nextInt() % (maxVal - minVal + 1));
				StructorizerFileAPI.fileWriteLine(fileNo, number);
			}
		}
		catch (Exception ex4645d92a) {
			String error = ex4645d92a.getMessage()
			System.out.println(error);
			return -7;
		}
		finally {
			StructorizerFileAPI.fileClose(fileNo);
		}
		return count;
	}
