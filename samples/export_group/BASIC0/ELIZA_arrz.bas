10 REM Concept and lisp implementation published by Joseph Weizenbaum (MIT): 
20 REM "ELIZA - A Computer Program For the Study of Natural Language Communication Between Man and Machine" - In: 
30 REM Computational Linguistis 1(1966)9, pp. 36-45 
40 REM Revision history: 
50 REM 2016-10-06 Initial version 
60 REM 2017-03-29 Two diagrams updated (comments translated to English) 
70 REM 2017-03-29 More keywords and replies added 
80 REM 2019-03-14 Replies and mapping reorganised for easier maintenance 
90 REM 2019-03-15 key map joined from keyword array and index map 
100 REM 2019-03-28 Keyword "bot" inserted (same reply ring as "computer") 
110 REM 2019-11-28 New global type "History" (to ensure a homogenous array) 
120 REM 2022-01-11 Measures against substition inversions a -> b -> a in conjugateStrings, reflexions revised. 
130 REM Generated by Structorizer 3.32-26 
140 
150 REM Copyright (C) 2018-05-14 Kay Gürtzig 
160 REM License: GPLv3-link 
170 REM GNU General Public License (V 3) 
180 REM https://www.gnu.org/licenses/gpl.html 
190 REM http://www.gnu.de/documents/gpl.de.html 
200 
210 REM  
220 REM program ELIZA
230 REM TODO: add the respective type suffixes to your variable names if required 
240 
250 REM histArray contains the most recent user replies as ring buffer; 
260 REM histIndex is the index where the next reply is to be stored (= index of the oldest 
270 REM cached user reply). 
280 REM Note: The depth of the history is to be specified by initializing a variable of this type, 
290 REM e.g. for a history of depth 5: 
300 REM myhistory <- History{{"", "", "", "", ""}, 0} 
310 TYPE History
320   Dim histArray() AS String
330   histIndex AS Integer
340 END TYPE
350 REM Associates a key word in the text with an index in the reply ring array 
360 TYPE KeyMapEntry
370   keyword AS String
380   index AS Integer
390 END TYPE
400 
410 DIM replies(,) AS String
420 DIM reflexions(,1) AS String
430 DIM byePhrases(,1) AS String
440 DIM keyMap() AS KeyMapEntry
450 DIM offsets() AS Integer
460 DIM history AS History
470 DIM findInfo(1) AS integer
480 DIM entry AS KeyMapEntry
490 REM  
500 REM Title information 
510 PRINT "************* ELIZA **************"
520 PRINT "* Original design by J. Weizenbaum"
530 PRINT "**********************************"
540 PRINT "* Adapted for Basic on IBM PC by"
550 PRINT "* - Patricia Danielson"
560 PRINT "* - Paul Hashfield"
570 PRINT "**********************************"
580 PRINT "* Adapted for Structorizer by"
590 PRINT "* - Kay Gürtzig / FH Erfurt 2016"
600 PRINT "* Version: 2.4 (2022-01-11)"
610 PRINT "* (Requires at least Structorizer 3.30-03 to run)"
620 PRINT "**********************************"
630 REM Stores the last five inputs of the user in a ring buffer, 
640 REM the second component is the rolling (over-)write index. 
650 LET history.histArray(0) = ""
660 LET history.histArray(1) = ""
670 LET history.histArray(2) = ""
680 LET history.histArray(3) = ""
690 LET history.histArray(4) = ""
700 LET history.histIndex = 0
710 LET replies = setupReplies()
720 LET reflexions = setupReflexions()
730 LET byePhrases = setupGoodByePhrases()
740 LET keyMap = setupKeywords()
750 LET offsets(length(keyMap)-1) = 0
760 LET isGone = false
770 REM Starter 
780 PRINT "Hi! I\'m your new therapist. My name is Eliza. What\'s your problem?"
790 DO
800   INPUT userInput
810   REM Converts the input to lowercase, cuts out interpunctation 
820   REM and pads the string 
830   LET userInput = normalizeInput(userInput)
840   LET isGone = checkGoodBye(userInput, byePhrases)
850   IF NOT isGone THEN
860     LET reply = "Please don\'t repeat yourself!"
870     LET isRepeated = checkRepetition(history, userInput)
880     IF NOT isRepeated THEN
890       LET findInfo = findKeyword(keyMap, userInput)
900       LET keyIndex = findInfo(0)
910       IF keyIndex < 0 THEN
920         REM Should never happen... 
930         LET keyIndex = length(keyMap)-1
940       END IF
950       LET entry = keyMap(keyIndex)
960       REM Variable part of the reply 
970       LET varPart = ""
980       IF length(entry.keyword) > 0 THEN
990         LET varPart = conjugateStrings(userInput, entry.keyword, findInfo(1), reflexions)
1000       END IF
1010       LET replyRing = replies(entry.index)
1020       LET reply = replyRing(offsets(keyIndex))
1030       LET offsets(keyIndex) = (offsets(keyIndex) + 1) % length(replyRing)
1040       LET posAster = pos("*", reply)
1050       IF posAster > 0 THEN
1060         IF varPart = " " THEN
1070           LET reply = "You will have to elaborate more for me to help you."
1080         ELSE
1090           delete(reply, posAster, 1)
1100           insert(varPart, reply, posAster)
1110         END IF
1120       END IF
1130       LET reply = adjustSpelling(reply)
1140     END IF
1150     PRINT reply
1160   END IF
1170 LOOP UNTIL isGone
1180 END
1190 REM  
1200 REM Cares for correct letter case among others 
1210 REM TODO: Add type-specific suffixes where necessary! 
1220 FUNCTION adjustSpelling(sentence AS String) AS String
1230   REM TODO: add the respective type suffixes to your variable names if required 
1240   REM  
1250   REM  
1260   LET result = sentence
1270   LET position = 1
1280   DO WHILE (position <= length(sentence)) AND (copy(sentence, position, 1) = " ")
1290     LET position = position + 1
1300   LOOP
1310   IF position <= length(sentence) THEN
1320     LET start = copy(sentence, 1, position)
1330     delete(result, 1, position)
1340     insert(uppercase(start), result, 1)
1350   END IF
1360   DIM array697022ba() AS String = {" i ", " i\'"}
1370   FOR EACH word IN array697022ba
1380     LET position = pos(word, result)
1390     DO WHILE position > 0
1400       delete(result, position+1, 1)
1410       insert("I", result, position+1)
1420       LET position = pos(word, result)
1430     LOOP
1440   NEXT word
1450   RETURN result
1460 END FUNCTION
1470 REM  
1480 REM Checks whether the given text contains some kind of 
1490 REM good-bye phrase inducing the end of the conversation 
1500 REM and if so writes a correspding good-bye message and 
1510 REM returns true, otherwise false 
1520 REM TODO: Add type-specific suffixes where necessary! 
1530 FUNCTION checkGoodBye(text AS String, phrases AS String(50,0 TO 1)) AS boolean
1540   REM TODO: add the respective type suffixes to your variable names if required 
1550   REM  
1560   REM  
1570   FOR EACH pair IN phrases
1580     IF pos(pair(0), text) > 0 THEN
1590       PRINT pair(1)
1600       RETURN true
1610     END IF
1620   NEXT pair
1630   return false
1640 END FUNCTION
1650 REM  
1660 REM TODO: Add type-specific suffixes where necessary! 
1670 FUNCTION conjugateStrings(sentence AS String, key AS String, keyPos AS integer, flexions AS String(50,0 TO 1)) AS String
1680   REM TODO: add the respective type suffixes to your variable names if required 
1690   REM  
1700   REM  
1710   LET result = " " + copy(sentence, keyPos + length(key), length(sentence)) + " "
1720   FOR EACH pair IN flexions
1730     LET left = ""
1740     LET right = result
1750     LET pos0 = pos(pair(0), right)
1760     LET pos1 = pos(pair(1), right)
1770     DO WHILE pos0 > 0 OR pos1 > 0
1780       REM Detect which of the two words of the pair matches first (lest a substitution should be reverted) 
1790       LET which = 0
1800       LET position = pos0
1810       IF (pos0 = 0) OR ((pos1 > 0) AND (pos1 < pos0)) THEN
1820         LET which = 1
1830         LET position = pos1
1840       END IF
1850       LET left = left + copy(right, 1, position-1) + pair(1 - which)
1860       LET right = copy(right, position + length(pair(which)), length(right))
1870       LET pos0 = pos(pair(0), right)
1880       LET pos1 = pos(pair(1), right)
1890     LOOP
1900     LET result = left + right
1910   NEXT pair
1920   REM Eliminate multiple spaces (replaced by single ones) and vertical bars 
1930   DIM array951d833() AS String = {"  ", "|"}
1940   FOR EACH str IN array951d833
1950     LET position = pos(str, result)
1960     DO WHILE position > 0
1970       LET result = copy(result, 1, position-1) + copy(result, position+1, length(result))
1980       LET position = pos(str, result)
1990     LOOP
2000   NEXT str
2010   RETURN result
2020 END FUNCTION
2030 REM  
2040 REM Converts the sentence to lowercase, eliminates all 
2050 REM interpunction (i.e. ',', '.', ';'), and pads the 
2060 REM sentence among blanks 
2070 REM TODO: Add type-specific suffixes where necessary! 
2080 FUNCTION normalizeInput(sentence AS String) AS String
2090   REM TODO: add the respective type suffixes to your variable names if required 
2100   REM  
2110   REM  
2120   LET sentence = lowercase(sentence)
2130   REM TODO: Specify an appropriate element type for the array! 
2140   DIM array22a5a576() AS FIXME_22a5a576 = {'.', ',', ';', '!', '?'}
2150   FOR EACH symbol IN array22a5a576
2160     LET position = pos(symbol, sentence)
2170     DO WHILE position > 0
2180       LET sentence = copy(sentence, 1, position-1) + copy(sentence, position+1, length(sentence))
2190       LET position = pos(symbol, sentence)
2200     LOOP
2210   NEXT symbol
2220   LET result = " " + sentence + " "
2230   RETURN result
2240 END FUNCTION
2250 REM  
2260 REM TODO: Add type-specific suffixes where necessary! 
2270 FUNCTION setupGoodByePhrases() AS String(50,0 TO 1)
2280   REM TODO: add the respective type suffixes to your variable names if required 
2290   REM  
2300   DIM phrases(,1) AS String
2310   REM  
2320   LET phrases(0)(0) = " shut"
2330   LET phrases(0)(1) = "Okay. If you feel that way I\'ll shut up. ... Your choice."
2340   LET phrases(1)(0) = "bye"
2350   LET phrases(1)(1) = "Well, let\'s end our talk for now. See you later. Bye."
2360   return phrases
2370 END FUNCTION
2380 REM  
2390 REM Returns an array of pairs of mutually substitutable words 
2400 REM The second word may contain a '|' in order to prevent an inverse 
2410 REM replacement. 
2420 REM TODO: Add type-specific suffixes where necessary! 
2430 FUNCTION setupReflexions() AS String(50,0 TO 1)
2440   REM TODO: add the respective type suffixes to your variable names if required 
2450   REM  
2460   DIM reflexions(,1) AS String
2470   REM  
2480   LET reflexions(0)(0) = " are "
2490   LET reflexions(0)(1) = " am "
2500   REM This is not always helpful (e.g. if it relates to things or third persons) 
2510   LET reflexions(1)(0) = " were "
2520   LET reflexions(1)(1) = " was "
2530   LET reflexions(2)(0) = " you "
2540   LET reflexions(2)(1) = " i "
2550   LET reflexions(3)(0) = " yours "
2560   LET reflexions(3)(1) = " mine "
2570   LET reflexions(4)(0) = " yourself "
2580   LET reflexions(4)(1) = " myself "
2590   LET reflexions(5)(0) = " your "
2600   LET reflexions(5)(1) = " my "
2610   LET reflexions(6)(0) = " i\'ve "
2620   LET reflexions(6)(1) = " you\'ve "
2630   LET reflexions(7)(0) = " i\'m "
2640   LET reflexions(7)(1) = " you\'re "
2650   REM We must not replace "you" by "me", not in particular after "I" had been replaced by "you". 
2660   LET reflexions(8)(0) = " me "
2670   LET reflexions(8)(1) = " |you "
2680   return reflexions
2690 END FUNCTION
2700 REM  
2710 REM This routine sets up the reply rings addressed by the key words defined in 
2720 REM routine `setupKeywords()´ and mapped hitherto by the cross table defined 
2730 REM in `setupMapping()´ 
2740 REM TODO: Add type-specific suffixes where necessary! 
2750 FUNCTION setupReplies() AS String(50,50)
2760   REM TODO: add the respective type suffixes to your variable names if required 
2770   REM  
2780   DIM setupReplies(,) AS String
2790   DIM replies(,) AS String
2800   REM  
2810   REM We start with the highest index for performance reasons 
2820   REM (is to avoid frequent array resizing) 
2830   LET replies(29)(0) = "Say, do you have any psychological problems?"
2840   LET replies(29)(1) = "What does that suggest to you?"
2850   LET replies(29)(2) = "I see."
2860   LET replies(29)(3) = "I'm not sure I understand you fully."
2870   LET replies(29)(4) = "Come come elucidate your thoughts."
2880   LET replies(29)(5) = "Can you elaborate on that?"
2890   LET replies(29)(6) = "That is quite interesting."
2900   LET replies(0)(0) = "Don't you believe that I can*?"
2910   LET replies(0)(1) = "Perhaps you would like to be like me?"
2920   LET replies(0)(2) = "You want me to be able to*?"
2930   LET replies(1)(0) = "Perhaps you don't want to*?"
2940   LET replies(1)(1) = "Do you want to be able to*?"
2950   LET replies(2)(0) = "What makes you think I am*?"
2960   LET replies(2)(1) = "Does it please you to believe I am*?"
2970   LET replies(2)(2) = "Perhaps you would like to be*?"
2980   LET replies(2)(3) = "Do you sometimes wish you were*?"
2990   LET replies(3)(0) = "Don't you really*?"
3000   LET replies(3)(1) = "Why don't you*?"
3010   LET replies(3)(2) = "Do you wish to be able to*?"
3020   LET replies(3)(3) = "Does that trouble you*?"
3030   LET replies(4)(0) = "Do you often feel*?"
3040   LET replies(4)(1) = "Are you afraid of feeling*?"
3050   LET replies(4)(2) = "Do you enjoy feeling*?"
3060   LET replies(5)(0) = "Do you really believe I don't*?"
3070   LET replies(5)(1) = "Perhaps in good time I will*."
3080   LET replies(5)(2) = "Do you want me to*?"
3090   LET replies(6)(0) = "Do you think you should be able to*?"
3100   LET replies(6)(1) = "Why can't you*?"
3110   LET replies(7)(0) = "Why are you interested in whether or not I am*?"
3120   LET replies(7)(1) = "Would you prefer if I were not*?"
3130   LET replies(7)(2) = "Perhaps in your fantasies I am*?"
3140   LET replies(8)(0) = "How do you know you can't*?"
3150   LET replies(8)(1) = "Have you tried?"
3160   LET replies(8)(2) = "Perhaps you can now*."
3170   LET replies(9)(0) = "Did you come to me because you are*?"
3180   LET replies(9)(1) = "How long have you been*?"
3190   LET replies(9)(2) = "Do you believe it is normal to be*?"
3200   LET replies(9)(3) = "Do you enjoy being*?"
3210   LET replies(10)(0) = "We were discussing you--not me."
3220   LET replies(10)(1) = "Oh, I*."
3230   LET replies(10)(2) = "You're not really talking about me, are you?"
3240   LET replies(11)(0) = "What would it mean to you if you got*?"
3250   LET replies(11)(1) = "Why do you want*?"
3260   LET replies(11)(2) = "Suppose you soon got*..."
3270   LET replies(11)(3) = "What if you never got*?"
3280   LET replies(11)(4) = "I sometimes also want*."
3290   LET replies(12)(0) = "Why do you ask?"
3300   LET replies(12)(1) = "Does that question interest you?"
3310   LET replies(12)(2) = "What answer would please you the most?"
3320   LET replies(12)(3) = "What do you think?"
3330   LET replies(12)(4) = "Are such questions on your mind often?"
3340   LET replies(12)(5) = "What is it that you really want to know?"
3350   LET replies(12)(6) = "Have you asked anyone else?"
3360   LET replies(12)(7) = "Have you asked such questions before?"
3370   LET replies(12)(8) = "What else comes to mind when you ask that?"
3380   LET replies(13)(0) = "Names don't interest me."
3390   LET replies(13)(1) = "I don't care about names -- please go on."
3400   LET replies(14)(0) = "Is that the real reason?"
3410   LET replies(14)(1) = "Don't any other reasons come to mind?"
3420   LET replies(14)(2) = "Does that reason explain anything else?"
3430   LET replies(14)(3) = "What other reasons might there be?"
3440   LET replies(15)(0) = "Please don't apologize!"
3450   LET replies(15)(1) = "Apologies are not necessary."
3460   LET replies(15)(2) = "What feelings do you have when you apologize?"
3470   LET replies(15)(3) = "Don't be so defensive!"
3480   LET replies(16)(0) = "What does that dream suggest to you?"
3490   LET replies(16)(1) = "Do you dream often?"
3500   LET replies(16)(2) = "What persons appear in your dreams?"
3510   LET replies(16)(3) = "Are you disturbed by your dreams?"
3520   LET replies(17)(0) = "How do you do ...please state your problem."
3530   LET replies(18)(0) = "You don't seem quite certain."
3540   LET replies(18)(1) = "Why the uncertain tone?"
3550   LET replies(18)(2) = "Can't you be more positive?"
3560   LET replies(18)(3) = "You aren't sure?"
3570   LET replies(18)(4) = "Don't you know?"
3580   LET replies(19)(0) = "Are you saying no just to be negative?"
3590   LET replies(19)(1) = "You are being a bit negative."
3600   LET replies(19)(2) = "Why not?"
3610   LET replies(19)(3) = "Are you sure?"
3620   LET replies(19)(4) = "Why no?"
3630   LET replies(20)(0) = "Why are you concerned about my*?"
3640   LET replies(20)(1) = "What about your own*?"
3650   LET replies(21)(0) = "Can you think of a specific example?"
3660   LET replies(21)(1) = "When?"
3670   LET replies(21)(2) = "What are you thinking of?"
3680   LET replies(21)(3) = "Really, always?"
3690   LET replies(22)(0) = "Do you really think so?"
3700   LET replies(22)(1) = "But you are not sure you*?"
3710   LET replies(22)(2) = "Do you doubt you*?"
3720   LET replies(23)(0) = "In what way?"
3730   LET replies(23)(1) = "What resemblance do you see?"
3740   LET replies(23)(2) = "What does the similarity suggest to you?"
3750   LET replies(23)(3) = "What other connections do you see?"
3760   LET replies(23)(4) = "Could there really be some connection?"
3770   LET replies(23)(5) = "How?"
3780   LET replies(23)(6) = "You seem quite positive."
3790   LET replies(24)(0) = "Are you sure?"
3800   LET replies(24)(1) = "I see."
3810   LET replies(24)(2) = "I understand."
3820   LET replies(25)(0) = "Why do you bring up the topic of friends?"
3830   LET replies(25)(1) = "Do your friends worry you?"
3840   LET replies(25)(2) = "Do your friends pick on you?"
3850   LET replies(25)(3) = "Are you sure you have any friends?"
3860   LET replies(25)(4) = "Do you impose on your friends?"
3870   LET replies(25)(5) = "Perhaps your love for friends worries you."
3880   LET replies(26)(0) = "Do computers worry you?"
3890   LET replies(26)(1) = "Are you talking about me in particular?"
3900   LET replies(26)(2) = "Are you frightened by machines?"
3910   LET replies(26)(3) = "Why do you mention computers?"
3920   LET replies(26)(4) = "What do you think machines have to do with your problem?"
3930   LET replies(26)(5) = "Don't you think computers can help people?"
3940   LET replies(26)(6) = "What is it about machines that worries you?"
3950   LET replies(27)(0) = "Do you sometimes feel uneasy without a smartphone?"
3960   LET replies(27)(1) = "Have you had these phantasies before?"
3970   LET replies(27)(2) = "Does the world seem more real for you via apps?"
3980   LET replies(28)(0) = "Tell me more about your family."
3990   LET replies(28)(1) = "Who else in your family*?"
4000   LET replies(28)(2) = "What does family relations mean for you?"
4010   LET replies(28)(3) = "Come on, How old are you?"
4020   LET setupReplies = replies
4030   RETURN setupReplies
4040 END FUNCTION
4050 REM  
4060 REM Checks whether newInput has occurred among the recently cached 
4070 REM input strings in the histArray component of history and updates the history. 
4080 REM TODO: Add type-specific suffixes where necessary! 
4090 FUNCTION checkRepetition(history AS History, newInput AS String) AS boolean
4100   REM TODO: add the respective type suffixes to your variable names if required 
4110   REM  
4120   REM  
4130   LET hasOccurred = false
4140   IF length(newInput) > 4 THEN
4150     LET histDepth = length(history.histArray)
4160     FOR i = 0 TO histDepth-1
4170       IF newInput = history.histArray(i) THEN
4180         LET hasOccurred = true
4190       END IF
4200     NEXT i
4210     LET history.histArray(history.histIndex) = newInput
4220     LET history.histIndex = (history.histIndex + 1) % (histDepth)
4230   END IF
4240   return hasOccurred
4250 END FUNCTION
4260 REM  
4270 REM Looks for the occurrence of the first of the strings 
4280 REM contained in keywords within the given sentence (in 
4290 REM array order). 
4300 REM Returns an array of 
4310 REM 0: the index of the first identified keyword (if any, otherwise -1), 
4320 REM 1: the position inside sentence (0 if not found) 
4330 REM TODO: Add type-specific suffixes where necessary! 
4340 FUNCTION findKeyword(CONST keyMap AS KeyMapEntry(50), sentence AS String) AS integer(0 TO 1)
4350   REM TODO: add the respective type suffixes to your variable names if required 
4360   REM  
4370   DIM result(1) AS Integer
4380   DIM entry AS KeyMapEntry
4390   REM  
4400   REM Contains the index of the keyword and its position in sentence 
4410   LET result(0) = -1
4420   LET result(1) = 0
4430   LET i = 0
4440   DO WHILE (result(0) < 0) AND (i < length(keyMap))
4450     LET entry = keyMap(i)
4460     LET position = pos(entry.keyword, sentence)
4470     IF position > 0 THEN
4480       LET result(0) = i
4490       LET result(1) = position
4500     END IF
4510     LET i = i+1
4520   LOOP
4530   RETURN result
4540 END FUNCTION
4550 REM  
4560 REM The lower the index the higher the rank of the keyword (search is sequential). 
4570 REM The index of the first keyword found in a user sentence maps to a respective 
4580 REM reply ring as defined in `setupReplies()´. 
4590 REM TODO: Add type-specific suffixes where necessary! 
4600 FUNCTION setupKeywords() AS KeyMapEntry(50)
4610   REM TODO: add the respective type suffixes to your variable names if required 
4620   REM  
4630   DIM keywords() AS KeyMapEntry
4640   REM  
4650   REM The empty key string (last entry) is the default clause - will always be found 
4660   LET keywords(39).keyword = ""
4670   LET keywords(39).index = 29
4680   LET keywords(0).keyword = "can you "
4690   LET keywords(0).index = 0
4700   LET keywords(1).keyword = "can i "
4710   LET keywords(1).index = 1
4720   LET keywords(2).keyword = "you are "
4730   LET keywords(2).index = 2
4740   LET keywords(3).keyword = "you\'re "
4750   LET keywords(3).index = 2
4760   LET keywords(4).keyword = "i don't "
4770   LET keywords(4).index = 3
4780   LET keywords(5).keyword = "i feel "
4790   LET keywords(5).index = 4
4800   LET keywords(6).keyword = "why don\'t you "
4810   LET keywords(6).index = 5
4820   LET keywords(7).keyword = "why can\'t i "
4830   LET keywords(7).index = 6
4840   LET keywords(8).keyword = "are you "
4850   LET keywords(8).index = 7
4860   LET keywords(9).keyword = "i can\'t "
4870   LET keywords(9).index = 8
4880   LET keywords(10).keyword = "i am "
4890   LET keywords(10).index = 9
4900   LET keywords(11).keyword = "i\'m "
4910   LET keywords(11).index = 9
4920   LET keywords(12).keyword = "you "
4930   LET keywords(12).index = 10
4940   LET keywords(13).keyword = "i want "
4950   LET keywords(13).index = 11
4960   LET keywords(14).keyword = "what "
4970   LET keywords(14).index = 12
4980   LET keywords(15).keyword = "how "
4990   LET keywords(15).index = 12
5000   LET keywords(16).keyword = "who "
5010   LET keywords(16).index = 12
5020   LET keywords(17).keyword = "where "
5030   LET keywords(17).index = 12
5040   LET keywords(18).keyword = "when "
5050   LET keywords(18).index = 12
5060   LET keywords(19).keyword = "why "
5070   LET keywords(19).index = 12
5080   LET keywords(20).keyword = "name "
5090   LET keywords(20).index = 13
5100   LET keywords(21).keyword = "cause "
5110   LET keywords(21).index = 14
5120   LET keywords(22).keyword = "sorry "
5130   LET keywords(22).index = 15
5140   LET keywords(23).keyword = "dream "
5150   LET keywords(23).index = 16
5160   LET keywords(24).keyword = "hello "
5170   LET keywords(24).index = 17
5180   LET keywords(25).keyword = "hi "
5190   LET keywords(25).index = 17
5200   LET keywords(26).keyword = "maybe "
5210   LET keywords(26).index = 18
5220   LET keywords(27).keyword = " no"
5230   LET keywords(27).index = 19
5240   LET keywords(28).keyword = "your "
5250   LET keywords(28).index = 20
5260   LET keywords(29).keyword = "always "
5270   LET keywords(29).index = 21
5280   LET keywords(30).keyword = "think "
5290   LET keywords(30).index = 22
5300   LET keywords(31).keyword = "alike "
5310   LET keywords(31).index = 23
5320   LET keywords(32).keyword = "yes "
5330   LET keywords(32).index = 24
5340   LET keywords(33).keyword = "friend "
5350   LET keywords(33).index = 25
5360   LET keywords(34).keyword = "computer"
5370   LET keywords(34).index = 26
5380   LET keywords(35).keyword = "bot "
5390   LET keywords(35).index = 26
5400   LET keywords(36).keyword = "smartphone"
5410   LET keywords(36).index = 27
5420   LET keywords(37).keyword = "father "
5430   LET keywords(37).index = 28
5440   LET keywords(38).keyword = "mother "
5450   LET keywords(38).index = 28
5460   return keywords
5470 END FUNCTION
