10 REM NOTE: 
20 REM This first module of the file is a library module providing common resources 
30 REM for the following modules, which are separated by comment lines like 
40 REM "======= 8< =======...". 
50 REM You may have to cut this file apart at these lines in order to get the parts 
60 REM running, since the following modules may form sort of mutually independent 
70 REM applications or programs the coexistence of which in a single file might not 
80 REM be sensible. 
90 REM Generated by Structorizer 3.32-20 
100 
110 REM Copyright (C) 2024-04-03 Kay Gürtzig 
120 REM License: GPLv3-link 
130 REM GNU General Public License (V 3) 
140 REM https://www.gnu.org/licenses/gpl.html 
150 REM http://www.gnu.de/documents/gpl.de.html 
160 
170 REM  
180 REM TODO: Add type-specific suffixes where necessary! 
190 SUB FileApiGroupTest_arrz()
200   REM TODO: add the respective type suffixes to your variable names if required 
210 END
220 
230 REM  
240 REM Draws a bar chart from the array "values" of size nValues. 
250 REM Turtleizer must be activated and will scale the chart into a square of 
260 REM 500 x 500 pixels 
270 REM Note: The function is not robust against empty array or totally equal values. 
280 
290 REM Copyright (C) 2020-03-22 Kay Gürtzig 
300 REM License: GPLv3-link 
310 
320 REM TODO: Add type-specific suffixes where necessary! 
330 SUB drawBarChart(values AS double(50), nValues)
340   REM TODO: add the respective type suffixes to your variable names if required 
350   REM Used range of the Turtleizer screen 
360   LET xSize = 500
370   LET ySize = 500
380   LET kMin = 0
390   LET kMax = 0
400   FOR k = 1 TO nValues-1
410     IF values(k) > values(kMax) THEN
420       LET kMax = k
430     ELSE
440       IF values(k) < values(kMin) THEN
450         LET kMin = k
460       END IF
470     END IF
480   NEXT k
490   LET valMin = values(kMin)
500   LET valMax = values(kMax)
510   LET yScale = valMax * 1.0 / (ySize - 1)
520   LET yAxis = ySize - 1
530   IF valMin < 0 THEN
540     IF valMax > 0 THEN
550       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
560       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
570     ELSE
580       LET yAxis = 1
590       LET yScale = valMin * 1.0 / (ySize - 1)
600     END IF
610   END IF
620   REM draw coordinate axes 
630   gotoXY(1, ySize - 1)
640   forward(ySize -1) : REM color = ffffff
650   penUp()
660   backward(yAxis) : REM color = ffffff
670   right(90)
680   penDown()
690   forward(xSize -1) : REM color = ffffff
700   penUp()
710   backward(xSize-1) : REM color = ffffff
720   LET stripeWidth = xSize / nValues
730   FOR k = 0 TO nValues-1
740     LET stripeHeight = values(k) * 1.0 / yScale
750     SELECT CASE k % 3
760       CASE 0
770         setPenColor(255,0,0)
780       CASE 1
790         setPenColor(0, 255,0)
800       CASE 2
810         setPenColor(0, 0, 255)
820     END SELECT
830     fd(1) : REM color = ffffff
840     left(90)
850     penDown()
860     fd(stripeHeight) : REM color = ffffff
870     right(90)
880     fd(stripeWidth - 1) : REM color = ffffff
890     right(90)
900     forward(stripeHeight) : REM color = ffffff
910     left(90)
920     penUp()
930   NEXT k
940 END SUB
950 
960 REM  
970 REM Writes a text file with name fileName, consisting of count lines, each containing 
980 REM a random number in the range from minVal to maxVal (both inclusive). 
990 REM Returns either the number of written number if all went well or some potential 
1000 REM error code if something went wrong. 
1010 
1020 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1030 REM License: GPLv3-link 
1040 
1050 REM TODO: Add type-specific suffixes where necessary! 
1060 FUNCTION generateRandomNumberFile(fileName AS String, count AS Integer, minVal AS integer, maxVal AS integer) AS integer
1070   REM TODO: add the respective type suffixes to your variable names if required 
1080   LET fileNo = fileCreate(fileName)
1090   IF fileNo <= 0 THEN
1100     RETURN fileNo
1110   END IF
1120   ON ERROR GOTO 1190
1130   FOR k = 1 TO count
1140     LET number = minVal + random(maxVal - minVal + 1)
1150     fileWriteLine(fileNo, number)
1160   NEXT k
1170   GOTO 1220
1180   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
1190     PRINT error
1200     RETURN -7
1210   REM End of error handler, resume here ... 
1220   ON ERROR GOTO 0
1230   fileClose(fileNo)
1240   RETURN count
1250 END FUNCTION
1260 
1270 REM  
1280 REM Tries to read as many integer values as possible upto maxNumbers 
1290 REM from file fileName into the given array numbers. 
1300 REM Returns the number of the actually read numbers. May cause an exception. 
1310 
1320 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1330 REM License: GPLv3-link 
1340 
1350 REM TODO: Add type-specific suffixes where necessary! 
1360 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
1370   REM TODO: add the respective type suffixes to your variable names if required 
1380   LET nNumbers = 0
1390   LET fileNo = fileOpen(fileName)
1400   IF fileNo <= 0 THEN
1410     REM FIXME: Only a number is allowed as parameter: 
1420     ERROR "File could not be opened!"
1430   END IF
1440   ON ERROR GOTO 1520
1450   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
1460     LET number = fileReadInt(fileNo)
1470     LET numbers(nNumbers) = number
1480     LET nNumbers = nNumbers + 1
1490   LOOP
1500   GOTO 1550
1510   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
1520     REM FIXME: Only a number is allowed as parameter: 
1530     ERROR 
1540   REM End of error handler, resume here ... 
1550   ON ERROR GOTO 0
1560   fileClose(fileNo)
1570   RETURN nNumbers
1580 END FUNCTION
1590 
1600 REM ======= 8< =========================================================== 
1610 
1620 REM Computes the sum and average of the numbers read from a user-specified 
1630 REM text file (which might have been created via generateRandomNumberFile(4)). 
1640 REM  
1650 REM This program is part of an arrangement used to test group code export (issue 
1660 REM #828) with FileAPI dependency. 
1670 REM The input check loop has been disabled (replaced by a simple unchecked input 
1680 REM instruction) in order to test the effect of indirect FileAPI dependency (only the 
1690 REM called subroutine directly requires FileAPI now). 
1700 REM Generated by Structorizer 3.32-20 
1710 
1720 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1730 REM License: GPLv3-link 
1740 REM GNU General Public License (V 3) 
1750 REM https://www.gnu.org/licenses/gpl.html 
1760 REM http://www.gnu.de/documents/gpl.de.html 
1770 
1780 REM  
1790 REM program ComputeSum
1800 REM TODO: add the respective type suffixes to your variable names if required 
1810 LET fileNo = 1000
1820 REM Disable this if you enable the loop below! 
1830 PRINT "Name/path of the number file"; : INPUT file_name
1840 REM If you enable this loop, then the preceding input instruction is to be disabled 
1850 REM and the fileClose instruction in the alternative below is to be enabled. 
1860 REM DO 
1870 REM   PRINT "Name/path of the number file"; : INPUT file_name 
1880 REM   LET fileNo = fileOpen(file_name) 
1890 REM LOOP UNTIL fileNo > 0 OR file_name = "" 
1900 IF fileNo > 0 THEN
1910   REM This should be enabled if the input check loop above gets enabled. 
1920 REM   fileClose(fileNo) 
1930   REM TODO: Check indexBase value (automatically generated) 
1940   LET indexBase = 0
1950   LET nValues = 0
1960   ON ERROR GOTO 2000
1970   LET nValues = readNumbers(file_name, values, 1000)
1980   GOTO 2030
1990   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
2000     PRINT failure
2010     STOP
2020   REM End of error handler, resume here ... 
2030   ON ERROR GOTO 0
2040   LET sum = 0.0
2050   FOR k = 0 TO nValues-1
2060     LET sum = sum + values(k)
2070   NEXT k
2080   PRINT "sum = "; sum
2090   PRINT "average = "; sum / nValues
2100 END IF
2110 END
2120 
2130 REM ======= 8< =========================================================== 
2140 
2150 REM Reads a random number file and draws a histogram accotrding to the 
2160 REM user specifications 
2170 REM Generated by Structorizer 3.32-20 
2180 
2190 REM Copyright (C) 2020-03-21 Kay Gürtzig 
2200 REM License: GPLv3-link 
2210 REM GNU General Public License (V 3) 
2220 REM https://www.gnu.org/licenses/gpl.html 
2230 REM http://www.gnu.de/documents/gpl.de.html 
2240 
2250 REM  
2260 REM program DrawRandomHistogram
2270 REM TODO: add the respective type suffixes to your variable names if required 
2280 LET fileNo = -10
2290 DO
2300   PRINT "Name/path of the number file"; : INPUT file_name
2310   LET fileNo = fileOpen(file_name)
2320 LOOP UNTIL fileNo > 0 OR file_name = ""
2330 IF fileNo > 0 THEN
2340   fileClose(fileNo)
2350   PRINT "number of intervals"; : INPUT nIntervals
2360   REM Initialize the interval counters 
2370   FOR k = 0 TO nIntervals-1
2380     LET count(k) = 0
2390   NEXT k
2400   REM Index of the most populated interval 
2410   LET kMaxCount = 0
2420   REM TODO: Check indexBase value (automatically generated) 
2430   LET indexBase = 0
2440   LET nObtained = 0
2450   ON ERROR GOTO 2490
2460   LET nObtained = readNumbers(file_name, numberArray, 10000)
2470   GOTO 2510
2480   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
2490     PRINT failure
2500   REM End of error handler, resume here ... 
2510   ON ERROR GOTO 0
2520   IF nObtained > 0 THEN
2530     LET min = numberArray(0)
2540     LET max = numberArray(0)
2550     FOR i = 1 TO nObtained-1
2560       IF numberArray(i) < min THEN
2570         LET min = numberArray(i)
2580       ELSE
2590         IF numberArray(i) > max THEN
2600           LET max = numberArray(i)
2610         END IF
2620       END IF
2630     NEXT i
2640     REM Interval width 
2650     LET width = (max - min) * 1.0 / nIntervals
2660     FOR i = 0 TO nObtained - 1
2670       LET value = numberArray(i)
2680       LET k = 1
2690       DO WHILE k < nIntervals AND value > min + k * width
2700         LET k = k + 1
2710       LOOP
2720       LET count(k-1) = count(k-1) + 1
2730       IF count(k-1) > count(kMaxCount) THEN
2740         LET kMaxCount = k-1
2750       END IF
2760     NEXT i
2770     CALL drawBarChart(count, nIntervals)
2780     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
2790     FOR k = 0 TO nIntervals-1
2800       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
2810     NEXT k
2820   ELSE
2830     PRINT "No numbers read."
2840   END IF
2850 END IF
2860 END
