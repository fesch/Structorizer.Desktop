MODULE FileApiGroupTest_arrz;
(* Generated by Structorizer 3.30-09 *)

(*
  NOTE:
  This first module of the file is a library module providing common resources
  for the following modules, which are separated by comment lines like
  "======= 8< =======...".
  You may have to cut this file apart at these lines in order to get the parts
  running, since the following modules may form sort of mutually independent
  applications or programs the coexistence of which in a single file might not
  be sensible.
 *)

(* Copyright (C) 2020-04-24 kay *)

(*
  Draws a bar chart from the array "values" of size nValues.
  Turtleizer must be activated and will scale the chart into a square of
  500 x 500 pixels
  Note: The function is not robust against empty array or totally equal values.
 *)
PROCEDURE drawBarChart*(values: ARRAY 50 OF LONGREAL; nValues: ???);
CONST
  (* Used range of the Turtleizer screen *)
  xSize = 500;
  ySize = 500;

VAR
  (* TODO: check and accomplish variable declarations *)
  yScale: ???;	(* FIXME! *)
  yAxis: ???;	(* FIXME! *)
  valMin: ???;	(* FIXME! *)
  valMax: ???;	(* FIXME! *)
  stripeWidth: ???;	(* FIXME! *)
  stripeHeight: ???;	(* FIXME! *)
  kMin: INTEGER;
  kMax: INTEGER;
  k: INTEGER;
BEGIN
  (* Used range of the Turtleizer screen *)
  kMin := 0;
  kMax := 0;
  FOR k := 1 TO nValues-1 DO
    IF values[k] > values[kMax] THEN
      kMax := k;
    END
    ELSE
      IF values[k] < values[kMin] THEN
        kMin := k;
      END;
    END;
  END;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  IF valMin < 0 THEN
    IF valMax > 0 THEN
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    END
    ELSE
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    END;
  END;
  (* draw coordinate axes *)
  gotoXY(1, ySize - 1);
  forward(ySize -1); (* color = ffffff *)
  penUp();
  backward(yAxis); (* color = ffffff *)
  right(90);
  penDown();
  forward(xSize -1); (* color = ffffff *)
  penUp();
  backward(xSize-1); (* color = ffffff *)
  stripeWidth := xSize / nValues;
  FOR k := 0 TO nValues-1 DO
    stripeHeight := values[k] * 1.0 / yScale;
    CASE k MOD 3 OF
      0:
      setPenColor(255,0,0);
    |
      1:
      setPenColor(0, 255,0);
    |
      2:
      setPenColor(0, 0, 255);
    |
    END;
    fd(1); (* color = ffffff *)
    left(90);
    penDown();
    fd(stripeHeight); (* color = ffffff *)
    right(90);
    fd(stripeWidth - 1); (* color = ffffff *)
    right(90);
    forward(stripeHeight); (* color = ffffff *)
    left(90);
    penUp();
  END;
END drawBarChart;

(*
  Tries to read as many integer values as possible upto maxNumbers
  from file fileName into the given array numbers.
  Returns the number of the actually read numbers. May cause an exception.
 *)
PROCEDURE readNumbers*(fileName: ARRAY 128 OF CHAR; VAR numbers: ARRAY 50 OF INTEGER; maxNumbers: INTEGER): INTEGER;
VAR
  (* TODO: check and accomplish variable declarations *)
  number: INTEGER;
  nNumbers: INTEGER;
  fileNo: INTEGER;
BEGIN
  nNumbers := 0;
  fileNo := fileOpen(fileName);
  IF fileNo <= 0 THEN
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw "File could not be opened!" *)
  END;
  (* try (FIXME!) *)
    WHILE ~ fileEOF(fileNo) & nNumbers < maxNumbers DO
      number := fileReadInt(fileNo);
      numbers[nNumbers] := number;
      nNumbers := nNumbers + 1;
    END;
  (* catch error (FIXME!) *)
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw *)
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN nNumbers;
END readNumbers;

BEGIN
  
END FileApiGroupTest_arrz.

(* ======= 8< =========================================================== *)

(*
  Computes the sum and average of the numbers read from a user-specified
  text file (which might have been created via generateRandomNumberFile(4)).
  
  This program is part of an arrangement used to test group code export (issue
  #828) with FileAPI dependency.
  The input check loop has been disabled (replaced by a simple unchecked input
  instruction) in order to test the effect of indirect FileAPI dependency (only the
  called subroutine directly requires FileAPI now).
 *)
MODULE ComputeSum;
(* Generated by Structorizer 3.30-09 *)
IMPORT FileApiGroupTest_arrz,In,Out;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  values: ARRAY 50 OF ???;	(* FIXME! *)
  sum: LONGREAL;
  nValues: INTEGER;
  k: INTEGER;
  (* Disable this if you enable the loop below! *)
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  failure: Exception;

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := 1000;
  (* Disable this if you enable the loop below! *)
  (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
  Out.String("Name/path of the number file"); In.TYPE(file_name);
  (*
    If you enable this loop, then the preceding input instruction is to be disabled
    and the fileClose instruction in the alternative below is to be enabled.
   *)
(*   REPEAT *)
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
(*     Out.String("Name/path of the number file"); In.TYPE(file_name); *)
(*     fileNo := fileOpen(file_name); *)
(*   UNTIL fileNo > 0 OR file_name = ""; *)
  IF fileNo > 0 THEN
    (* This should be enabled if the input check loop above gets enabled. *)
(*     fileClose(fileNo); *)
    (* Hint: Automatically decomposed array initialization *)
    nValues := 0;
    (* try (FIXME!) *)
      nValues := readNumbers(file_name, values, 1000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
      (* FIXME: Find a solution to exit the program here! *)
      (* exit -7 *)
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    sum := 0.0;
    FOR k := 0 TO nValues-1 DO
      sum := sum + values[k];
    END;
    Out.String("sum = ");
    Out.Real(sum, 10);
    Out.Ln;
    Out.String("average = ");
    (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
    Out.TYPE(sum / nValues);
    Out.Ln;
  END;
END ComputeSum.

(* ======= 8< =========================================================== *)

(*
  Reads a random number file and draws a histogram accotrding to the
  user specifications
 *)
MODULE DrawRandomHistogram;
(* Generated by Structorizer 3.30-09 *)
IMPORT FileApiGroupTest_arrz,In,Out;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  (* Interval width *)
  width: ???;	(* FIXME! *)
  value: ???;	(* FIXME! *)
  numberArray: ARRAY 50 OF ???;	(* FIXME! *)
  nObtained: INTEGER;
  nIntervals: ???;	(* FIXME! *)
  min: ???;	(* FIXME! *)
  max: ???;	(* FIXME! *)
  kMaxCount: INTEGER;
  k: INTEGER;
  i: INTEGER;
  file_name: ???;	(* FIXME! *)
  fileNo: ???;	(* FIXME! *)
  count: ARRAY 50 OF INTEGER;
  failure: Exception;

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := -10;
  REPEAT
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("Name/path of the number file"); In.TYPE(file_name);
    fileNo := fileOpen(file_name);
  UNTIL fileNo > 0 OR file_name = "";
  IF fileNo > 0 THEN
    fileClose(fileNo);
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("number of intervals"); In.TYPE(nIntervals);
    (* Initialize the interval counters *)
    FOR k := 0 TO nIntervals-1 DO
      count[k] := 0;
    END;
    (* Index of the most populated interval *)
    kMaxCount := 0;
    (* Hint: Automatically decomposed array initialization *)
    nObtained := 0;
    (* try (FIXME!) *)
      nObtained := readNumbers(file_name, numberArray, 10000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    IF nObtained > 0 THEN
      min := numberArray[0];
      max := numberArray[0];
      FOR i := 1 TO nObtained-1 DO
        IF numberArray[i] < min THEN
          min := numberArray[i];
        END
        ELSE
          IF numberArray[i] > max THEN
            max := numberArray[i];
          END;
        END;
      END;
      (* Interval width *)
      width := (max - min) * 1.0 / nIntervals;
      FOR i := 0 TO nObtained - 1 DO
        value := numberArray[i];
        k := 1;
        WHILE k < nIntervals & value > min + k * width DO
          k := k + 1;
        END;
        count[k-1] := count[k-1] + 1;
        IF count[k-1] > count[kMaxCount] THEN
          kMaxCount := k-1;
        END;
      END;
      drawBarChart(count, nIntervals);
      Out.String("Interval with max count: ");
      Out.Int(kMaxCount, 10);
      Out.String(" (");
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(count[kMaxCount]);
      Out.String(")");
      Out.Ln;
      FOR k := 0 TO nIntervals-1 DO
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(count[k]);
        Out.String(" numbers in interval ");
        Out.Int(k, 10);
        Out.String(" (");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + k * width);
        Out.String(" ... ");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + (k+1) * width);
        Out.String(")");
        Out.Ln;
      END;
    END
    ELSE
      Out.String("No numbers read.");
      Out.Ln;
    END;
  END;
END DrawRandomHistogram.

(* ======= 8< =========================================================== *)

MODULE generateRandomNumberFile;
(* Generated by Structorizer 3.30-09 *)

IMPORT In,Out;
(*
  Writes a text file with name fileName, consisting of count lines, each containing
  a random number in the range from minVal to maxVal (both inclusive).
  Returns either the number of written number if all went well or some potential
  error code if something went wrong.
 *)
PROCEDURE generateRandomNumberFile*(fileName: ARRAY 128 OF CHAR; count, minVal, maxVal: INTEGER): INTEGER;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  number: ???;	(* FIXME! *)
  k: INTEGER;
  fileNo: INTEGER;
  error: Exception;
BEGIN
  fileNo := fileCreate(fileName);
  IF fileNo <= 0 THEN
    RETURN fileNo;
  END;
  (* try (FIXME!) *)
    FOR k := 1 TO count DO
      number := minVal + random(maxVal - minVal + 1);
      fileWriteLine(fileNo, number);
    END;
  (* catch error (FIXME!) *)
    (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
    Out.TYPE(error);
    Out.Ln;
    RETURN -7;
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN count;
END generateRandomNumberFile;

BEGIN
  In.Open;
  Out.Open;
  
END generateRandomNumberFile.
