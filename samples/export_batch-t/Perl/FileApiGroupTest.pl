#!/usr/bin/perl
# Generated by Structorizer 3.32-32 

# Copyright (C) 2020-03-21 Kay Gürtzig 
# License: GPLv3-link 
# GNU General Public License (V 3) 
# https://www.gnu.org/licenses/gpl.html 
# http://www.gnu.de/documents/gpl.de.html 

use strict;
use warnings;
use Class::Struct;

# TODO: This algorithm made use of the Structorizer File API, 
#       which cannot not be translated completely. 
#       Watch out for "TODO FileAPI" comments and try to adapt 
#       the code according to the recommendations. 
#       See e.g. http://perldoc.perl.org/perlopentut.html 

sub finally (&) { Finally->new(@_) }

# Draws a bar chart from the array "values" of size nValues. 
# Turtleizer must be activated and will scale the chart into a square of 
# 500 x 500 pixels 
# Note: The function is not robust against empty array or totally equal values. 
sub drawBarChart {
    my $values = $_[0];
    my $nValues = $_[1];

    # Used range of the Turtleizer screen 
    const xSize <- 500;
    const ySize <- 500;
    kMin <- 0;
    kMax <- 0;

    for ($k = 1; $k <= nValues-1; $k += (1)) {

        if ( values[k] > values[kMax] ) {
            kMax <- k;
        }
        else if ( values[k] < values[kMin] ) {
            kMin <- k;
        }

    }

    valMin <- values[kMin];
    valMax <- values[kMax];
    yScale <- valMax * 1.0 / (ySize - 1);
    yAxis <- ySize - 1;

    if ( valMin < 0 ) {

        if ( valMax > 0 ) {
            yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
            yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
        }
        else {
            yAxis <- 1;
            yScale <- valMin * 1.0 / (ySize - 1);
        }

    }

    # draw coordinate axes 
    gotoXY(1, ySize - 1);
    forward(ySize -1); # color = ffffff
    penUp();
    backward(yAxis); # color = ffffff
    right(90);
    penDown();
    forward(xSize -1); # color = ffffff
    penUp();
    backward(xSize-1); # color = ffffff
    stripeWidth <- xSize / nValues;

    for ($k = 0; $k <= nValues-1; $k += (1)) {
        stripeHeight <- values[k] * 1.0 / yScale;

        switch ( k mod 3 ) {

            case (0) {
                setPenColor(255,0,0);
            }

            case (1) {
                setPenColor(0, 255,0);
            }

            case (2) {
                setPenColor(0, 0, 255);
            }
        }

        fd(1); # color = ffffff
        left(90);
        penDown();
        fd(stripeHeight); # color = ffffff
        right(90);
        fd(stripeWidth - 1); # color = ffffff
        right(90);
        forward(stripeHeight); # color = ffffff
        left(90);
        penUp();
    }

}

# = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# Tries to read as many integer values as possible upto maxNumbers 
# from file fileName into the given array numbers. 
# Returns the number of the actually read numbers. May cause an exception. 
sub readNumbers {
    my $fileName = $_[0];
    my $numbers = $_[1];
    my $maxNumbers = $_[2];

    nNumbers <- 0;
    fileNo <- fileOpen(fileName);

    if ( fileNo <= 0 ) {
        die "File could not be opened!";
    }

    eval {
        my $final192d3247 = finally {
            fileClose(fileNo);
        };

        while ( not fileEOF(fileNo) and nNumbers < maxNumbers ) {
            number <- fileReadInt(fileNo);
            numbers[nNumbers] <- number;
            nNumbers <- nNumbers + 1;
        }

    };
    if (my $ex192d3247 = $@) {
        die ;
    };
    return nNumbers;
}

# ---------------------------------------------------------------------- 
#  Finally class, introduced to handle finally blocks via RAII 
# ---------------------------------------------------------------------- 
package Finally;
sub new {
    my ($class, $code) = @_;
    bless {code => $code}, $class;
}
sub DESTROY { my ($self) = @_; $self->{code}->() }

# ======= 8< =========================================================== 

#!/usr/bin/perl
# Generated by Structorizer 3.32-32 

# Copyright (C) 2020-03-21 Kay Gürtzig 
# License: GPLv3-link 
# GNU General Public License (V 3) 
# https://www.gnu.org/licenses/gpl.html 
# http://www.gnu.de/documents/gpl.de.html 

use FileApiGroupTest;
use strict;
use warnings;
use Class::Struct;
sub finally (&) { Finally->new(@_) }

# = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# Computes the sum and average of the numbers read from a user-specified 
# text file (which might have been created via generateRandomNumberFile(4)). 
#  
# This program is part of an arrangement used to test group code export (issue 
# #828) with FileAPI dependency. 
# The input check loop has been disabled (replaced by a simple unchecked input 
# instruction) in order to test the effect of indirect FileAPI dependency (only the 
# called subroutine directly requires FileAPI now). 

fileNo <- 1000;
# Disable this if you enable the loop below! 
print "Name/path of the number file"; chomp(file_name = <STDIN>);
#  
# If you enable this loop, then the preceding input instruction is to be disabled 
# and the fileClose instruction in the alternative below is to be enabled. 
# do { 
#     print "Name/path of the number file"; chomp(file_name = <STDIN>); 
#     fileNo <- fileOpen(file_name); 
# } while (!( fileNo > 0 or file_name = "" )); 
#  

if ( fileNo > 0 ) {
    # This should be enabled if the input check loop above gets enabled. 
#     fileClose(fileNo); 
    values <- {};
    nValues <- 0;
    eval {
        nValues <- readNumbers(file_name, values, 1000);
    };
    if (my $ex32eebfca = $@) {
        print failure, "\n";
        exit(-7);
    };
    sum <- 0.0;

    for ($k = 0; $k <= nValues-1; $k += (1)) {
        sum <- sum + values[k];
    }

    print "sum = ", sum, "\n";
    print "average = ", sum / nValues, "\n";
}

# ---------------------------------------------------------------------- 
#  Finally class, introduced to handle finally blocks via RAII 
# ---------------------------------------------------------------------- 
package Finally;
sub new {
    my ($class, $code) = @_;
    bless {code => $code}, $class;
}
sub DESTROY { my ($self) = @_; $self->{code}->() }

# ======= 8< =========================================================== 

#!/usr/bin/perl
# Generated by Structorizer 3.32-32 

# Copyright (C) 2020-03-21 Kay Gürtzig 
# License: GPLv3-link 
# GNU General Public License (V 3) 
# https://www.gnu.org/licenses/gpl.html 
# http://www.gnu.de/documents/gpl.de.html 

use FileApiGroupTest;
use strict;
use warnings;
use Class::Struct;

# TODO: This algorithm made use of the Structorizer File API, 
#       which cannot not be translated completely. 
#       Watch out for "TODO FileAPI" comments and try to adapt 
#       the code according to the recommendations. 
#       See e.g. http://perldoc.perl.org/perlopentut.html 

sub finally (&) { Finally->new(@_) }

# Draws a bar chart from the array "values" of size nValues. 
# Turtleizer must be activated and will scale the chart into a square of 
# 500 x 500 pixels 
# Note: The function is not robust against empty array or totally equal values. 
sub drawBarChart {
    my $values = $_[0];
    my $nValues = $_[1];

    # Used range of the Turtleizer screen 
    const xSize <- 500;
    const ySize <- 500;
    kMin <- 0;
    kMax <- 0;

    for ($k = 1; $k <= nValues-1; $k += (1)) {

        if ( values[k] > values[kMax] ) {
            kMax <- k;
        }
        else if ( values[k] < values[kMin] ) {
            kMin <- k;
        }

    }

    valMin <- values[kMin];
    valMax <- values[kMax];
    yScale <- valMax * 1.0 / (ySize - 1);
    yAxis <- ySize - 1;

    if ( valMin < 0 ) {

        if ( valMax > 0 ) {
            yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
            yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
        }
        else {
            yAxis <- 1;
            yScale <- valMin * 1.0 / (ySize - 1);
        }

    }

    # draw coordinate axes 
    gotoXY(1, ySize - 1);
    forward(ySize -1); # color = ffffff
    penUp();
    backward(yAxis); # color = ffffff
    right(90);
    penDown();
    forward(xSize -1); # color = ffffff
    penUp();
    backward(xSize-1); # color = ffffff
    stripeWidth <- xSize / nValues;

    for ($k = 0; $k <= nValues-1; $k += (1)) {
        stripeHeight <- values[k] * 1.0 / yScale;

        switch ( k mod 3 ) {

            case (0) {
                setPenColor(255,0,0);
            }

            case (1) {
                setPenColor(0, 255,0);
            }

            case (2) {
                setPenColor(0, 0, 255);
            }
        }

        fd(1); # color = ffffff
        left(90);
        penDown();
        fd(stripeHeight); # color = ffffff
        right(90);
        fd(stripeWidth - 1); # color = ffffff
        right(90);
        forward(stripeHeight); # color = ffffff
        left(90);
        penUp();
    }

}

# = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# Reads a random number file and draws a histogram accotrding to the 
# user specifications 

fileNo <- -10;

do {
    print "Name/path of the number file"; chomp(file_name = <STDIN>);
    fileNo <- fileOpen(file_name);
} while (!( fileNo > 0 or file_name = "" ));


if ( fileNo > 0 ) {
    fileClose(fileNo);
    print "number of intervals"; chomp(nIntervals = <STDIN>);

    # Initialize the interval counters 
    for ($k = 0; $k <= nIntervals-1; $k += (1)) {
        count[k] <- 0;
    }

    # Index of the most populated interval 
    kMaxCount <- 0;
    numberArray <- {};
    nObtained <- 0;
    eval {
        nObtained <- readNumbers(file_name, numberArray, 10000);
    };
    if (my $ex289d1c02 = $@) {
        print failure, "\n";
    };

    if ( nObtained > 0 ) {
        min <- numberArray[0];
        max <- numberArray[0];

        for ($i = 1; $i <= nObtained-1; $i += (1)) {

            if ( numberArray[i] < min ) {
                min <- numberArray[i];
            }
            else if ( numberArray[i] > max ) {
                max <- numberArray[i];
            }

        }

        # Interval width 
        width <- (max - min) * 1.0 / nIntervals;

        for ($i = 0; $i <= nObtained - 1; $i += (1)) {
            value <- numberArray[i];
            k <- 1;

            while ( k < nIntervals and value > min + k * width ) {
                k <- k + 1;
            }

            count[k-1] <- count[k-1] + 1;

            if ( count[k-1] > count[kMaxCount] ) {
                kMaxCount <- k-1;
            }

        }

        drawBarChart(count, nIntervals);
        print "Interval with max count: ", kMaxCount, " (", count[kMaxCount], ")", "\n";

        for ($k = 0; $k <= nIntervals-1; $k += (1)) {
            print count[k], " numbers in interval ", k, " (", min + k * width, " ... ", min + (k+1) * width, ")", "\n";
        }

    }
    else {
        print "No numbers read.", "\n";
    }

}

# ---------------------------------------------------------------------- 
#  Finally class, introduced to handle finally blocks via RAII 
# ---------------------------------------------------------------------- 
package Finally;
sub new {
    my ($class, $code) = @_;
    bless {code => $code}, $class;
}
sub DESTROY { my ($self) = @_; $self->{code}->() }
