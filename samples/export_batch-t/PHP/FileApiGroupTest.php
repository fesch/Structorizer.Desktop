<?php
// function readNumbers (generated by Structorizer 3.32-32) 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

require_once 'StructorizerFileAPI';

// function drawBarChart 
// Draws a bar chart from the array "values" of size nValues. 
// Turtleizer must be activated and will scale the chart into a square of 
// 500 x 500 pixels 
// Note: The function is not robust against empty array or totally equal values. 
function drawBarChart(values: array of double; nValues)
{

	// TODO Establish sensible web formulars to get the $_GET input working. 

	// Used range of the Turtleizer screen 
	const xSize <- 500;
	const ySize <- 500;
	kMin <- 0;
	kMax <- 0;
	for ($k = 1; $k <= nValues-1; $k += (1))
	{
		if (values[k] > values[kMax])
		{
			kMax <- k;
		}
		else if values[k] < values[kMin]
		{
			kMin <- k;
		}
	}
	valMin <- values[kMin];
	valMax <- values[kMax];
	yScale <- valMax * 1.0 / (ySize - 1);
	yAxis <- ySize - 1;
	if (valMin < 0)
	{
		if (valMax > 0)
		{
			yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
			yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
		}
		else
		{
			yAxis <- 1;
			yScale <- valMin * 1.0 / (ySize - 1);
		}
	}
	// draw coordinate axes 
	gotoXY(1, ySize - 1);
	forward(ySize -1); // color = ffffff
	penUp();
	backward(yAxis); // color = ffffff
	right(90);
	penDown();
	forward(xSize -1); // color = ffffff
	penUp();
	backward(xSize-1); // color = ffffff
	stripeWidth <- xSize / nValues;
	for ($k = 0; $k <= nValues-1; $k += (1))
	{
		stripeHeight <- values[k] * 1.0 / yScale;
		switch (k mod 3) 
		{
			case 0:
				setPenColor(255,0,0);
				break;
			case 1:
				setPenColor(0, 255,0);
				break;
			case 2:
				setPenColor(0, 0, 255);
				break;
		}
		fd(1); // color = ffffff
		left(90);
		penDown();
		fd(stripeHeight); // color = ffffff
		right(90);
		fd(stripeWidth - 1); // color = ffffff
		right(90);
		forward(stripeHeight); // color = ffffff
		left(90);
		penUp();
	}
}
// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// function readNumbers 
// Tries to read as many integer values as possible upto maxNumbers 
// from file fileName into the given array numbers. 
// Returns the number of the actually read numbers. May cause an exception. 
function readNumbers(fileName: string; numbers: array of integer; maxNumbers: integer): integer()
{

	// TODO Establish sensible web formulars to get the $_GET input working. 

	nNumbers <- 0;
	fileNo <- fileOpen(fileName);
	if (fileNo <= 0)
	{
		throw new Exception("File could not be opened!");
	}
	try {
		while (not fileEOF(fileNo) and nNumbers < maxNumbers) 
		{
			number <- fileReadInt(fileNo);
			numbers[nNumbers] <- number;
			nNumbers <- nNumbers + 1;
		}
	} catch (Exception $ex192d3247) {
		$error = $ex192d3247->getMessage();
		throw $ex192d3247;
	} finally {
		fileClose(fileNo);
	}
	return nNumbers;
}

?>

// ======= 8< =========================================================== 

<?php
// program ComputeSum (generated by Structorizer 3.32-32) 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

require_once 'FileApiGroupTest';

// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// Computes the sum and average of the numbers read from a user-specified 
// text file (which might have been created via generateRandomNumberFile(4)). 
//  
// This program is part of an arrangement used to test group code export (issue 
// #828) with FileAPI dependency. 
// The input check loop has been disabled (replaced by a simple unchecked input 
// instruction) in order to test the effect of indirect FileAPI dependency (only the 
// called subroutine directly requires FileAPI now). 

// TODO Establish sensible web formulars to get the $_GET input working. 

fileNo <- 1000;
// Disable this if you enable the loop below! 
file_name = $_REQUEST["Name/path of the number file"];	// TODO form a sensible input opportunity;
// If you enable this loop, then the preceding input instruction is to be disabled 
// and the fileClose instruction in the alternative below is to be enabled. 
// do 
// { 
// 	file_name = $_REQUEST["Name/path of the number file"];	// TODO form a sensible input opportunity; 
// 	fileNo <- fileOpen(file_name); 
// } while (!( fileNo > 0 or file_name = "" )); 
if (fileNo > 0)
{
	// This should be enabled if the input check loop above gets enabled. 
// 	fileClose(fileNo); 
	values <- {};
	nValues <- 0;
	try {
		nValues <- readNumbers(file_name, values, 1000);
	} catch (Exception $ex4e718207) {
		$failure = $ex4e718207->getMessage();
		echo failure;
		exit(-7);
	}
	sum <- 0.0;
	for ($k = 0; $k <= nValues-1; $k += (1))
	{
		sum <- sum + values[k];
	}
	echo "sum = ", sum;
	echo "average = ", sum / nValues;
}

?>

// ======= 8< =========================================================== 

<?php
// program DrawRandomHistogram (generated by Structorizer 3.32-32) 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

require_once 'FileApiGroupTest';
require_once 'StructorizerFileAPI';

// function drawBarChart 
// Draws a bar chart from the array "values" of size nValues. 
// Turtleizer must be activated and will scale the chart into a square of 
// 500 x 500 pixels 
// Note: The function is not robust against empty array or totally equal values. 
function drawBarChart(values: array of double; nValues)
{

	// TODO Establish sensible web formulars to get the $_GET input working. 

	// Used range of the Turtleizer screen 
	const xSize <- 500;
	const ySize <- 500;
	kMin <- 0;
	kMax <- 0;
	for ($k = 1; $k <= nValues-1; $k += (1))
	{
		if (values[k] > values[kMax])
		{
			kMax <- k;
		}
		else if values[k] < values[kMin]
		{
			kMin <- k;
		}
	}
	valMin <- values[kMin];
	valMax <- values[kMax];
	yScale <- valMax * 1.0 / (ySize - 1);
	yAxis <- ySize - 1;
	if (valMin < 0)
	{
		if (valMax > 0)
		{
			yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
			yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
		}
		else
		{
			yAxis <- 1;
			yScale <- valMin * 1.0 / (ySize - 1);
		}
	}
	// draw coordinate axes 
	gotoXY(1, ySize - 1);
	forward(ySize -1); // color = ffffff
	penUp();
	backward(yAxis); // color = ffffff
	right(90);
	penDown();
	forward(xSize -1); // color = ffffff
	penUp();
	backward(xSize-1); // color = ffffff
	stripeWidth <- xSize / nValues;
	for ($k = 0; $k <= nValues-1; $k += (1))
	{
		stripeHeight <- values[k] * 1.0 / yScale;
		switch (k mod 3) 
		{
			case 0:
				setPenColor(255,0,0);
				break;
			case 1:
				setPenColor(0, 255,0);
				break;
			case 2:
				setPenColor(0, 0, 255);
				break;
		}
		fd(1); // color = ffffff
		left(90);
		penDown();
		fd(stripeHeight); // color = ffffff
		right(90);
		fd(stripeWidth - 1); // color = ffffff
		right(90);
		forward(stripeHeight); // color = ffffff
		left(90);
		penUp();
	}
}
// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// Reads a random number file and draws a histogram accotrding to the 
// user specifications 

// TODO Establish sensible web formulars to get the $_GET input working. 

fileNo <- -10;
do
{
	file_name = $_REQUEST["Name/path of the number file"];	// TODO form a sensible input opportunity;
	fileNo <- fileOpen(file_name);
} while (!( fileNo > 0 or file_name = "" ));
if (fileNo > 0)
{
	fileClose(fileNo);
	nIntervals = $_REQUEST["number of intervals"];	// TODO form a sensible input opportunity;
	// Initialize the interval counters 
	for ($k = 0; $k <= nIntervals-1; $k += (1))
	{
		count[k] <- 0;
	}
	// Index of the most populated interval 
	kMaxCount <- 0;
	numberArray <- {};
	nObtained <- 0;
	try {
		nObtained <- readNumbers(file_name, numberArray, 10000);
	} catch (Exception $ex289d1c02) {
		$failure = $ex289d1c02->getMessage();
		echo failure;
	}
	if (nObtained > 0)
	{
		min <- numberArray[0];
		max <- numberArray[0];
		for ($i = 1; $i <= nObtained-1; $i += (1))
		{
			if (numberArray[i] < min)
			{
				min <- numberArray[i];
			}
			else if numberArray[i] > max
			{
				max <- numberArray[i];
			}
		}
		// Interval width 
		width <- (max - min) * 1.0 / nIntervals;
		for ($i = 0; $i <= nObtained - 1; $i += (1))
		{
			value <- numberArray[i];
			k <- 1;
			while (k < nIntervals and value > min + k * width) 
			{
				k <- k + 1;
			}
			count[k-1] <- count[k-1] + 1;
			if (count[k-1] > count[kMaxCount])
			{
				kMaxCount <- k-1;
			}
		}
		drawBarChart(count, nIntervals);
		echo "Interval with max count: ", kMaxCount, " (", count[kMaxCount], ")";
		for ($k = 0; $k <= nIntervals-1; $k += (1))
		{
			echo count[k], " numbers in interval ", k, " (", min + k * width, " ... ", min + (k+1) * width, ")";
		}
	}
	else
	{
		echo "No numbers read.";
	}
}

?>
