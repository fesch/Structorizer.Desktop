10 REM Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
20 REM to allow performance comparison via execution counting ("Collect Runtime Data" should 
30 REM sensibly be switched on). 
40 REM Requested input data are: Number of elements (size) and filing mode. 
50 REM Generated by Structorizer 3.32-32 
60 
70 REM Copyright (C) 2019-10-02 Kay Gürtzig 
80 REM License: GPLv3-link 
90 REM GNU General Public License (V 3) 
100 REM https://www.gnu.org/licenses/gpl.html 
110 REM http://www.gnu.de/documents/gpl.de.html 
120 
130 REM  
140 REM program SORTING_TEST_MAIN
150 REM TODO: add the respective type suffixes to your variable names if required 
160 REM  
170 DO
180   INPUT elementCount
190 LOOP UNTIL elementCount >= 1
200 DO
210   PRINT "Filling: 1 = random, 2 = increasing, 3 = decreasing"; : INPUT modus
220 LOOP UNTIL modus = 1 or modus = 2 or modus = 3
230 FOR i = 0 TO elementCount-1
240   SELECT CASE modus
250     CASE 1
260       values1[i] <- random(10000)
270     CASE 2
280       values1[i] <- i
290     CASE 3
300       values1[i] <- -i
310   END SELECT
320 NEXT i
330 REM Copy the array for exact comparability 
340 FOR i = 0 TO elementCount-1
350   values2[i] <- values1[i]
360   values3[i] <- values1[i]
370 NEXT i
380 
390 REM ========================================================== 
400 REM ================= START PARALLEL SECTION ================= 
410 REM ========================================================== 
420 REM TODO: add the necessary code to run the threads concurrently 
430 
440   REM ----------------- START THREAD 0 ----------------- 
450     CALL bubbleSort(values1)
460   REM ------------------ END THREAD 0 ------------------ 
470 
480 
490   REM ----------------- START THREAD 1 ----------------- 
500     CALL quickSort(values2, 0, elementCount)
510   REM ------------------ END THREAD 1 ------------------ 
520 
530 
540   REM ----------------- START THREAD 2 ----------------- 
550     CALL heapSort(values3)
560   REM ------------------ END THREAD 2 ------------------ 
570 
580 REM ========================================================== 
590 REM ================== END PARALLEL SECTION ================== 
600 REM ========================================================== 
610 
620 ok1 <- testSorted(values1)
630 ok2 <- testSorted(values2)
640 ok3 <- testSorted(values3)
650 IF not ok1 or not ok2 or not ok3 THEN
660   FOR i = 0 TO elementCount-1
670     IF values1[i] <> values2[i] or values1[i] <> values3[i] THEN
680       PRINT "Difference at ["; i; "]: "; values1[i]; " <-> "; values2[i]; " <-> "; values3[i]
690     END IF
700   NEXT i
710 END IF
720 DO
730   PRINT "Show arrays (yes/no)?"; : INPUT show
740 LOOP UNTIL show = "yes" or show = "no"
750 IF show = "yes" THEN
760   FOR i = 0 TO elementCount - 1
770     PRINT "["; i; "]:\t"; values1[i]; "\t"; values2[i]; "\t"; values3[i]
780   NEXT i
790 END IF
800 END
810 REM  
820 REM Implements the well-known BubbleSort algorithm. 
830 REM Compares neigbouring elements and swaps them in case of an inversion. 
840 REM Repeats this while inversions have been found. After every 
850 REM loop passage at least one element (the largest one out of the 
860 REM processed subrange) finds its final place at the end of the 
870 REM subrange. 
880 REM TODO: Add type-specific suffixes where necessary! 
890 SUB bubbleSort(values)
900   REM TODO: add the respective type suffixes to your variable names if required 
910   REM  
920   REM  
930   ende <- length(values) - 2
940   DO
950     REM The index of the most recent swapping (-1 means no swapping done). 
960     posSwapped <- -1
970     FOR i = 0 TO ende
980       IF values[i] > values[i+1] THEN
990         temp <- values[i]
1000         values[i] <- values[i+1]
1010         values[i+1] <- temp
1020         posSwapped <- i
1030       END IF
1040     NEXT i
1050     ende <- posSwapped - 1
1060   LOOP UNTIL posSwapped < 0
1070 END SUB
1080 REM  
1090 REM Given a max-heap 'heap´ with element at index 'i´ possibly 
1100 REM violating the heap property wrt. its subtree upto and including 
1110 REM index range-1, restores heap property in the subtree at index i 
1120 REM again. 
1130 REM TODO: Add type-specific suffixes where necessary! 
1140 SUB maxHeapify(heap, i, range)
1150   REM TODO: add the respective type suffixes to your variable names if required 
1160   REM  
1170   REM  
1180   REM Indices of left and right child of node i 
1190   right <- (i+1) * 2
1200   left <- right - 1
1210   REM Index of the (local) maximum 
1220   max <- i
1230   IF left < range and heap[left] > heap[i] THEN
1240     max <- left
1250   END IF
1260   IF right < range and heap[right] > heap[max] THEN
1270     max <- right
1280   END IF
1290   IF max <> i THEN
1300     temp <- heap[i]
1310     heap[i] <- heap[max]
1320     heap[max] <- temp
1330     CALL maxHeapify(heap, max, range)
1340   END IF
1350 END SUB
1360 REM  
1370 REM Partitions array 'values´ between indices 'start´ und 'stop´-1 with 
1380 REM respect to the pivot element initially at index 'p´ into smaller 
1390 REM and greater elements. 
1400 REM Returns the new (and final) index of the pivot element (which 
1410 REM separates the sequence of smaller elements from the sequence 
1420 REM of greater elements). 
1430 REM This is not the most efficient algorithm (about half the swapping 
1440 REM might still be avoided) but it is pretty clear. 
1450 REM TODO: Add type-specific suffixes where necessary! 
1460 FUNCTION partition(values, start, stop, p) AS Integer
1470   REM TODO: add the respective type suffixes to your variable names if required 
1480   REM  
1490   REM  
1500   REM Cache the pivot element 
1510   pivot <- values[p]
1520   REM Exchange the pivot element with the start element 
1530   values[p] <- values[start]
1540   values[start] <- pivot
1550   p <- start
1560   REM Beginning and end of the remaining undiscovered range 
1570   start <- start + 1
1580   stop <- stop - 1
1590   REM Still unseen elements? 
1600   REM Loop invariants: 
1610   REM 1. p = start - 1 
1620   REM 2. pivot = values[p] 
1630   REM 3. i < start → values[i] ≤ pivot 
1640   REM 4. stop < i → pivot < values[i] 
1650   DO WHILE start <= stop
1660     REM Fetch the first element of the undiscovered area 
1670     seen <- values[start]
1680     REM Does the checked element belong to the smaller area? 
1690     IF seen <= pivot THEN
1700       REM Insert the seen element between smaller area and pivot element 
1710       values[p] <- seen
1720       values[start] <- pivot
1730       REM Shift the border between lower and undicovered area, 
1740       REM update pivot position. 
1750       p <- p + 1
1760       start <- start + 1
1770     ELSE
1780       REM Insert the checked element between undiscovered and larger area 
1790       values[start] <- values[stop]
1800       values[stop] <- seen
1810       REM Shift the border between undiscovered and larger area 
1820       stop <- stop - 1
1830     END IF
1840   LOOP
1850   RETURN p
1860 END FUNCTION
1870 REM  
1880 REM Checks whether or not the passed-in array is (ascendingly) sorted. 
1890 REM TODO: Add type-specific suffixes where necessary! 
1900 FUNCTION testSorted(numbers) AS bool
1910   REM TODO: add the respective type suffixes to your variable names if required 
1920   REM  
1930   REM  
1940   isSorted <- true
1950   i <- 0
1960   REM As we compare with the following element, we must stop at the penultimate index 
1970   DO WHILE isSorted and (i <= length(numbers)-2)
1980     REM Is there an inversion? 
1990     IF numbers[i] > numbers[i+1] THEN
2000       isSorted <- false
2010     ELSE
2020       i <- i + 1
2030     END IF
2040   LOOP
2050   RETURN isSorted
2060 END FUNCTION
2070 REM  
2080 REM Runs through the array heap and converts it to a max-heap 
2090 REM in a bottom-up manner, i.e. starts above the "leaf" level 
2100 REM (index >= length(heap) div 2) and goes then up towards 
2110 REM the root. 
2120 REM TODO: Add type-specific suffixes where necessary! 
2130 SUB buildMaxHeap(heap)
2140   REM TODO: add the respective type suffixes to your variable names if required 
2150   REM  
2160   REM  
2170   lgth <- length(heap)
2180   FOR k = lgth div 2 - 1 TO 0 STEP -1
2190     CALL maxHeapify(heap, k, lgth)
2200   NEXT k
2210 END SUB
2220 REM  
2230 REM Recursively sorts a subrange of the given array 'values´.  
2240 REM start is the first index of the subsequence to be sorted, 
2250 REM stop is the index BEHIND the subsequence to be sorted. 
2260 REM TODO: Add type-specific suffixes where necessary! 
2270 SUB quickSort(values, start, stop)
2280   REM TODO: add the respective type suffixes to your variable names if required 
2290   REM  
2300   REM  
2310   REM At least 2 elements? (Less don't make sense.) 
2320   IF stop >= start + 2 THEN
2330     REM Select a pivot element, be p its index. 
2340     REM (here: randomly chosen element out of start ... stop-1) 
2350     p <- random(stop-start) + start
2360     REM Partition the array into smaller and greater elements 
2370     REM Get the resulting (and final) position of the pivot element 
2380     p <- partition(values, start, stop, p)
2390     REM Sort subsequances separately and independently ... 
2400 
2410     REM ========================================================== 
2420     REM ================= START PARALLEL SECTION ================= 
2430     REM ========================================================== 
2440     REM TODO: add the necessary code to run the threads concurrently 
2450 
2460       REM ----------------- START THREAD 0 ----------------- 
2470         REM Sort left (lower) array part 
2480         CALL quickSort(values, start, p)
2490       REM ------------------ END THREAD 0 ------------------ 
2500 
2510 
2520       REM ----------------- START THREAD 1 ----------------- 
2530         REM Sort right (higher) array part 
2540         CALL quickSort(values, p+1, stop)
2550       REM ------------------ END THREAD 1 ------------------ 
2560 
2570     REM ========================================================== 
2580     REM ================== END PARALLEL SECTION ================== 
2590     REM ========================================================== 
2600 
2610   END IF
2620 END SUB
2630 REM  
2640 REM Sorts the array 'values´ of numbers according to he heap sort 
2650 REM algorithm 
2660 REM TODO: Add type-specific suffixes where necessary! 
2670 SUB heapSort(values)
2680   REM TODO: add the respective type suffixes to your variable names if required 
2690   REM  
2700   REM  
2710   CALL buildMaxHeap(values)
2720   heapRange <- length(values)
2730   FOR k = heapRange - 1 TO 1 STEP -1
2740     heapRange <- heapRange - 1
2750     REM Swap the maximum value (root of the heap) to the heap end 
2760     maximum <- values[0]
2770     values[0] <- values[heapRange]
2780     values[heapRange] <- maximum
2790     CALL maxHeapify(values, 0, heapRange)
2800   NEXT k
2810 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

