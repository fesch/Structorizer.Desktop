10 REM Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
20 REM to allow performance comparison via execution counting ("Collect Runtime Data" should 
30 REM sensibly be switched on). 
40 REM Requested input data are: Number of elements (size) and filing mode. 
50 REM Generated by Structorizer 3.32-31 
60 
70 REM Copyright (C) 2019-10-02 Kay Gürtzig 
80 REM License: GPLv3-link 
90 REM GNU General Public License (V 3) 
100 REM https://www.gnu.org/licenses/gpl.html 
110 REM http://www.gnu.de/documents/gpl.de.html 
120 
130 REM  
140 REM program SORTING_TEST_MAIN
150 REM TODO: add the respective type suffixes to your variable names if required 
160 DIM values3() AS Integer
170 DIM values2() AS Integer
180 DIM values1() AS Integer
190 REM  
200 DO
210   INPUT elementCount
220 LOOP UNTIL elementCount >= 1
230 DO
240   PRINT "Filling: 1 = random, 2 = increasing, 3 = decreasing"; : INPUT modus
250 LOOP UNTIL modus = 1 or modus = 2 or modus = 3
260 FOR i = 0 TO elementCount-1
270   SELECT CASE modus
280     CASE 1
290       values1[i] <- random(10000)
300     CASE 2
310       values1[i] <- i
320     CASE 3
330       values1[i] <- -i
340   END SELECT
350 NEXT i
360 REM Copy the array for exact comparability 
370 FOR i = 0 TO elementCount-1
380   values2[i] <- values1[i]
390   values3[i] <- values1[i]
400 NEXT i
410 
420 REM ========================================================== 
430 REM ================= START PARALLEL SECTION ================= 
440 REM ========================================================== 
450 REM TODO: add the necessary code to run the threads concurrently 
460 
470   REM ----------------- START THREAD 0 ----------------- 
480     CALL bubbleSort(values1)
490   REM ------------------ END THREAD 0 ------------------ 
500 
510 
520   REM ----------------- START THREAD 1 ----------------- 
530     CALL quickSort(values2, 0, elementCount)
540   REM ------------------ END THREAD 1 ------------------ 
550 
560 
570   REM ----------------- START THREAD 2 ----------------- 
580     CALL heapSort(values3)
590   REM ------------------ END THREAD 2 ------------------ 
600 
610 REM ========================================================== 
620 REM ================== END PARALLEL SECTION ================== 
630 REM ========================================================== 
640 
650 ok1 <- testSorted(values1)
660 ok2 <- testSorted(values2)
670 ok3 <- testSorted(values3)
680 IF not ok1 or not ok2 or not ok3 THEN
690   FOR i = 0 TO elementCount-1
700     IF values1[i] <> values2[i] or values1[i] <> values3[i] THEN
710       PRINT "Difference at ["; i; "]: "; values1[i]; " <-> "; values2[i]; " <-> "; values3[i]
720     END IF
730   NEXT i
740 END IF
750 DO
760   PRINT "Show arrays (yes/no)?"; : INPUT show
770 LOOP UNTIL show = "yes" or show = "no"
780 IF show = "yes" THEN
790   FOR i = 0 TO elementCount - 1
800     PRINT "["; i; "]:\t"; values1[i]; "\t"; values2[i]; "\t"; values3[i]
810   NEXT i
820 END IF
830 END
840 REM  
850 REM Implements the well-known BubbleSort algorithm. 
860 REM Compares neigbouring elements and swaps them in case of an inversion. 
870 REM Repeats this while inversions have been found. After every 
880 REM loop passage at least one element (the largest one out of the 
890 REM processed subrange) finds its final place at the end of the 
900 REM subrange. 
910 REM TODO: Add type-specific suffixes where necessary! 
920 SUB bubbleSort(values)
930   REM TODO: add the respective type suffixes to your variable names if required 
940   REM  
950   REM  
960   ende <- length(values) - 2
970   DO
980     REM The index of the most recent swapping (-1 means no swapping done). 
990     posSwapped <- -1
1000     FOR i = 0 TO ende
1010       IF values[i] > values[i+1] THEN
1020         temp <- values[i]
1030         values[i] <- values[i+1]
1040         values[i+1] <- temp
1050         posSwapped <- i
1060       END IF
1070     NEXT i
1080     ende <- posSwapped - 1
1090   LOOP UNTIL posSwapped < 0
1100 END SUB
1110 REM  
1120 REM Given a max-heap 'heap´ with element at index 'i´ possibly 
1130 REM violating the heap property wrt. its subtree upto and including 
1140 REM index range-1, restores heap property in the subtree at index i 
1150 REM again. 
1160 REM TODO: Add type-specific suffixes where necessary! 
1170 SUB maxHeapify(heap, i, range)
1180   REM TODO: add the respective type suffixes to your variable names if required 
1190   REM  
1200   REM  
1210   REM Indices of left and right child of node i 
1220   right <- (i+1) * 2
1230   left <- right - 1
1240   REM Index of the (local) maximum 
1250   max <- i
1260   IF left < range and heap[left] > heap[i] THEN
1270     max <- left
1280   END IF
1290   IF right < range and heap[right] > heap[max] THEN
1300     max <- right
1310   END IF
1320   IF max <> i THEN
1330     temp <- heap[i]
1340     heap[i] <- heap[max]
1350     heap[max] <- temp
1360     CALL maxHeapify(heap, max, range)
1370   END IF
1380 END SUB
1390 REM  
1400 REM Partitions array 'values´ between indices 'start´ und 'stop´-1 with 
1410 REM respect to the pivot element initially at index 'p´ into smaller 
1420 REM and greater elements. 
1430 REM Returns the new (and final) index of the pivot element (which 
1440 REM separates the sequence of smaller elements from the sequence 
1450 REM of greater elements). 
1460 REM This is not the most efficient algorithm (about half the swapping 
1470 REM might still be avoided) but it is pretty clear. 
1480 REM TODO: Add type-specific suffixes where necessary! 
1490 FUNCTION partition(values, start, stop, p) AS Integer
1500   REM TODO: add the respective type suffixes to your variable names if required 
1510   REM  
1520   REM  
1530   REM Cache the pivot element 
1540   pivot <- values[p]
1550   REM Exchange the pivot element with the start element 
1560   values[p] <- values[start]
1570   values[start] <- pivot
1580   p <- start
1590   REM Beginning and end of the remaining undiscovered range 
1600   start <- start + 1
1610   stop <- stop - 1
1620   REM Still unseen elements? 
1630   REM Loop invariants: 
1640   REM 1. p = start - 1 
1650   REM 2. pivot = values[p] 
1660   REM 3. i < start → values[i] ≤ pivot 
1670   REM 4. stop < i → pivot < values[i] 
1680   DO WHILE start <= stop
1690     REM Fetch the first element of the undiscovered area 
1700     seen <- values[start]
1710     REM Does the checked element belong to the smaller area? 
1720     IF seen <= pivot THEN
1730       REM Insert the seen element between smaller area and pivot element 
1740       values[p] <- seen
1750       values[start] <- pivot
1760       REM Shift the border between lower and undicovered area, 
1770       REM update pivot position. 
1780       p <- p + 1
1790       start <- start + 1
1800     ELSE
1810       REM Insert the checked element between undiscovered and larger area 
1820       values[start] <- values[stop]
1830       values[stop] <- seen
1840       REM Shift the border between undiscovered and larger area 
1850       stop <- stop - 1
1860     END IF
1870   LOOP
1880   RETURN p
1890 END FUNCTION
1900 REM  
1910 REM Checks whether or not the passed-in array is (ascendingly) sorted. 
1920 REM TODO: Add type-specific suffixes where necessary! 
1930 FUNCTION testSorted(numbers) AS bool
1940   REM TODO: add the respective type suffixes to your variable names if required 
1950   REM  
1960   REM  
1970   isSorted <- true
1980   i <- 0
1990   REM As we compare with the following element, we must stop at the penultimate index 
2000   DO WHILE isSorted and (i <= length(numbers)-2)
2010     REM Is there an inversion? 
2020     IF numbers[i] > numbers[i+1] THEN
2030       isSorted <- false
2040     ELSE
2050       i <- i + 1
2060     END IF
2070   LOOP
2080   RETURN isSorted
2090 END FUNCTION
2100 REM  
2110 REM Runs through the array heap and converts it to a max-heap 
2120 REM in a bottom-up manner, i.e. starts above the "leaf" level 
2130 REM (index >= length(heap) div 2) and goes then up towards 
2140 REM the root. 
2150 REM TODO: Add type-specific suffixes where necessary! 
2160 SUB buildMaxHeap(heap)
2170   REM TODO: add the respective type suffixes to your variable names if required 
2180   REM  
2190   REM  
2200   lgth <- length(heap)
2210   FOR k = lgth div 2 - 1 TO 0 STEP -1
2220     CALL maxHeapify(heap, k, lgth)
2230   NEXT k
2240 END SUB
2250 REM  
2260 REM Recursively sorts a subrange of the given array 'values´.  
2270 REM start is the first index of the subsequence to be sorted, 
2280 REM stop is the index BEHIND the subsequence to be sorted. 
2290 REM TODO: Add type-specific suffixes where necessary! 
2300 SUB quickSort(values, start, stop)
2310   REM TODO: add the respective type suffixes to your variable names if required 
2320   REM  
2330   REM  
2340   REM At least 2 elements? (Less don't make sense.) 
2350   IF stop >= start + 2 THEN
2360     REM Select a pivot element, be p its index. 
2370     REM (here: randomly chosen element out of start ... stop-1) 
2380     p <- random(stop-start) + start
2390     REM Partition the array into smaller and greater elements 
2400     REM Get the resulting (and final) position of the pivot element 
2410     p <- partition(values, start, stop, p)
2420     REM Sort subsequances separately and independently ... 
2430 
2440     REM ========================================================== 
2450     REM ================= START PARALLEL SECTION ================= 
2460     REM ========================================================== 
2470     REM TODO: add the necessary code to run the threads concurrently 
2480 
2490       REM ----------------- START THREAD 0 ----------------- 
2500         REM Sort left (lower) array part 
2510         CALL quickSort(values, start, p)
2520       REM ------------------ END THREAD 0 ------------------ 
2530 
2540 
2550       REM ----------------- START THREAD 1 ----------------- 
2560         REM Sort right (higher) array part 
2570         CALL quickSort(values, p+1, stop)
2580       REM ------------------ END THREAD 1 ------------------ 
2590 
2600     REM ========================================================== 
2610     REM ================== END PARALLEL SECTION ================== 
2620     REM ========================================================== 
2630 
2640   END IF
2650 END SUB
2660 REM  
2670 REM Sorts the array 'values´ of numbers according to he heap sort 
2680 REM algorithm 
2690 REM TODO: Add type-specific suffixes where necessary! 
2700 SUB heapSort(values)
2710   REM TODO: add the respective type suffixes to your variable names if required 
2720   REM  
2730   REM  
2740   CALL buildMaxHeap(values)
2750   heapRange <- length(values)
2760   FOR k = heapRange - 1 TO 1 STEP -1
2770     heapRange <- heapRange - 1
2780     REM Swap the maximum value (root of the heap) to the heap end 
2790     maximum <- values[0]
2800     values[0] <- values[heapRange]
2810     values[heapRange] <- maximum
2820     CALL maxHeapify(values, 0, heapRange)
2830   NEXT k
2840 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

