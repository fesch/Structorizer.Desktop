10 REM Concept and lisp implementation published by Joseph Weizenbaum (MIT): 
20 REM "ELIZA - A Computer Program For the Study of Natural Language Communication Between Man and Machine" - In: 
30 REM Computational Linguistis 1(1966)9, pp. 36-45 
40 REM Revision history: 
50 REM 2016-10-06 Initial version 
60 REM 2017-03-29 Two diagrams updated (comments translated to English) 
70 REM 2017-03-29 More keywords and replies added 
80 REM 2019-03-14 Replies and mapping reorganised for easier maintenance 
90 REM 2019-03-15 key map joined from keyword array and index map 
100 REM 2019-03-28 Keyword "bot" inserted (same reply ring as "computer") 
110 REM 2019-11-28 New global type "History" (to ensure a homogenous array) 
120 REM 2022-01-11 Measures against substition inversions a -> b -> a in conjugateStrings, reflexions revised. 
130 REM Generated by Structorizer 3.32-31 
140 
150 REM Copyright (C) 2018-05-14 Kay Gürtzig 
160 REM License: GPLv3-link 
170 REM GNU General Public License (V 3) 
180 REM https://www.gnu.org/licenses/gpl.html 
190 REM http://www.gnu.de/documents/gpl.de.html 
200 
210 REM  
220 REM program ELIZA
230 REM TODO: add the respective type suffixes to your variable names if required 
240 
250 REM histArray contains the most recent user replies as ring buffer; 
260 REM histIndex is the index where the next reply is to be stored (= index of the oldest 
270 REM cached user reply). 
280 REM Note: The depth of the history is to be specified by initializing a variable of this type, 
290 REM e.g. for a history of depth 5: 
300 REM myhistory <- History{{"", "", "", "", ""}, 0} 
310 REM Associates a key word in the text with an index in the reply ring array 
320 
330 DIM replies(,) AS String
340 DIM reflexions(,1) AS String
350 DIM byePhrases(,1) AS String
360 DIM keyMap() AS KeyMapEntry
370 TYPE History
380   Dim histArray() AS String
390   histIndex AS Integer
400 END TYPE
410 TYPE KeyMapEntry
420   keyword AS String
430   index AS Integer
440 END TYPE
450 DIM offsets() AS Integer
460 DIM history AS History
470 DIM findInfo(1) AS integer
480 DIM entry AS KeyMapEntry
490 REM  
500 REM Title information 
510 PRINT "************* ELIZA **************"
520 PRINT "* Original design by J. Weizenbaum"
530 PRINT "**********************************"
540 PRINT "* Adapted for Basic on IBM PC by"
550 PRINT "* - Patricia Danielson"
560 PRINT "* - Paul Hashfield"
570 PRINT "**********************************"
580 PRINT "* Adapted for Structorizer by"
590 PRINT "* - Kay Gürtzig / FH Erfurt 2016"
600 PRINT "* Version: 2.4 (2022-01-11)"
610 PRINT "* (Requires at least Structorizer 3.30-03 to run)"
620 PRINT "**********************************"
630 REM Stores the last five inputs of the user in a ring buffer, 
640 REM the second component is the rolling (over-)write index. 
650 history <- History{{"", "", "", "", ""}, 0}
660 CONST replies <- setupReplies()
670 CONST reflexions <- setupReflexions()
680 CONST byePhrases <- setupGoodByePhrases()
690 CONST keyMap <- setupKeywords()
700 offsets[length(keyMap)-1] <- 0
710 isGone <- false
720 REM Starter 
730 PRINT "Hi! I\'m your new therapist. My name is Eliza. What\'s your problem?"
740 DO
750   INPUT userInput
760   REM Converts the input to lowercase, cuts out interpunctation 
770   REM and pads the string 
780   userInput <- normalizeInput(userInput)
790   isGone <- checkGoodBye(userInput, byePhrases)
800   IF not isGone THEN
810     reply <- "Please don\'t repeat yourself!"
820     isRepeated <- checkRepetition(history, userInput)
830     IF not isRepeated THEN
840       findInfo <- findKeyword(keyMap, userInput)
850       keyIndex <- findInfo[0]
860       IF keyIndex < 0 THEN
870         REM Should never happen... 
880         keyIndex <- length(keyMap)-1
890       END IF
900       var entry: KeyMapEntry <- keyMap[keyIndex]
910       REM Variable part of the reply 
920       varPart <- ""
930       IF length(entry.keyword) > 0 THEN
940         varPart <- conjugateStrings(userInput, entry.keyword, findInfo[1], reflexions)
950       END IF
960       replyRing <- replies[entry.index]
970       reply <- replyRing[offsets[keyIndex]]
980       offsets[keyIndex] <- (offsets[keyIndex] + 1) mod length(replyRing)
990       posAster <- pos("*", reply)
1000       IF posAster > 0 THEN
1010         IF varPart = " " THEN
1020           reply <- "You will have to elaborate more for me to help you."
1030         ELSE
1040           delete(reply, posAster, 1)
1050           insert(varPart, reply, posAster)
1060         END IF
1070       END IF
1080       reply <- adjustSpelling(reply)
1090     END IF
1100     PRINT reply
1110   END IF
1120 LOOP UNTIL isGone
1130 END
1140 REM  
1150 REM Cares for correct letter case among others 
1160 REM TODO: Add type-specific suffixes where necessary! 
1170 FUNCTION adjustSpelling(sentence AS String) AS String
1180   REM TODO: add the respective type suffixes to your variable names if required 
1190   REM  
1200   REM  
1210   result <- sentence
1220   position <- 1
1230   DO WHILE (position <= length(sentence)) and (copy(sentence, position, 1) = " ")
1240     position <- position + 1
1250   LOOP
1260   IF position <= length(sentence) THEN
1270     start <- copy(sentence, 1, position)
1280     delete(result, 1, position)
1290     insert(uppercase(start), result, 1)
1300   END IF
1310   FOR EACH word IN {" i ", " i\'"}
1320     position <- pos(word, result)
1330     DO WHILE position > 0
1340       delete(result, position+1, 1)
1350       insert("I", result, position+1)
1360       position <- pos(word, result)
1370     LOOP
1380   NEXT word
1390   RETURN result
1400 END FUNCTION
1410 REM  
1420 REM Checks whether the given text contains some kind of 
1430 REM good-bye phrase inducing the end of the conversation 
1440 REM and if so writes a correspding good-bye message and 
1450 REM returns true, otherwise false 
1460 REM TODO: Add type-specific suffixes where necessary! 
1470 FUNCTION checkGoodBye(text AS String, phrases AS String(50,0 TO 1)) AS boolean
1480   REM TODO: add the respective type suffixes to your variable names if required 
1490   REM  
1500   REM  
1510   FOR EACH pair IN phrases
1520     IF pos(pair[0], text) > 0 THEN
1530       PRINT pair[1]
1540       RETURN true
1550     END IF
1560   NEXT pair
1570   RETURN false
1580 END FUNCTION
1590 REM  
1600 REM Checks whether newInput has occurred among the recently cached 
1610 REM input strings in the histArray component of history and updates the history. 
1620 REM TODO: Add type-specific suffixes where necessary! 
1630 FUNCTION checkRepetition(history AS History, newInput AS String) AS boolean
1640   REM TODO: add the respective type suffixes to your variable names if required 
1650   REM  
1660   TYPE History
1670     Dim histArray() AS String
1680     histIndex AS Integer
1690   END TYPE
1700   REM  
1710   hasOccurred <- false
1720   IF length(newInput) > 4 THEN
1730     histDepth <- length(history.histArray)
1740     FOR i = 0 TO histDepth-1
1750       IF newInput = history.histArray[i] THEN
1760         hasOccurred <- true
1770       END IF
1780     NEXT i
1790     history.histArray[history.histIndex] <- newInput
1800     history.histIndex <- (history.histIndex + 1) mod (histDepth)
1810   END IF
1820   RETURN hasOccurred
1830 END FUNCTION
1840 REM  
1850 REM TODO: Add type-specific suffixes where necessary! 
1860 FUNCTION conjugateStrings(sentence AS String, key AS String, keyPos AS integer, flexions AS String(50,0 TO 1)) AS String
1870   REM TODO: add the respective type suffixes to your variable names if required 
1880   REM  
1890   REM  
1900   result <- " " + copy(sentence, keyPos + length(key), length(sentence)) + " "
1910   FOR EACH pair IN flexions
1920     left <- ""
1930     right <- result
1940     pos0 <- pos(pair[0], right)
1950     pos1 <- pos(pair[1], right)
1960     DO WHILE pos0 > 0 or pos1 > 0
1970       REM Detect which of the two words of the pair matches first (lest a substitution should be reverted) 
1980       which <- 0
1990       position <- pos0
2000       IF (pos0 = 0) or ((pos1 > 0) and (pos1 < pos0)) THEN
2010         which <- 1
2020         position <- pos1
2030       END IF
2040       left <- left + copy(right, 1, position-1) + pair[1 - which]
2050       right <- copy(right, position + length(pair[which]), length(right))
2060       pos0 <- pos(pair[0], right)
2070       pos1 <- pos(pair[1], right)
2080     LOOP
2090     result <- left + right
2100   NEXT pair
2110   REM Eliminate multiple spaces (replaced by single ones) and vertical bars 
2120   FOR EACH str IN {"  ", "|"}
2130     position <- pos(str, result)
2140     DO WHILE position > 0
2150       result <- copy(result, 1, position-1) + copy(result, position+1, length(result))
2160       position <- pos(str, result)
2170     LOOP
2180   NEXT str
2190   RETURN result
2200 END FUNCTION
2210 REM  
2220 REM Looks for the occurrence of the first of the strings 
2230 REM contained in keywords within the given sentence (in 
2240 REM array order). 
2250 REM Returns an array of 
2260 REM 0: the index of the first identified keyword (if any, otherwise -1), 
2270 REM 1: the position inside sentence (0 if not found) 
2280 REM TODO: Add type-specific suffixes where necessary! 
2290 FUNCTION findKeyword(CONST keyMap AS KeyMapEntry(50), sentence AS String) AS integer(0 TO 1)
2300   REM TODO: add the respective type suffixes to your variable names if required 
2310   REM  
2320   TYPE KeyMapEntry
2330     keyword AS String
2340     index AS Integer
2350   END TYPE
2360   DIM result(1) AS Integer
2370   DIM entry AS KeyMapEntry
2380   REM  
2390   REM Contains the index of the keyword and its position in sentence 
2400   result <- {-1, 0}
2410   i <- 0
2420   DO WHILE (result[0] < 0) and (i < length(keyMap))
2430     var entry: KeyMapEntry <- keyMap[i]
2440     position <- pos(entry.keyword, sentence)
2450     IF position > 0 THEN
2460       result[0] <- i
2470       result[1] <- position
2480     END IF
2490     i <- i+1
2500   LOOP
2510   RETURN result
2520 END FUNCTION
2530 REM  
2540 REM Converts the sentence to lowercase, eliminates all 
2550 REM interpunction (i.e. ',', '.', ';'), and pads the 
2560 REM sentence among blanks 
2570 REM TODO: Add type-specific suffixes where necessary! 
2580 FUNCTION normalizeInput(sentence AS String) AS String
2590   REM TODO: add the respective type suffixes to your variable names if required 
2600   REM  
2610   REM  
2620   sentence <- lowercase(sentence)
2630   FOR EACH symbol IN {'.', ',', ';', '!', '?'}
2640     position <- pos(symbol, sentence)
2650     DO WHILE position > 0
2660       sentence <- copy(sentence, 1, position-1) + copy(sentence, position+1, length(sentence))
2670       position <- pos(symbol, sentence)
2680     LOOP
2690   NEXT symbol
2700   result <- " " + sentence + " "
2710   RETURN result
2720 END FUNCTION
2730 REM  
2740 REM TODO: Add type-specific suffixes where necessary! 
2750 FUNCTION setupGoodByePhrases() AS String(50,0 TO 1)
2760   REM TODO: add the respective type suffixes to your variable names if required 
2770   REM  
2780   DIM phrases(,1) AS String
2790   REM  
2800   phrases[0] <- {" shut", "Okay. If you feel that way I\'ll shut up. ... Your choice."}
2810   phrases[1] <- {"bye", "Well, let\'s end our talk for now. See you later. Bye."}
2820   RETURN phrases
2830 END FUNCTION
2840 REM  
2850 REM The lower the index the higher the rank of the keyword (search is sequential). 
2860 REM The index of the first keyword found in a user sentence maps to a respective 
2870 REM reply ring as defined in `setupReplies()´. 
2880 REM TODO: Add type-specific suffixes where necessary! 
2890 FUNCTION setupKeywords() AS KeyMapEntry(50)
2900   REM TODO: add the respective type suffixes to your variable names if required 
2910   REM  
2920   TYPE KeyMapEntry
2930     keyword AS String
2940     index AS Integer
2950   END TYPE
2960   DIM keywords() AS KeyMapEntry
2970   REM  
2980   REM The empty key string (last entry) is the default clause - will always be found 
2990   keywords[39] <- KeyMapEntry{"", 29}
3000   keywords[0] <- KeyMapEntry{"can you ", 0}
3010   keywords[1] <- KeyMapEntry{"can i ", 1}
3020   keywords[2] <- KeyMapEntry{"you are ", 2}
3030   keywords[3] <- KeyMapEntry{"you\'re ", 2}
3040   keywords[4] <- KeyMapEntry{"i don't ", 3}
3050   keywords[5] <- KeyMapEntry{"i feel ", 4}
3060   keywords[6] <- KeyMapEntry{"why don\'t you ", 5}
3070   keywords[7] <- KeyMapEntry{"why can\'t i ", 6}
3080   keywords[8] <- KeyMapEntry{"are you ", 7}
3090   keywords[9] <- KeyMapEntry{"i can\'t ", 8}
3100   keywords[10] <- KeyMapEntry{"i am ", 9}
3110   keywords[11] <- KeyMapEntry{"i\'m ", 9}
3120   keywords[12] <- KeyMapEntry{"you ", 10}
3130   keywords[13] <- KeyMapEntry{"i want ", 11}
3140   keywords[14] <- KeyMapEntry{"what ", 12}
3150   keywords[15] <- KeyMapEntry{"how ", 12}
3160   keywords[16] <- KeyMapEntry{"who ", 12}
3170   keywords[17] <- KeyMapEntry{"where ", 12}
3180   keywords[18] <- KeyMapEntry{"when ", 12}
3190   keywords[19] <- KeyMapEntry{"why ", 12}
3200   keywords[20] <- KeyMapEntry{"name ", 13}
3210   keywords[21] <- KeyMapEntry{"cause ", 14}
3220   keywords[22] <- KeyMapEntry{"sorry ", 15}
3230   keywords[23] <- KeyMapEntry{"dream ", 16}
3240   keywords[24] <- KeyMapEntry{"hello ", 17}
3250   keywords[25] <- KeyMapEntry{"hi ", 17}
3260   keywords[26] <- KeyMapEntry{"maybe ", 18}
3270   keywords[27] <- KeyMapEntry{" no", 19}
3280   keywords[28] <- KeyMapEntry{"your ", 20}
3290   keywords[29] <- KeyMapEntry{"always ", 21}
3300   keywords[30] <- KeyMapEntry{"think ", 22}
3310   keywords[31] <- KeyMapEntry{"alike ", 23}
3320   keywords[32] <- KeyMapEntry{"yes ", 24}
3330   keywords[33] <- KeyMapEntry{"friend ", 25}
3340   keywords[34] <- KeyMapEntry{"computer", 26}
3350   keywords[35] <- KeyMapEntry{"bot ", 26}
3360   keywords[36] <- KeyMapEntry{"smartphone", 27}
3370   keywords[37] <- KeyMapEntry{"father ", 28}
3380   keywords[38] <- KeyMapEntry{"mother ", 28}
3390   RETURN keywords
3400 END FUNCTION
3410 REM  
3420 REM Returns an array of pairs of mutually substitutable words 
3430 REM The second word may contain a '|' in order to prevent an inverse 
3440 REM replacement. 
3450 REM TODO: Add type-specific suffixes where necessary! 
3460 FUNCTION setupReflexions() AS String(50,0 TO 1)
3470   REM TODO: add the respective type suffixes to your variable names if required 
3480   REM  
3490   DIM reflexions(,1) AS String
3500   REM  
3510   reflexions[0] <- {" are ", " am "}
3520   REM This is not always helpful (e.g. if it relates to things or third persons) 
3530   reflexions[1] <- {" were ", " was "}
3540   reflexions[2] <- {" you ", " i "}
3550   reflexions[3] <- {" yours ", " mine "}
3560   reflexions[4] <- {" yourself ", " myself "}
3570   reflexions[5] <- {" your ", " my "}
3580   reflexions[6] <- {" i\'ve ", " you\'ve "}
3590   reflexions[7] <- {" i\'m ", " you\'re "}
3600   REM We must not replace "you" by "me", not in particular after "I" had been replaced by "you". 
3610   reflexions[8] <- {" me ", " |you "}
3620   RETURN reflexions
3630 END FUNCTION
3640 REM  
3650 REM This routine sets up the reply rings addressed by the key words defined in 
3660 REM routine `setupKeywords()´ and mapped hitherto by the cross table defined 
3670 REM in `setupMapping()´ 
3680 REM TODO: Add type-specific suffixes where necessary! 
3690 FUNCTION setupReplies() AS String(50,50)
3700   REM TODO: add the respective type suffixes to your variable names if required 
3710   REM  
3720   DIM setupReplies(,) AS String
3730   DIM replies(,) AS String
3740   REM  
3750   REM We start with the highest index for performance reasons 
3760   REM (is to avoid frequent array resizing) 
3770   replies[29] <- { "Say, do you have any psychological problems?", "What does that suggest to you?", "I see.", "I'm not sure I understand you fully.", "Come come elucidate your thoughts.", "Can you elaborate on that?", "That is quite interesting."}
3780   replies[0] <- { "Don't you believe that I can*?", "Perhaps you would like to be like me?", "You want me to be able to*?"}
3790   replies[1] <- { "Perhaps you don't want to*?", "Do you want to be able to*?"}
3800   replies[2] <- { "What makes you think I am*?", "Does it please you to believe I am*?", "Perhaps you would like to be*?", "Do you sometimes wish you were*?"}
3810   replies[3] <- { "Don't you really*?", "Why don't you*?", "Do you wish to be able to*?", "Does that trouble you*?"}
3820   replies[4] <- { "Do you often feel*?", "Are you afraid of feeling*?", "Do you enjoy feeling*?"}
3830   replies[5] <- { "Do you really believe I don't*?", "Perhaps in good time I will*.", "Do you want me to*?"}
3840   replies[6] <- { "Do you think you should be able to*?", "Why can't you*?"}
3850   replies[7] <- { "Why are you interested in whether or not I am*?", "Would you prefer if I were not*?", "Perhaps in your fantasies I am*?"}
3860   replies[8] <- { "How do you know you can't*?", "Have you tried?","Perhaps you can now*."}
3870   replies[9] <- { "Did you come to me because you are*?", "How long have you been*?", "Do you believe it is normal to be*?", "Do you enjoy being*?"}
3880   replies[10] <- { "We were discussing you--not me.", "Oh, I*.", "You're not really talking about me, are you?"}
3890   replies[11] <- { "What would it mean to you if you got*?", "Why do you want*?", "Suppose you soon got*...", "What if you never got*?", "I sometimes also want*."}
3900   replies[12] <- { "Why do you ask?", "Does that question interest you?", "What answer would please you the most?", "What do you think?", "Are such questions on your mind often?", "What is it that you really want to know?", "Have you asked anyone else?", "Have you asked such questions before?", "What else comes to mind when you ask that?"}
3910   replies[13] <- { "Names don't interest me.", "I don't care about names -- please go on."}
3920   replies[14] <- { "Is that the real reason?", "Don't any other reasons come to mind?", "Does that reason explain anything else?", "What other reasons might there be?"}
3930   replies[15] <- { "Please don't apologize!", "Apologies are not necessary.", "What feelings do you have when you apologize?", "Don't be so defensive!"}
3940   replies[16] <- { "What does that dream suggest to you?", "Do you dream often?", "What persons appear in your dreams?", "Are you disturbed by your dreams?"}
3950   replies[17] <- { "How do you do ...please state your problem."}
3960   replies[18] <- { "You don't seem quite certain.", "Why the uncertain tone?", "Can't you be more positive?", "You aren't sure?", "Don't you know?"}
3970   replies[19] <- { "Are you saying no just to be negative?", "You are being a bit negative.", "Why not?", "Are you sure?", "Why no?"}
3980   replies[20] <- { "Why are you concerned about my*?", "What about your own*?"}
3990   replies[21] <- { "Can you think of a specific example?", "When?", "What are you thinking of?", "Really, always?"}
4000   replies[22] <- { "Do you really think so?", "But you are not sure you*?", "Do you doubt you*?"}
4010   replies[23] <- { "In what way?", "What resemblance do you see?", "What does the similarity suggest to you?", "What other connections do you see?", "Could there really be some connection?", "How?", "You seem quite positive."}
4020   replies[24] <- { "Are you sure?", "I see.", "I understand."}
4030   replies[25] <- { "Why do you bring up the topic of friends?", "Do your friends worry you?", "Do your friends pick on you?", "Are you sure you have any friends?", "Do you impose on your friends?", "Perhaps your love for friends worries you."}
4040   replies[26] <- { "Do computers worry you?", "Are you talking about me in particular?", "Are you frightened by machines?", "Why do you mention computers?", "What do you think machines have to do with your problem?", "Don't you think computers can help people?", "What is it about machines that worries you?"}
4050   replies[27] <- { "Do you sometimes feel uneasy without a smartphone?", "Have you had these phantasies before?", "Does the world seem more real for you via apps?"}
4060   replies[28] <- { "Tell me more about your family.", "Who else in your family*?", "What does family relations mean for you?", "Come on, How old are you?"}
4070   setupReplies <- replies
4080   RETURN setupReplies
4090 END FUNCTION

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

