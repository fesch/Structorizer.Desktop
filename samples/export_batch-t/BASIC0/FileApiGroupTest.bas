10 REM Tries to read as many integer values as possible upto maxNumbers 
20 REM from file fileName into the given array numbers. 
30 REM Returns the number of the actually read numbers. May cause an exception. 
40 REM Generated by Structorizer 3.32-32 
50 
60 REM Copyright (C) 2020-03-21 Kay Gürtzig 
70 REM License: GPLv3-link 
80 REM GNU General Public License (V 3) 
90 REM https://www.gnu.org/licenses/gpl.html 
100 REM http://www.gnu.de/documents/gpl.de.html 
110 
120 REM  
130 REM TODO: Add type-specific suffixes where necessary! 
140 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
150   REM TODO: add the respective type suffixes to your variable names if required 
160   REM  
170   nNumbers <- 0
180   fileNo <- fileOpen(fileName)
190   IF fileNo <= 0 THEN
200     REM FIXME: Only a number is allowed as parameter: 
210     ERROR "File could not be opened!"
220   END IF
230   ON ERROR GOTO 310
240   DO WHILE not fileEOF(fileNo) and nNumbers < maxNumbers
250     number <- fileReadInt(fileNo)
260     numbers[nNumbers] <- number
270     nNumbers <- nNumbers + 1
280   LOOP
290   GOTO 340
300   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
310     REM FIXME: Only a number is allowed as parameter: 
320     ERROR 
330   REM End of error handler, resume here ... 
340   ON ERROR GOTO 0
350   fileClose(fileNo)
360   RETURN nNumbers
370 END FUNCTION
380 REM  
390 REM Draws a bar chart from the array "values" of size nValues. 
400 REM Turtleizer must be activated and will scale the chart into a square of 
410 REM 500 x 500 pixels 
420 REM Note: The function is not robust against empty array or totally equal values. 
430 REM TODO: Add type-specific suffixes where necessary! 
440 SUB drawBarChart(values AS double(50), nValues)
450   REM TODO: add the respective type suffixes to your variable names if required 
460   REM  
470   REM  
480   REM Used range of the Turtleizer screen 
490   CONST xSize <- 500
500   CONST ySize <- 500
510   kMin <- 0
520   kMax <- 0
530   FOR k = 1 TO nValues-1
540     IF values[k] > values[kMax] THEN
550       kMax <- k
560     ELSE
570       IF values[k] < values[kMin] THEN
580         kMin <- k
590       END IF
600     END IF
610   NEXT k
620   valMin <- values[kMin]
630   valMax <- values[kMax]
640   yScale <- valMax * 1.0 / (ySize - 1)
650   yAxis <- ySize - 1
660   IF valMin < 0 THEN
670     IF valMax > 0 THEN
680       yAxis <- valMax * ySize * 1.0 / (valMax - valMin)
690       yScale <- (valMax - valMin) * 1.0 / (ySize - 1)
700     ELSE
710       yAxis <- 1
720       yScale <- valMin * 1.0 / (ySize - 1)
730     END IF
740   END IF
750   REM draw coordinate axes 
760   gotoXY(1, ySize - 1)
770   forward(ySize -1) : REM color = ffffff
780   penUp()
790   backward(yAxis) : REM color = ffffff
800   right(90)
810   penDown()
820   forward(xSize -1) : REM color = ffffff
830   penUp()
840   backward(xSize-1) : REM color = ffffff
850   stripeWidth <- xSize / nValues
860   FOR k = 0 TO nValues-1
870     stripeHeight <- values[k] * 1.0 / yScale
880     SELECT CASE k mod 3
890       CASE 0
900         setPenColor(255,0,0)
910       CASE 1
920         setPenColor(0, 255,0)
930       CASE 2
940         setPenColor(0, 0, 255)
950     END SELECT
960     fd(1) : REM color = ffffff
970     left(90)
980     penDown()
990     fd(stripeHeight) : REM color = ffffff
1000     right(90)
1010     fd(stripeWidth - 1) : REM color = ffffff
1020     right(90)
1030     forward(stripeHeight) : REM color = ffffff
1040     left(90)
1050     penUp()
1060   NEXT k
1070 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1080 REM ======= 8< =========================================================== 
1090 
1100 REM Computes the sum and average of the numbers read from a user-specified 
1110 REM text file (which might have been created via generateRandomNumberFile(4)). 
1120 REM  
1130 REM This program is part of an arrangement used to test group code export (issue 
1140 REM #828) with FileAPI dependency. 
1150 REM The input check loop has been disabled (replaced by a simple unchecked input 
1160 REM instruction) in order to test the effect of indirect FileAPI dependency (only the 
1170 REM called subroutine directly requires FileAPI now). 
1180 REM Generated by Structorizer 3.32-32 
1190 
1200 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1210 REM License: GPLv3-link 
1220 REM GNU General Public License (V 3) 
1230 REM https://www.gnu.org/licenses/gpl.html 
1240 REM http://www.gnu.de/documents/gpl.de.html 
1250 
1260 REM  
1270 REM program ComputeSum
1280 REM TODO: add the respective type suffixes to your variable names if required 
1290 REM  
1300 fileNo <- 1000
1310 REM Disable this if you enable the loop below! 
1320 PRINT "Name/path of the number file"; : INPUT file_name
1330 REM If you enable this loop, then the preceding input instruction is to be disabled 
1340 REM and the fileClose instruction in the alternative below is to be enabled. 
1350 REM DO 
1360 REM   PRINT "Name/path of the number file"; : INPUT file_name 
1370 REM   fileNo <- fileOpen(file_name) 
1380 REM LOOP UNTIL fileNo > 0 or file_name = "" 
1390 IF fileNo > 0 THEN
1400   REM This should be enabled if the input check loop above gets enabled. 
1410 REM   fileClose(fileNo) 
1420   values <- {}
1430   nValues <- 0
1440   ON ERROR GOTO 1480
1450   nValues <- readNumbers(file_name, values, 1000)
1460   GOTO 1520
1470   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1480     PRINT failure
1490     REM FIXME: The following exit code was intended to pass: -7 
1500     STOP
1510   REM End of error handler, resume here ... 
1520   ON ERROR GOTO 0
1530   sum <- 0.0
1540   FOR k = 0 TO nValues-1
1550     sum <- sum + values[k]
1560   NEXT k
1570   PRINT "sum = "; sum
1580   PRINT "average = "; sum / nValues
1590 END IF
1600 END

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1610 REM ======= 8< =========================================================== 
1620 
1630 REM Reads a random number file and draws a histogram accotrding to the 
1640 REM user specifications 
1650 REM Generated by Structorizer 3.32-32 
1660 
1670 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1680 REM License: GPLv3-link 
1690 REM GNU General Public License (V 3) 
1700 REM https://www.gnu.org/licenses/gpl.html 
1710 REM http://www.gnu.de/documents/gpl.de.html 
1720 
1730 REM  
1740 REM program DrawRandomHistogram
1750 REM TODO: add the respective type suffixes to your variable names if required 
1760 REM  
1770 fileNo <- -10
1780 DO
1790   PRINT "Name/path of the number file"; : INPUT file_name
1800   fileNo <- fileOpen(file_name)
1810 LOOP UNTIL fileNo > 0 or file_name = ""
1820 IF fileNo > 0 THEN
1830   fileClose(fileNo)
1840   PRINT "number of intervals"; : INPUT nIntervals
1850   REM Initialize the interval counters 
1860   FOR k = 0 TO nIntervals-1
1870     count[k] <- 0
1880   NEXT k
1890   REM Index of the most populated interval 
1900   kMaxCount <- 0
1910   numberArray <- {}
1920   nObtained <- 0
1930   ON ERROR GOTO 1970
1940   nObtained <- readNumbers(file_name, numberArray, 10000)
1950   GOTO 1990
1960   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1970     PRINT failure
1980   REM End of error handler, resume here ... 
1990   ON ERROR GOTO 0
2000   IF nObtained > 0 THEN
2010     min <- numberArray[0]
2020     max <- numberArray[0]
2030     FOR i = 1 TO nObtained-1
2040       IF numberArray[i] < min THEN
2050         min <- numberArray[i]
2060       ELSE
2070         IF numberArray[i] > max THEN
2080           max <- numberArray[i]
2090         END IF
2100       END IF
2110     NEXT i
2120     REM Interval width 
2130     width <- (max - min) * 1.0 / nIntervals
2140     FOR i = 0 TO nObtained - 1
2150       value <- numberArray[i]
2160       k <- 1
2170       DO WHILE k < nIntervals and value > min + k * width
2180         k <- k + 1
2190       LOOP
2200       count[k-1] <- count[k-1] + 1
2210       IF count[k-1] > count[kMaxCount] THEN
2220         kMaxCount <- k-1
2230       END IF
2240     NEXT i
2250     CALL drawBarChart(count, nIntervals)
2260     PRINT "Interval with max count: "; kMaxCount; " ("; count[kMaxCount]; ")"
2270     FOR k = 0 TO nIntervals-1
2280       PRINT count[k]; " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
2290     NEXT k
2300   ELSE
2310     PRINT "No numbers read."
2320   END IF
2330 END IF
2340 END
2350 REM  
2360 REM Draws a bar chart from the array "values" of size nValues. 
2370 REM Turtleizer must be activated and will scale the chart into a square of 
2380 REM 500 x 500 pixels 
2390 REM Note: The function is not robust against empty array or totally equal values. 
2400 REM TODO: Add type-specific suffixes where necessary! 
2410 SUB drawBarChart(values AS double(50), nValues)
2420   REM TODO: add the respective type suffixes to your variable names if required 
2430   REM  
2440   REM  
2450   REM Used range of the Turtleizer screen 
2460   CONST xSize <- 500
2470   CONST ySize <- 500
2480   kMin <- 0
2490   kMax <- 0
2500   FOR k = 1 TO nValues-1
2510     IF values[k] > values[kMax] THEN
2520       kMax <- k
2530     ELSE
2540       IF values[k] < values[kMin] THEN
2550         kMin <- k
2560       END IF
2570     END IF
2580   NEXT k
2590   valMin <- values[kMin]
2600   valMax <- values[kMax]
2610   yScale <- valMax * 1.0 / (ySize - 1)
2620   yAxis <- ySize - 1
2630   IF valMin < 0 THEN
2640     IF valMax > 0 THEN
2650       yAxis <- valMax * ySize * 1.0 / (valMax - valMin)
2660       yScale <- (valMax - valMin) * 1.0 / (ySize - 1)
2670     ELSE
2680       yAxis <- 1
2690       yScale <- valMin * 1.0 / (ySize - 1)
2700     END IF
2710   END IF
2720   REM draw coordinate axes 
2730   gotoXY(1, ySize - 1)
2740   forward(ySize -1) : REM color = ffffff
2750   penUp()
2760   backward(yAxis) : REM color = ffffff
2770   right(90)
2780   penDown()
2790   forward(xSize -1) : REM color = ffffff
2800   penUp()
2810   backward(xSize-1) : REM color = ffffff
2820   stripeWidth <- xSize / nValues
2830   FOR k = 0 TO nValues-1
2840     stripeHeight <- values[k] * 1.0 / yScale
2850     SELECT CASE k mod 3
2860       CASE 0
2870         setPenColor(255,0,0)
2880       CASE 1
2890         setPenColor(0, 255,0)
2900       CASE 2
2910         setPenColor(0, 0, 255)
2920     END SELECT
2930     fd(1) : REM color = ffffff
2940     left(90)
2950     penDown()
2960     fd(stripeHeight) : REM color = ffffff
2970     right(90)
2980     fd(stripeWidth - 1) : REM color = ffffff
2990     right(90)
3000     forward(stripeHeight) : REM color = ffffff
3010     left(90)
3020     penUp()
3030   NEXT k
3040 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

