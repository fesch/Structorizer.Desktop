10 REM Concept and lisp implementation published by Joseph Weizenbaum (MIT): 
20 REM "ELIZA - A Computer Program For the Study of Natural Language Communication Between Man and Machine" - In: 
30 REM Computational Linguistis 1(1966)9, pp. 36-45 
40 REM Revision history: 
50 REM 2016-10-06 Initial version 
60 REM 2017-03-29 Two diagrams updated (comments translated to English) 
70 REM 2017-03-29 More keywords and replies added 
80 REM 2019-03-14 Replies and mapping reorganised for easier maintenance 
90 REM 2019-03-15 key map joined from keyword array and index map 
100 REM 2019-03-28 Keyword "bot" inserted (same reply ring as "computer") 
110 REM 2019-11-28 New global type "History" (to ensure a homogenous array) 
120 REM Generated by Structorizer 3.32-31 
130 
140 REM Copyright (C) 2018-05-14 Kay Gürtzig 
150 REM License: GPLv3-link 
160 REM GNU General Public License (V 3) 
170 REM https://www.gnu.org/licenses/gpl.html 
180 REM http://www.gnu.de/documents/gpl.de.html 
190 
200 REM  
210 REM program ELIZA
220 REM TODO: add the respective type suffixes to your variable names if required 
230 
240 REM histArray contains the most recent user replies as ring buffer; 
250 REM histIndex is the index where the next reply is to be stored (= index of the oldest 
260 REM cached user reply). 
270 REM Note: The depth of the history is to be specified by initializing a variable of this type, 
280 REM e.g. for a history of depth 5: 
290 REM myhistory <- History{{"", "", "", "", ""}, 0} 
300 REM Associates a key word in the text with an index in the reply ring array 
310 
320 DIM replies(,) AS String
330 DIM reflexions(,1) AS String
340 DIM byePhrases(,1) AS String
350 DIM keyMap() AS KeyMapEntry
360 TYPE History
370   Dim histArray() AS String
380   histIndex AS Integer
390 END TYPE
400 TYPE KeyMapEntry
410   keyword AS String
420   index AS Integer
430 END TYPE
440 DIM offsets() AS Integer
450 DIM history AS History
460 DIM findInfo(1) AS integer
470 DIM entry AS KeyMapEntry
480 REM  
490 REM Title information 
500 PRINT "************* ELIZA **************"
510 PRINT "* Original design by J. Weizenbaum"
520 PRINT "**********************************"
530 PRINT "* Adapted for Basic on IBM PC by"
540 PRINT "* - Patricia Danielson"
550 PRINT "* - Paul Hashfield"
560 PRINT "**********************************"
570 PRINT "* Adapted for Structorizer by"
580 PRINT "* - Kay Gürtzig / FH Erfurt 2016"
590 PRINT "* Version: 2.3 (2020-02-24)"
600 PRINT "* (Requires at least Structorizer 3.30-03 to run)"
610 PRINT "**********************************"
620 REM Stores the last five inputs of the user in a ring buffer, 
630 REM the second component is the rolling (over-)write index. 
640 history <- History{{"", "", "", "", ""}, 0}
650 CONST replies <- setupReplies()
660 CONST reflexions <- setupReflexions()
670 CONST byePhrases <- setupGoodByePhrases()
680 CONST keyMap <- setupKeywords()
690 offsets[length(keyMap)-1] <- 0
700 isGone <- false
710 REM Starter 
720 PRINT "Hi! I\'m your new therapist. My name is Eliza. What\'s your problem?"
730 DO
740   INPUT userInput
750   REM Converts the input to lowercase, cuts out interpunctation 
760   REM and pads the string 
770   userInput <- normalizeInput(userInput)
780   isGone <- checkGoodBye(userInput, byePhrases)
790   IF not isGone THEN
800     reply <- "Please don\'t repeat yourself!"
810     isRepeated <- checkRepetition(history, userInput)
820     IF not isRepeated THEN
830       findInfo <- findKeyword(keyMap, userInput)
840       keyIndex <- findInfo[0]
850       IF keyIndex < 0 THEN
860         REM Should never happen... 
870         keyIndex <- length(keyMap)-1
880       END IF
890       var entry: KeyMapEntry <- keyMap[keyIndex]
900       REM Variable part of the reply 
910       varPart <- ""
920       IF length(entry.keyword) > 0 THEN
930         varPart <- conjugateStrings(userInput, entry.keyword, findInfo[1], reflexions)
940       END IF
950       replyRing <- replies[entry.index]
960       reply <- replyRing[offsets[keyIndex]]
970       offsets[keyIndex] <- (offsets[keyIndex] + 1) mod length(replyRing)
980       posAster <- pos("*", reply)
990       IF posAster > 0 THEN
1000         IF varPart = " " THEN
1010           reply <- "You will have to elaborate more for me to help you."
1020         ELSE
1030           delete(reply, posAster, 1)
1040           insert(varPart, reply, posAster)
1050         END IF
1060       END IF
1070       reply <- adjustSpelling(reply)
1080     END IF
1090     PRINT reply
1100   END IF
1110 LOOP UNTIL isGone
1120 END
1130 REM  
1140 REM Cares for correct letter case among others 
1150 REM TODO: Add type-specific suffixes where necessary! 
1160 FUNCTION adjustSpelling(sentence AS String) AS String
1170   REM TODO: add the respective type suffixes to your variable names if required 
1180   REM  
1190   REM  
1200   result <- sentence
1210   position <- 1
1220   DO WHILE (position <= length(sentence)) and (copy(sentence, position, 1) = " ")
1230     position <- position + 1
1240   LOOP
1250   IF position <= length(sentence) THEN
1260     start <- copy(sentence, 1, position)
1270     delete(result, 1, position)
1280     insert(uppercase(start), result, 1)
1290   END IF
1300   FOR EACH word IN {" i ", " i\'"}
1310     position <- pos(word, result)
1320     DO WHILE position > 0
1330       delete(result, position+1, 1)
1340       insert("I", result, position+1)
1350       position <- pos(word, result)
1360     LOOP
1370   NEXT word
1380   RETURN result
1390 END FUNCTION
1400 REM  
1410 REM Checks whether the given text contains some kind of 
1420 REM good-bye phrase inducing the end of the conversation 
1430 REM and if so writes a correspding good-bye message and 
1440 REM returns true, otherwise false 
1450 REM TODO: Add type-specific suffixes where necessary! 
1460 FUNCTION checkGoodBye(text AS String, phrases AS String(50,0 TO 1)) AS boolean
1470   REM TODO: add the respective type suffixes to your variable names if required 
1480   REM  
1490   REM  
1500   FOR EACH pair IN phrases
1510     IF pos(pair[0], text) > 0 THEN
1520       PRINT pair[1]
1530       RETURN true
1540     END IF
1550   NEXT pair
1560   RETURN false
1570 END FUNCTION
1580 REM  
1590 REM Checks whether newInput has occurred among the recently cached 
1600 REM input strings in the histArray component of history and updates the history. 
1610 REM TODO: Add type-specific suffixes where necessary! 
1620 FUNCTION checkRepetition(history AS History, newInput AS String) AS boolean
1630   REM TODO: add the respective type suffixes to your variable names if required 
1640   REM  
1650   TYPE History
1660     Dim histArray() AS String
1670     histIndex AS Integer
1680   END TYPE
1690   REM  
1700   hasOccurred <- false
1710   IF length(newInput) > 4 THEN
1720     histDepth <- length(history.histArray)
1730     FOR i = 0 TO histDepth-1
1740       IF newInput = history.histArray[i] THEN
1750         hasOccurred <- true
1760       END IF
1770     NEXT i
1780     history.histArray[history.histIndex] <- newInput
1790     history.histIndex <- (history.histIndex + 1) mod (histDepth)
1800   END IF
1810   RETURN hasOccurred
1820 END FUNCTION
1830 REM  
1840 REM TODO: Add type-specific suffixes where necessary! 
1850 FUNCTION conjugateStrings(sentence AS String, key AS String, keyPos AS integer, flexions AS String(50,0 TO 1)) AS String
1860   REM TODO: add the respective type suffixes to your variable names if required 
1870   REM  
1880   REM  
1890   result <- " " + copy(sentence, keyPos + length(key), length(sentence)) + " "
1900   FOR EACH pair IN flexions
1910     left <- ""
1920     right <- result
1930     position <- pos(pair[0], right)
1940     DO WHILE position > 0
1950       left <- left + copy(right, 1, position-1) + pair[1]
1960       right <- copy(right, position + length(pair[0]), length(right))
1970       position <- pos(pair[0], right)
1980     LOOP
1990     result <- left + right
2000   NEXT pair
2010   REM Eliminate multiple spaces 
2020   position <- pos("  ", result)
2030   DO WHILE position > 0
2040     result <- copy(result, 1, position-1) + copy(result, position+1, length(result))
2050     position <- pos("  ", result)
2060   LOOP
2070   RETURN result
2080 END FUNCTION
2090 REM  
2100 REM Looks for the occurrence of the first of the strings 
2110 REM contained in keywords within the given sentence (in 
2120 REM array order). 
2130 REM Returns an array of 
2140 REM 0: the index of the first identified keyword (if any, otherwise -1), 
2150 REM 1: the position inside sentence (0 if not found) 
2160 REM TODO: Add type-specific suffixes where necessary! 
2170 FUNCTION findKeyword(CONST keyMap AS KeyMapEntry(50), sentence AS String) AS integer(0 TO 1)
2180   REM TODO: add the respective type suffixes to your variable names if required 
2190   REM  
2200   TYPE KeyMapEntry
2210     keyword AS String
2220     index AS Integer
2230   END TYPE
2240   DIM result(1) AS Integer
2250   DIM entry AS KeyMapEntry
2260   REM  
2270   REM Contains the index of the keyword and its position in sentence 
2280   result <- {-1, 0}
2290   i <- 0
2300   DO WHILE (result[0] < 0) and (i < length(keyMap))
2310     var entry: KeyMapEntry <- keyMap[i]
2320     position <- pos(entry.keyword, sentence)
2330     IF position > 0 THEN
2340       result[0] <- i
2350       result[1] <- position
2360     END IF
2370     i <- i+1
2380   LOOP
2390   RETURN result
2400 END FUNCTION
2410 REM  
2420 REM Converts the sentence to lowercase, eliminates all 
2430 REM interpunction (i.e. ',', '.', ';'), and pads the 
2440 REM sentence among blanks 
2450 REM TODO: Add type-specific suffixes where necessary! 
2460 FUNCTION normalizeInput(sentence AS String) AS String
2470   REM TODO: add the respective type suffixes to your variable names if required 
2480   REM  
2490   REM  
2500   sentence <- lowercase(sentence)
2510   FOR EACH symbol IN {'.', ',', ';', '!', '?'}
2520     position <- pos(symbol, sentence)
2530     DO WHILE position > 0
2540       sentence <- copy(sentence, 1, position-1) + copy(sentence, position+1, length(sentence))
2550       position <- pos(symbol, sentence)
2560     LOOP
2570   NEXT symbol
2580   result <- " " + sentence + " "
2590   RETURN result
2600 END FUNCTION
2610 REM  
2620 REM TODO: Add type-specific suffixes where necessary! 
2630 FUNCTION setupGoodByePhrases() AS String(50,0 TO 1)
2640   REM TODO: add the respective type suffixes to your variable names if required 
2650   REM  
2660   DIM phrases(,1) AS String
2670   REM  
2680   phrases[0] <- {" shut", "Okay. If you feel that way I\'ll shut up. ... Your choice."}
2690   phrases[1] <- {"bye", "Well, let\'s end our talk for now. See you later. Bye."}
2700   RETURN phrases
2710 END FUNCTION
2720 REM  
2730 REM The lower the index the higher the rank of the keyword (search is sequential). 
2740 REM The index of the first keyword found in a user sentence maps to a respective 
2750 REM reply ring as defined in `setupReplies()´. 
2760 REM TODO: Add type-specific suffixes where necessary! 
2770 FUNCTION setupKeywords() AS KeyMapEntry(50)
2780   REM TODO: add the respective type suffixes to your variable names if required 
2790   REM  
2800   TYPE KeyMapEntry
2810     keyword AS String
2820     index AS Integer
2830   END TYPE
2840   DIM keywords() AS KeyMapEntry
2850   REM  
2860   REM The empty key string (last entry) is the default clause - will always be found 
2870   keywords[39] <- KeyMapEntry{"", 29}
2880   keywords[0] <- KeyMapEntry{"can you ", 0}
2890   keywords[1] <- KeyMapEntry{"can i ", 1}
2900   keywords[2] <- KeyMapEntry{"you are ", 2}
2910   keywords[3] <- KeyMapEntry{"you\'re ", 2}
2920   keywords[4] <- KeyMapEntry{"i don't ", 3}
2930   keywords[5] <- KeyMapEntry{"i feel ", 4}
2940   keywords[6] <- KeyMapEntry{"why don\'t you ", 5}
2950   keywords[7] <- KeyMapEntry{"why can\'t i ", 6}
2960   keywords[8] <- KeyMapEntry{"are you ", 7}
2970   keywords[9] <- KeyMapEntry{"i can\'t ", 8}
2980   keywords[10] <- KeyMapEntry{"i am ", 9}
2990   keywords[11] <- KeyMapEntry{"i\'m ", 9}
3000   keywords[12] <- KeyMapEntry{"you ", 10}
3010   keywords[13] <- KeyMapEntry{"i want ", 11}
3020   keywords[14] <- KeyMapEntry{"what ", 12}
3030   keywords[15] <- KeyMapEntry{"how ", 12}
3040   keywords[16] <- KeyMapEntry{"who ", 12}
3050   keywords[17] <- KeyMapEntry{"where ", 12}
3060   keywords[18] <- KeyMapEntry{"when ", 12}
3070   keywords[19] <- KeyMapEntry{"why ", 12}
3080   keywords[20] <- KeyMapEntry{"name ", 13}
3090   keywords[21] <- KeyMapEntry{"cause ", 14}
3100   keywords[22] <- KeyMapEntry{"sorry ", 15}
3110   keywords[23] <- KeyMapEntry{"dream ", 16}
3120   keywords[24] <- KeyMapEntry{"hello ", 17}
3130   keywords[25] <- KeyMapEntry{"hi ", 17}
3140   keywords[26] <- KeyMapEntry{"maybe ", 18}
3150   keywords[27] <- KeyMapEntry{" no", 19}
3160   keywords[28] <- KeyMapEntry{"your ", 20}
3170   keywords[29] <- KeyMapEntry{"always ", 21}
3180   keywords[30] <- KeyMapEntry{"think ", 22}
3190   keywords[31] <- KeyMapEntry{"alike ", 23}
3200   keywords[32] <- KeyMapEntry{"yes ", 24}
3210   keywords[33] <- KeyMapEntry{"friend ", 25}
3220   keywords[34] <- KeyMapEntry{"computer", 26}
3230   keywords[35] <- KeyMapEntry{"bot ", 26}
3240   keywords[36] <- KeyMapEntry{"smartphone", 27}
3250   keywords[37] <- KeyMapEntry{"father ", 28}
3260   keywords[38] <- KeyMapEntry{"mother ", 28}
3270   RETURN keywords
3280 END FUNCTION
3290 REM  
3300 REM Returns an array of pairs of mutualy substitutable  
3310 REM TODO: Add type-specific suffixes where necessary! 
3320 FUNCTION setupReflexions() AS String(50,0 TO 1)
3330   REM TODO: add the respective type suffixes to your variable names if required 
3340   REM  
3350   DIM reflexions(,1) AS String
3360   REM  
3370   reflexions[0] <- {" are ", " am "}
3380   reflexions[1] <- {" were ", " was "}
3390   reflexions[2] <- {" you ", " I "}
3400   reflexions[3] <- {" your", " my"}
3410   reflexions[4] <- {" i\'ve ", " you\'ve "}
3420   reflexions[5] <- {" i\'m ", " you\'re "}
3430   reflexions[6] <- {" me ", " you "}
3440   reflexions[7] <- {" my ", " your "}
3450   reflexions[8] <- {" i ", " you "}
3460   reflexions[9] <- {" am ", " are "}
3470   RETURN reflexions
3480 END FUNCTION
3490 REM  
3500 REM This routine sets up the reply rings addressed by the key words defined in 
3510 REM routine `setupKeywords()´ and mapped hitherto by the cross table defined 
3520 REM in `setupMapping()´ 
3530 REM TODO: Add type-specific suffixes where necessary! 
3540 FUNCTION setupReplies() AS String(50,50)
3550   REM TODO: add the respective type suffixes to your variable names if required 
3560   REM  
3570   DIM setupReplies(,) AS String
3580   DIM replies(,) AS String
3590   REM  
3600   REM We start with the highest index for performance reasons 
3610   REM (is to avoid frequent array resizing) 
3620   replies[29] <- { "Say, do you have any psychological problems?", "What does that suggest to you?", "I see.", "I'm not sure I understand you fully.", "Come come elucidate your thoughts.", "Can you elaborate on that?", "That is quite interesting."}
3630   replies[0] <- { "Don't you believe that I can*?", "Perhaps you would like to be like me?", "You want me to be able to*?"}
3640   replies[1] <- { "Perhaps you don't want to*?", "Do you want to be able to*?"}
3650   replies[2] <- { "What makes you think I am*?", "Does it please you to believe I am*?", "Perhaps you would like to be*?", "Do you sometimes wish you were*?"}
3660   replies[3] <- { "Don't you really*?", "Why don't you*?", "Do you wish to be able to*?", "Does that trouble you*?"}
3670   replies[4] <- { "Do you often feel*?", "Are you afraid of feeling*?", "Do you enjoy feeling*?"}
3680   replies[5] <- { "Do you really believe I don't*?", "Perhaps in good time I will*.", "Do you want me to*?"}
3690   replies[6] <- { "Do you think you should be able to*?", "Why can't you*?"}
3700   replies[7] <- { "Why are you interested in whether or not I am*?", "Would you prefer if I were not*?", "Perhaps in your fantasies I am*?"}
3710   replies[8] <- { "How do you know you can't*?", "Have you tried?","Perhaps you can now*."}
3720   replies[9] <- { "Did you come to me because you are*?", "How long have you been*?", "Do you believe it is normal to be*?", "Do you enjoy being*?"}
3730   replies[10] <- { "We were discussing you--not me.", "Oh, I*.", "You're not really talking about me, are you?"}
3740   replies[11] <- { "What would it mean to you if you got*?", "Why do you want*?", "Suppose you soon got*...", "What if you never got*?", "I sometimes also want*."}
3750   replies[12] <- { "Why do you ask?", "Does that question interest you?", "What answer would please you the most?", "What do you think?", "Are such questions on your mind often?", "What is it that you really want to know?", "Have you asked anyone else?", "Have you asked such questions before?", "What else comes to mind when you ask that?"}
3760   replies[13] <- { "Names don't interest me.", "I don't care about names -- please go on."}
3770   replies[14] <- { "Is that the real reason?", "Don't any other reasons come to mind?", "Does that reason explain anything else?", "What other reasons might there be?"}
3780   replies[15] <- { "Please don't apologize!", "Apologies are not necessary.", "What feelings do you have when you apologize?", "Don't be so defensive!"}
3790   replies[16] <- { "What does that dream suggest to you?", "Do you dream often?", "What persons appear in your dreams?", "Are you disturbed by your dreams?"}
3800   replies[17] <- { "How do you do ...please state your problem."}
3810   replies[18] <- { "You don't seem quite certain.", "Why the uncertain tone?", "Can't you be more positive?", "You aren't sure?", "Don't you know?"}
3820   replies[19] <- { "Are you saying no just to be negative?", "You are being a bit negative.", "Why not?", "Are you sure?", "Why no?"}
3830   replies[20] <- { "Why are you concerned about my*?", "What about your own*?"}
3840   replies[21] <- { "Can you think of a specific example?", "When?", "What are you thinking of?", "Really, always?"}
3850   replies[22] <- { "Do you really think so?", "But you are not sure you*?", "Do you doubt you*?"}
3860   replies[23] <- { "In what way?", "What resemblance do you see?", "What does the similarity suggest to you?", "What other connections do you see?", "Could there really be some connection?", "How?", "You seem quite positive."}
3870   replies[24] <- { "Are you sure?", "I see.", "I understand."}
3880   replies[25] <- { "Why do you bring up the topic of friends?", "Do your friends worry you?", "Do your friends pick on you?", "Are you sure you have any friends?", "Do you impose on your friends?", "Perhaps your love for friends worries you."}
3890   replies[26] <- { "Do computers worry you?", "Are you talking about me in particular?", "Are you frightened by machines?", "Why do you mention computers?", "What do you think machines have to do with your problem?", "Don't you think computers can help people?", "What is it about machines that worries you?"}
3900   replies[27] <- { "Do you sometimes feel uneasy without a smartphone?", "Have you had these phantasies before?", "Does the world seem more real for you via apps?"}
3910   replies[28] <- { "Tell me more about your family.", "Who else in your family*?", "What does family relations mean for you?", "Come on, How old are you?"}
3920   setupReplies <- replies
3930   RETURN setupReplies
3940 END FUNCTION

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

