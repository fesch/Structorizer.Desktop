// Generated by Structorizer 3.32-32 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

using FileAPI.CS;
using System;

/// <summary>
/// Tries to read as many integer values as possible upto maxNumbers
/// from file fileName into the given array numbers.
/// Returns the number of the actually read numbers. May cause an exception.
/// </summary>
public class readNumbers {

	/**
	 * Flag ensures that initialisation method {@link #initialize_FileApiGroupTest()}
	 *  runs just one time.
	 */
	private static boolean null = false;

	public static void null() {

		// TODO: Check and accomplish variable declarations: 

		nNumbers <- 0;
		fileNo <- fileOpen(fileName);
		if (fileNo <= 0) {
			// FIXME: You should replace System.Exception by an own subclass! 
			throw new System.Exception("File could not be opened!");
		}
		try {
			while (not fileEOF(fileNo) and nNumbers < maxNumbers) {
				number <- fileReadInt(fileNo);
				numbers[nNumbers] <- number;
				nNumbers <- nNumbers + 1;
			}
		}
		catch(Exception ex43bd930a) {
			string error = ex43bd930a.ToString()
			throw;
		}
		finally {
			fileClose(fileNo);
		}
		return nNumbers;
	}

	/// <summary>
	/// Draws a bar chart from the array "values" of size nValues.
	/// Turtleizer must be activated and will scale the chart into a square of
	/// 500 x 500 pixels
	/// Note: The function is not robust against empty array or totally equal values.
	/// </summary>
	/// <param name="values"> TODO </param>
	/// <param name="nValues"> TODO </param>
	private static void drawBarChart(double[] values, ??? nValues) {
		// TODO: Check and accomplish variable declarations: 

		// Used range of the Turtleizer screen 
		const xSize <- 500;
		const ySize <- 500;
		kMin <- 0;
		kMax <- 0;
		for (int k = 1; k <= nValues-1; k += (1)) {
			if (values[k] > values[kMax]) {
				kMax <- k;
			}
			else if (values[k] < values[kMin]) {
				kMin <- k;
			}
		}
		valMin <- values[kMin];
		valMax <- values[kMax];
		yScale <- valMax * 1.0 / (ySize - 1);
		yAxis <- ySize - 1;
		if (valMin < 0) {
			if (valMax > 0) {
				yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
				yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
			}
			else {
				yAxis <- 1;
				yScale <- valMin * 1.0 / (ySize - 1);
			}
		}
		// draw coordinate axes 
		gotoXY(1, ySize - 1);
		forward(ySize -1); // color = ffffff
		penUp();
		backward(yAxis); // color = ffffff
		right(90);
		penDown();
		forward(xSize -1); // color = ffffff
		penUp();
		backward(xSize-1); // color = ffffff
		stripeWidth <- xSize / nValues;
		for (int k = 0; k <= nValues-1; k += (1)) {
			stripeHeight <- values[k] * 1.0 / yScale;
			switch (k mod 3) {
			case 0:
				setPenColor(255,0,0);
				break;
			case 1:
				setPenColor(0, 255,0);
				break;
			case 2:
				setPenColor(0, 0, 255);
				break;
			}
			fd(1); // color = ffffff
			left(90);
			penDown();
			fd(stripeHeight); // color = ffffff
			right(90);
			fd(stripeWidth - 1); // color = ffffff
			right(90);
			forward(stripeHeight); // color = ffffff
			left(90);
			penUp();
		}
	}

// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 


}

// ======= 8< =========================================================== 

// Generated by Structorizer 3.32-32 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

using FileApiGroupTest;
using System;

/// <summary>
/// Computes the sum and average of the numbers read from a user-specified
/// text file (which might have been created via generateRandomNumberFile(4)).
/// 
/// This program is part of an arrangement used to test group code export (issue
/// #828) with FileAPI dependency.
/// The input check loop has been disabled (replaced by a simple unchecked input
/// instruction) in order to test the effect of indirect FileAPI dependency (only the
/// called subroutine directly requires FileAPI now).
/// </summary>
public class ComputeSum {

	/// <param name="args"> array of command line arguments </param>
	public static void Main(string[] args) {

		initialize_FileApiGroupTest();
		// TODO: Check and accomplish variable declarations: 

		// TODO: You may have to modify input instructions, 
		//       possibly by enclosing Console.ReadLine() calls with 
		//       Parse methods according to the variable type, e.g.: 
		//          i = int.Parse(Console.ReadLine()); 

		fileNo <- 1000;
		// Disable this if you enable the loop below! 
		Console.Write("Name/path of the number file"); file_name = Console.ReadLine();
		// If you enable this loop, then the preceding input instruction is to be disabled 
		// and the fileClose instruction in the alternative below is to be enabled. 
// 		do { 
// 			Console.Write("Name/path of the number file"); file_name = Console.ReadLine(); 
// 			fileNo <- fileOpen(file_name); 
// 		} while (!(fileNo > 0 or file_name = "")); 
		if (fileNo > 0) {
			// This should be enabled if the input check loop above gets enabled. 
// 			fileClose(fileNo); 
			values <- {};
			nValues <- 0;
			try {
				nValues <- FileApiGroupTest.readNumbers(file_name, values, 1000);
			}
			catch(Exception ex7403c468) {
				string failure = ex7403c468.ToString()
				Console.WriteLine(failure);
				if (System.Windows.Forms.Application.MessageLoop) {
					// WinForms app 
					System.Windows.Forms.Application.Exit();
				}
				else {
					// Console app 
					System.Environment.Exit(-7);
				}
			}
			sum <- 0.0;
			for (int k = 0; k <= nValues-1; k += (1)) {
				sum <- sum + values[k];
			}
			Console.Write("sum = "); Console.WriteLine(sum);
			Console.Write("average = "); Console.WriteLine(sum / nValues);
		}
	}

// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 


}

// ======= 8< =========================================================== 

// Generated by Structorizer 3.32-32 

// Copyright (C) 2020-03-21 Kay Gürtzig 
// License: GPLv3-link 
// GNU General Public License (V 3) 
// https://www.gnu.org/licenses/gpl.html 
// http://www.gnu.de/documents/gpl.de.html 

using FileApiGroupTest;
using FileAPI.CS;
using System;

/// <summary>
/// Reads a random number file and draws a histogram accotrding to the
/// user specifications
/// </summary>
public class DrawRandomHistogram {

	/// <param name="args"> array of command line arguments </param>
	public static void Main(string[] args) {

		initialize_FileApiGroupTest();
		// TODO: Check and accomplish variable declarations: 

		// TODO: You may have to modify input instructions, 
		//       possibly by enclosing Console.ReadLine() calls with 
		//       Parse methods according to the variable type, e.g.: 
		//          i = int.Parse(Console.ReadLine()); 

		fileNo <- -10;
		do {
			Console.Write("Name/path of the number file"); file_name = Console.ReadLine();
			fileNo <- fileOpen(file_name);
		} while (!(fileNo > 0 or file_name = ""));
		if (fileNo > 0) {
			fileClose(fileNo);
			Console.Write("number of intervals"); nIntervals = Console.ReadLine();
			// Initialize the interval counters 
			for (int k = 0; k <= nIntervals-1; k += (1)) {
				count[k] <- 0;
			}
			// Index of the most populated interval 
			kMaxCount <- 0;
			numberArray <- {};
			nObtained <- 0;
			try {
				nObtained <- FileApiGroupTest.readNumbers(file_name, numberArray, 10000);
			}
			catch(Exception ex7e0e6aa2) {
				string failure = ex7e0e6aa2.ToString()
				Console.WriteLine(failure);
			}
			if (nObtained > 0) {
				min <- numberArray[0];
				max <- numberArray[0];
				for (int i = 1; i <= nObtained-1; i += (1)) {
					if (numberArray[i] < min) {
						min <- numberArray[i];
					}
					else if (numberArray[i] > max) {
						max <- numberArray[i];
					}
				}
				// Interval width 
				width <- (max - min) * 1.0 / nIntervals;
				for (int i = 0; i <= nObtained - 1; i += (1)) {
					value <- numberArray[i];
					k <- 1;
					while (k < nIntervals and value > min + k * width) {
						k <- k + 1;
					}
					count[k-1] <- count[k-1] + 1;
					if (count[k-1] > count[kMaxCount]) {
						kMaxCount <- k-1;
					}
				}
				drawBarChart(count, nIntervals);
				Console.Write("Interval with max count: "); Console.Write(kMaxCount); Console.Write(" ("); Console.Write(count[kMaxCount]); Console.WriteLine(")");
				for (int k = 0; k <= nIntervals-1; k += (1)) {
					Console.Write(count[k]); Console.Write(" numbers in interval "); Console.Write(k); Console.Write(" ("); Console.Write(min + k * width); Console.Write(" ... "); Console.Write(min + (k+1) * width); Console.WriteLine(")");
				}
			}
			else {
				Console.WriteLine("No numbers read.");
			}
		}
	}

	/// <summary>
	/// Draws a bar chart from the array "values" of size nValues.
	/// Turtleizer must be activated and will scale the chart into a square of
	/// 500 x 500 pixels
	/// Note: The function is not robust against empty array or totally equal values.
	/// </summary>
	/// <param name="values"> TODO </param>
	/// <param name="nValues"> TODO </param>
	private static void drawBarChart(double[] values, ??? nValues) {
		// TODO: Check and accomplish variable declarations: 

		// Used range of the Turtleizer screen 
		const xSize <- 500;
		const ySize <- 500;
		kMin <- 0;
		kMax <- 0;
		for (int k = 1; k <= nValues-1; k += (1)) {
			if (values[k] > values[kMax]) {
				kMax <- k;
			}
			else if (values[k] < values[kMin]) {
				kMin <- k;
			}
		}
		valMin <- values[kMin];
		valMax <- values[kMax];
		yScale <- valMax * 1.0 / (ySize - 1);
		yAxis <- ySize - 1;
		if (valMin < 0) {
			if (valMax > 0) {
				yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
				yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
			}
			else {
				yAxis <- 1;
				yScale <- valMin * 1.0 / (ySize - 1);
			}
		}
		// draw coordinate axes 
		gotoXY(1, ySize - 1);
		forward(ySize -1); // color = ffffff
		penUp();
		backward(yAxis); // color = ffffff
		right(90);
		penDown();
		forward(xSize -1); // color = ffffff
		penUp();
		backward(xSize-1); // color = ffffff
		stripeWidth <- xSize / nValues;
		for (int k = 0; k <= nValues-1; k += (1)) {
			stripeHeight <- values[k] * 1.0 / yScale;
			switch (k mod 3) {
			case 0:
				setPenColor(255,0,0);
				break;
			case 1:
				setPenColor(0, 255,0);
				break;
			case 2:
				setPenColor(0, 0, 255);
				break;
			}
			fd(1); // color = ffffff
			left(90);
			penDown();
			fd(stripeHeight); // color = ffffff
			right(90);
			fd(stripeWidth - 1); // color = ffffff
			right(90);
			forward(stripeHeight); // color = ffffff
			left(90);
			penUp();
		}
	}

// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 


}
