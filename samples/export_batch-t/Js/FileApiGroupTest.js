// ======= 8< ======= FileApiGroupTest.js =============================== 

<script>
// function readNumbers(fileName: string; numbers: array of integer; maxNumbers: integer): integer 
// Generated by Structorizer 3.32-31 

// function drawBarChart(values: array of double; nValues) 
// Draws a bar chart from the array "values" of size nValues. 
// Turtleizer must be activated and will scale the chart into a square of 
// 500 x 500 pixels 
// Note: The function is not robust against empty array or totally equal values. 
export function drawBarChart(values, nValues) {

	// Used range of the Turtleizer screen 
	const xSize <- 500;
	const ySize <- 500;
	kMin <- 0;
	kMax <- 0;
	for (int k = 1; k <= nValues-1; k += (1))
	{
		if (values[k] > values[kMax])
		{
			kMax <- k;
		}
		else if (values[k] < values[kMin])
		{
			kMin <- k;
		}
	}
	valMin <- values[kMin];
	valMax <- values[kMax];
	yScale <- valMax * 1.0 / (ySize - 1);
	yAxis <- ySize - 1;
	if (valMin < 0)
	{
		if (valMax > 0)
		{
			yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
			yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
		}
		else
		{
			yAxis <- 1;
			yScale <- valMin * 1.0 / (ySize - 1);
		}
	}
	// draw coordinate axes 
	gotoXY(1, ySize - 1);
	forward(ySize -1); // color = ffffff
	penUp();
	backward(yAxis); // color = ffffff
	right(90);
	penDown();
	forward(xSize -1); // color = ffffff
	penUp();
	backward(xSize-1); // color = ffffff
	stripeWidth <- xSize / nValues;
	for (int k = 0; k <= nValues-1; k += (1))
	{
		stripeHeight <- values[k] * 1.0 / yScale;
		switch (k mod 3)
		{
		case 0:
			setPenColor(255,0,0);
			break;
		case 1:
			setPenColor(0, 255,0);
			break;
		case 2:
			setPenColor(0, 0, 255);
			break;
		}
		fd(1); // color = ffffff
		left(90);
		penDown();
		fd(stripeHeight); // color = ffffff
		right(90);
		fd(stripeWidth - 1); // color = ffffff
		right(90);
		forward(stripeHeight); // color = ffffff
		left(90);
		penUp();
	}
}
// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// Tries to read as many integer values as possible upto maxNumbers 
// from file fileName into the given array numbers. 
// Returns the number of the actually read numbers. May cause an exception. 
export function readNumbers(fileName, numbers, maxNumbers) {
	
	nNumbers <- 0;
	fileNo <- fileOpen(fileName);
	if (fileNo <= 0)
	{
		throw "File could not be opened!";
	}
	try
	{
		while (not fileEOF(fileNo) and nNumbers < maxNumbers)
		{
			number <- fileReadInt(fileNo);
			numbers[nNumbers] <- number;
			nNumbers <- nNumbers + 1;
		}
	}
	catch (ex2173f6d9)
	{
		error = ex2173f6d9.message
		throw ex2173f6d9;
	}
	finally
	{
		fileClose(fileNo);
	}
	return nNumbers;
}
</script>

// ======= 8< =========================================================== 

<script>
// program ComputeSum 
// Generated by Structorizer 3.32-31 

import ./FileApiGroupTest.js;

// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// Computes the sum and average of the numbers read from a user-specified 
// text file (which might have been created via generateRandomNumberFile(4)). 
//  
// This program is part of an arrangement used to test group code export (issue 
// #828) with FileAPI dependency. 
// The input check loop has been disabled (replaced by a simple unchecked input 
// instruction) in order to test the effect of indirect FileAPI dependency (only the 
// called subroutine directly requires FileAPI now). 
FileApiGroupTest();

fileNo <- 1000;
// Disable this if you enable the loop below! 
file_name = prompt("Name/path of the number file");
// If you enable this loop, then the preceding input instruction is to be disabled 
// and the fileClose instruction in the alternative below is to be enabled. 
// do 
// { 
// 	file_name = prompt("Name/path of the number file"); 
// 	fileNo <- fileOpen(file_name); 
// } while (not (fileNo > 0 or file_name = "")); 
if (fileNo > 0)
{
	// This should be enabled if the input check loop above gets enabled. 
// 	fileClose(fileNo); 
	values <- {};
	nValues <- 0;
	try
	{
		nValues <- readNumbers(file_name, values, 1000);
	}
	catch (ex1a1d6a08)
	{
		failure = ex1a1d6a08.message
		document.write((failure) + "<br/>");
		exit(-7);
	}
	sum <- 0.0;
	for (int k = 0; k <= nValues-1; k += (1))
	{
		sum <- sum + values[k];
	}
	document.write(("sum = ", sum) + "<br/>");
	document.write(("average = ", sum / nValues) + "<br/>");
}
</script>

// ======= 8< =========================================================== 

<script>
// program DrawRandomHistogram 
// Generated by Structorizer 3.32-31 

import ./FileApiGroupTest.js;

// function drawBarChart(values: array of double; nValues) 
// Draws a bar chart from the array "values" of size nValues. 
// Turtleizer must be activated and will scale the chart into a square of 
// 500 x 500 pixels 
// Note: The function is not robust against empty array or totally equal values. 
function drawBarChart(values, nValues) {

	// Used range of the Turtleizer screen 
	const xSize <- 500;
	const ySize <- 500;
	kMin <- 0;
	kMax <- 0;
	for (int k = 1; k <= nValues-1; k += (1))
	{
		if (values[k] > values[kMax])
		{
			kMax <- k;
		}
		else if (values[k] < values[kMin])
		{
			kMin <- k;
		}
	}
	valMin <- values[kMin];
	valMax <- values[kMax];
	yScale <- valMax * 1.0 / (ySize - 1);
	yAxis <- ySize - 1;
	if (valMin < 0)
	{
		if (valMax > 0)
		{
			yAxis <- valMax * ySize * 1.0 / (valMax - valMin);
			yScale <- (valMax - valMin) * 1.0 / (ySize - 1);
		}
		else
		{
			yAxis <- 1;
			yScale <- valMin * 1.0 / (ySize - 1);
		}
	}
	// draw coordinate axes 
	gotoXY(1, ySize - 1);
	forward(ySize -1); // color = ffffff
	penUp();
	backward(yAxis); // color = ffffff
	right(90);
	penDown();
	forward(xSize -1); // color = ffffff
	penUp();
	backward(xSize-1); // color = ffffff
	stripeWidth <- xSize / nValues;
	for (int k = 0; k <= nValues-1; k += (1))
	{
		stripeHeight <- values[k] * 1.0 / yScale;
		switch (k mod 3)
		{
		case 0:
			setPenColor(255,0,0);
			break;
		case 1:
			setPenColor(0, 255,0);
			break;
		case 2:
			setPenColor(0, 0, 255);
			break;
		}
		fd(1); // color = ffffff
		left(90);
		penDown();
		fd(stripeHeight); // color = ffffff
		right(90);
		fd(stripeWidth - 1); // color = ffffff
		right(90);
		forward(stripeHeight); // color = ffffff
		left(90);
		penUp();
	}
}
// = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

// Reads a random number file and draws a histogram accotrding to the 
// user specifications 
FileApiGroupTest();

fileNo <- -10;
do
{
	file_name = prompt("Name/path of the number file");
	fileNo <- fileOpen(file_name);
} while (not (fileNo > 0 or file_name = ""));
if (fileNo > 0)
{
	fileClose(fileNo);
	nIntervals = prompt("number of intervals");
	// Initialize the interval counters 
	for (int k = 0; k <= nIntervals-1; k += (1))
	{
		count[k] <- 0;
	}
	// Index of the most populated interval 
	kMaxCount <- 0;
	numberArray <- {};
	nObtained <- 0;
	try
	{
		nObtained <- readNumbers(file_name, numberArray, 10000);
	}
	catch (ex687080dc)
	{
		failure = ex687080dc.message
		document.write((failure) + "<br/>");
	}
	if (nObtained > 0)
	{
		min <- numberArray[0];
		max <- numberArray[0];
		for (int i = 1; i <= nObtained-1; i += (1))
		{
			if (numberArray[i] < min)
			{
				min <- numberArray[i];
			}
			else if (numberArray[i] > max)
			{
				max <- numberArray[i];
			}
		}
		// Interval width 
		width <- (max - min) * 1.0 / nIntervals;
		for (int i = 0; i <= nObtained - 1; i += (1))
		{
			value <- numberArray[i];
			k <- 1;
			while (k < nIntervals and value > min + k * width)
			{
				k <- k + 1;
			}
			count[k-1] <- count[k-1] + 1;
			if (count[k-1] > count[kMaxCount])
			{
				kMaxCount <- k-1;
			}
		}
		drawBarChart(count, nIntervals);
		document.write(("Interval with max count: ", kMaxCount, " (", count[kMaxCount], ")") + "<br/>");
		for (int k = 0; k <= nIntervals-1; k += (1))
		{
			document.write((count[k], " numbers in interval ", k, " (", min + k * width, " ... ", min + (k+1) * width, ")") + "<br/>");
		}
	}
	else
	{
		document.write(("No numbers read.") + "<br/>");
	}
}
</script>
