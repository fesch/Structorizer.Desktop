10 REM Tries to read as many integer values as possible upto maxNumbers 
20 REM from file fileName into the given array numbers. 
30 REM Returns the number of the actually read numbers. May cause an exception. 
40 REM Generated by Structorizer 3.32-31 
50 
60 REM Copyright (C) 2020-03-21 Kay Gürtzig 
70 REM License: GPLv3-link 
80 REM GNU General Public License (V 3) 
90 REM https://www.gnu.org/licenses/gpl.html 
100 REM http://www.gnu.de/documents/gpl.de.html 
110 
120 REM  
130 REM TODO: Add type-specific suffixes where necessary! 
140 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
150   REM TODO: add the respective type suffixes to your variable names if required 
160   REM  
170   LET nNumbers = 0
180   LET fileNo = fileOpen(fileName)
190   IF fileNo <= 0 THEN
200     REM FIXME: Only a number is allowed as parameter: 
210     ERROR "File could not be opened!"
220   END IF
230   ON ERROR GOTO 310
240   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
250     LET number = fileReadInt(fileNo)
260     LET numbers(nNumbers) = number
270     LET nNumbers = nNumbers + 1
280   LOOP
290   GOTO 340
300   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
310     REM FIXME: Only a number is allowed as parameter: 
320     ERROR 
330   REM End of error handler, resume here ... 
340   ON ERROR GOTO 0
350   fileClose(fileNo)
360   RETURN nNumbers
370 END FUNCTION
380 REM  
390 REM Draws a bar chart from the array "values" of size nValues. 
400 REM Turtleizer must be activated and will scale the chart into a square of 
410 REM 500 x 500 pixels 
420 REM Note: The function is not robust against empty array or totally equal values. 
430 REM TODO: Add type-specific suffixes where necessary! 
440 SUB drawBarChart(values AS double(50), nValues)
450   REM TODO: add the respective type suffixes to your variable names if required 
460   REM  
470   REM  
480   REM Used range of the Turtleizer screen 
490   LET xSize = 500
500   LET ySize = 500
510   LET kMin = 0
520   LET kMax = 0
530   FOR k = 1 TO nValues-1
540     IF values(k) > values(kMax) THEN
550       LET kMax = k
560     ELSE
570       IF values(k) < values(kMin) THEN
580         LET kMin = k
590       END IF
600     END IF
610   NEXT k
620   LET valMin = values(kMin)
630   LET valMax = values(kMax)
640   LET yScale = valMax * 1.0 / (ySize - 1)
650   LET yAxis = ySize - 1
660   IF valMin < 0 THEN
670     IF valMax > 0 THEN
680       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
690       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
700     ELSE
710       LET yAxis = 1
720       LET yScale = valMin * 1.0 / (ySize - 1)
730     END IF
740   END IF
750   REM draw coordinate axes 
760   gotoXY(1, ySize - 1)
770   forward(ySize -1) : REM color = ffffff
780   penUp()
790   backward(yAxis) : REM color = ffffff
800   right(90)
810   penDown()
820   forward(xSize -1) : REM color = ffffff
830   penUp()
840   backward(xSize-1) : REM color = ffffff
850   LET stripeWidth = xSize / nValues
860   FOR k = 0 TO nValues-1
870     LET stripeHeight = values(k) * 1.0 / yScale
880     SELECT CASE k % 3
890       CASE 0
900         setPenColor(255,0,0)
910       CASE 1
920         setPenColor(0, 255,0)
930       CASE 2
940         setPenColor(0, 0, 255)
950     END SELECT
960     fd(1) : REM color = ffffff
970     left(90)
980     penDown()
990     fd(stripeHeight) : REM color = ffffff
1000     right(90)
1010     fd(stripeWidth - 1) : REM color = ffffff
1020     right(90)
1030     forward(stripeHeight) : REM color = ffffff
1040     left(90)
1050     penUp()
1060   NEXT k
1070 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1080 REM ======= 8< =========================================================== 
1090 
1100 REM Computes the sum and average of the numbers read from a user-specified 
1110 REM text file (which might have been created via generateRandomNumberFile(4)). 
1120 REM  
1130 REM This program is part of an arrangement used to test group code export (issue 
1140 REM #828) with FileAPI dependency. 
1150 REM The input check loop has been disabled (replaced by a simple unchecked input 
1160 REM instruction) in order to test the effect of indirect FileAPI dependency (only the 
1170 REM called subroutine directly requires FileAPI now). 
1180 REM Generated by Structorizer 3.32-31 
1190 
1200 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1210 REM License: GPLv3-link 
1220 REM GNU General Public License (V 3) 
1230 REM https://www.gnu.org/licenses/gpl.html 
1240 REM http://www.gnu.de/documents/gpl.de.html 
1250 
1260 REM  
1270 REM program ComputeSum
1280 REM TODO: add the respective type suffixes to your variable names if required 
1290 DIM values() AS ???
1300 REM  
1310 LET fileNo = 1000
1320 REM Disable this if you enable the loop below! 
1330 PRINT "Name/path of the number file"; : INPUT file_name
1340 REM If you enable this loop, then the preceding input instruction is to be disabled 
1350 REM and the fileClose instruction in the alternative below is to be enabled. 
1360 REM DO 
1370 REM   PRINT "Name/path of the number file"; : INPUT file_name 
1380 REM   LET fileNo = fileOpen(file_name) 
1390 REM LOOP UNTIL fileNo > 0 OR file_name = "" 
1400 IF fileNo > 0 THEN
1410   REM This should be enabled if the input check loop above gets enabled. 
1420 REM   fileClose(fileNo) 
1430   LET nValues = 0
1440   ON ERROR GOTO 1480
1450   LET nValues = readNumbers(file_name, values, 1000)
1460   GOTO 1510
1470   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1480     PRINT failure
1490     STOP
1500   REM End of error handler, resume here ... 
1510   ON ERROR GOTO 0
1520   LET sum = 0.0
1530   FOR k = 0 TO nValues-1
1540     LET sum = sum + values(k)
1550   NEXT k
1560   PRINT "sum = "; sum
1570   PRINT "average = "; sum / nValues
1580 END IF
1590 END

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1600 REM ======= 8< =========================================================== 
1610 
1620 REM Reads a random number file and draws a histogram accotrding to the 
1630 REM user specifications 
1640 REM Generated by Structorizer 3.32-31 
1650 
1660 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1670 REM License: GPLv3-link 
1680 REM GNU General Public License (V 3) 
1690 REM https://www.gnu.org/licenses/gpl.html 
1700 REM http://www.gnu.de/documents/gpl.de.html 
1710 
1720 REM  
1730 REM program DrawRandomHistogram
1740 REM TODO: add the respective type suffixes to your variable names if required 
1750 DIM numberArray() AS ???
1760 DIM count() AS Integer
1770 REM  
1780 LET fileNo = -10
1790 DO
1800   PRINT "Name/path of the number file"; : INPUT file_name
1810   LET fileNo = fileOpen(file_name)
1820 LOOP UNTIL fileNo > 0 OR file_name = ""
1830 IF fileNo > 0 THEN
1840   fileClose(fileNo)
1850   PRINT "number of intervals"; : INPUT nIntervals
1860   REM Initialize the interval counters 
1870   FOR k = 0 TO nIntervals-1
1880     LET count(k) = 0
1890   NEXT k
1900   REM Index of the most populated interval 
1910   LET kMaxCount = 0
1920   LET nObtained = 0
1930   ON ERROR GOTO 1970
1940   LET nObtained = readNumbers(file_name, numberArray, 10000)
1950   GOTO 1990
1960   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1970     PRINT failure
1980   REM End of error handler, resume here ... 
1990   ON ERROR GOTO 0
2000   IF nObtained > 0 THEN
2010     LET min = numberArray(0)
2020     LET max = numberArray(0)
2030     FOR i = 1 TO nObtained-1
2040       IF numberArray(i) < min THEN
2050         LET min = numberArray(i)
2060       ELSE
2070         IF numberArray(i) > max THEN
2080           LET max = numberArray(i)
2090         END IF
2100       END IF
2110     NEXT i
2120     REM Interval width 
2130     LET width = (max - min) * 1.0 / nIntervals
2140     FOR i = 0 TO nObtained - 1
2150       LET value = numberArray(i)
2160       LET k = 1
2170       DO WHILE k < nIntervals AND value > min + k * width
2180         LET k = k + 1
2190       LOOP
2200       LET count(k-1) = count(k-1) + 1
2210       IF count(k-1) > count(kMaxCount) THEN
2220         LET kMaxCount = k-1
2230       END IF
2240     NEXT i
2250     CALL drawBarChart(count, nIntervals)
2260     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
2270     FOR k = 0 TO nIntervals-1
2280       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
2290     NEXT k
2300   ELSE
2310     PRINT "No numbers read."
2320   END IF
2330 END IF
2340 END
2350 REM  
2360 REM Draws a bar chart from the array "values" of size nValues. 
2370 REM Turtleizer must be activated and will scale the chart into a square of 
2380 REM 500 x 500 pixels 
2390 REM Note: The function is not robust against empty array or totally equal values. 
2400 REM TODO: Add type-specific suffixes where necessary! 
2410 SUB drawBarChart(values AS double(50), nValues)
2420   REM TODO: add the respective type suffixes to your variable names if required 
2430   REM  
2440   REM  
2450   REM Used range of the Turtleizer screen 
2460   LET xSize = 500
2470   LET ySize = 500
2480   LET kMin = 0
2490   LET kMax = 0
2500   FOR k = 1 TO nValues-1
2510     IF values(k) > values(kMax) THEN
2520       LET kMax = k
2530     ELSE
2540       IF values(k) < values(kMin) THEN
2550         LET kMin = k
2560       END IF
2570     END IF
2580   NEXT k
2590   LET valMin = values(kMin)
2600   LET valMax = values(kMax)
2610   LET yScale = valMax * 1.0 / (ySize - 1)
2620   LET yAxis = ySize - 1
2630   IF valMin < 0 THEN
2640     IF valMax > 0 THEN
2650       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
2660       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
2670     ELSE
2680       LET yAxis = 1
2690       LET yScale = valMin * 1.0 / (ySize - 1)
2700     END IF
2710   END IF
2720   REM draw coordinate axes 
2730   gotoXY(1, ySize - 1)
2740   forward(ySize -1) : REM color = ffffff
2750   penUp()
2760   backward(yAxis) : REM color = ffffff
2770   right(90)
2780   penDown()
2790   forward(xSize -1) : REM color = ffffff
2800   penUp()
2810   backward(xSize-1) : REM color = ffffff
2820   LET stripeWidth = xSize / nValues
2830   FOR k = 0 TO nValues-1
2840     LET stripeHeight = values(k) * 1.0 / yScale
2850     SELECT CASE k % 3
2860       CASE 0
2870         setPenColor(255,0,0)
2880       CASE 1
2890         setPenColor(0, 255,0)
2900       CASE 2
2910         setPenColor(0, 0, 255)
2920     END SELECT
2930     fd(1) : REM color = ffffff
2940     left(90)
2950     penDown()
2960     fd(stripeHeight) : REM color = ffffff
2970     right(90)
2980     fd(stripeWidth - 1) : REM color = ffffff
2990     right(90)
3000     forward(stripeHeight) : REM color = ffffff
3010     left(90)
3020     penUp()
3030   NEXT k
3040 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

