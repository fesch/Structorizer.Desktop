10 REM Tries to read as many integer values as possible upto maxNumbers 
20 REM from file fileName into the given array numbers. 
30 REM Returns the number of the actually read numbers. May cause an exception. 
40 REM Generated by Structorizer 3.32-32 
50 
60 REM Copyright (C) 2020-03-21 Kay Gürtzig 
70 REM License: GPLv3-link 
80 REM GNU General Public License (V 3) 
90 REM https://www.gnu.org/licenses/gpl.html 
100 REM http://www.gnu.de/documents/gpl.de.html 
110 
120 REM  
130 REM TODO: Add type-specific suffixes where necessary! 
140 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
150   REM TODO: add the respective type suffixes to your variable names if required 
160   REM  
170   LET nNumbers = 0
180   LET fileNo = fileOpen(fileName)
190   IF fileNo <= 0 THEN
200     REM FIXME: Only a number is allowed as parameter: 
210     ERROR "File could not be opened!"
220   END IF
230   ON ERROR GOTO 310
240   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
250     LET number = fileReadInt(fileNo)
260     LET numbers(nNumbers) = number
270     LET nNumbers = nNumbers + 1
280   LOOP
290   GOTO 340
300   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
310     REM FIXME: Only a number is allowed as parameter: 
320     ERROR 
330   REM End of error handler, resume here ... 
340   ON ERROR GOTO 0
350   fileClose(fileNo)
360   RETURN nNumbers
370 END FUNCTION
380 REM  
390 REM Draws a bar chart from the array "values" of size nValues. 
400 REM Turtleizer must be activated and will scale the chart into a square of 
410 REM 500 x 500 pixels 
420 REM Note: The function is not robust against empty array or totally equal values. 
430 REM TODO: Add type-specific suffixes where necessary! 
440 SUB drawBarChart(values AS double(50), nValues)
450   REM TODO: add the respective type suffixes to your variable names if required 
460   REM  
470   REM  
480   REM Used range of the Turtleizer screen 
490   LET xSize = 500
500   LET ySize = 500
510   LET kMin = 0
520   LET kMax = 0
530   FOR k = 1 TO nValues-1
540     IF values(k) > values(kMax) THEN
550       LET kMax = k
560     ELSE
570       IF values(k) < values(kMin) THEN
580         LET kMin = k
590       END IF
600     END IF
610   NEXT k
620   LET valMin = values(kMin)
630   LET valMax = values(kMax)
640   LET yScale = valMax * 1.0 / (ySize - 1)
650   LET yAxis = ySize - 1
660   IF valMin < 0 THEN
670     IF valMax > 0 THEN
680       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
690       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
700     ELSE
710       LET yAxis = 1
720       LET yScale = valMin * 1.0 / (ySize - 1)
730     END IF
740   END IF
750   REM draw coordinate axes 
760   gotoXY(1, ySize - 1)
770   forward(ySize -1) : REM color = ffffff
780   penUp()
790   backward(yAxis) : REM color = ffffff
800   right(90)
810   penDown()
820   forward(xSize -1) : REM color = ffffff
830   penUp()
840   backward(xSize-1) : REM color = ffffff
850   LET stripeWidth = xSize / nValues
860   FOR k = 0 TO nValues-1
870     LET stripeHeight = values(k) * 1.0 / yScale
880     SELECT CASE k % 3
890       CASE 0
900         setPenColor(255,0,0)
910       CASE 1
920         setPenColor(0, 255,0)
930       CASE 2
940         setPenColor(0, 0, 255)
950     END SELECT
960     fd(1) : REM color = ffffff
970     left(90)
980     penDown()
990     fd(stripeHeight) : REM color = ffffff
1000     right(90)
1010     fd(stripeWidth - 1) : REM color = ffffff
1020     right(90)
1030     forward(stripeHeight) : REM color = ffffff
1040     left(90)
1050     penUp()
1060   NEXT k
1070 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1080 REM ======= 8< =========================================================== 
1090 
1100 REM Computes the sum and average of the numbers read from a user-specified 
1110 REM text file (which might have been created via generateRandomNumberFile(4)). 
1120 REM  
1130 REM This program is part of an arrangement used to test group code export (issue 
1140 REM #828) with FileAPI dependency. 
1150 REM The input check loop has been disabled (replaced by a simple unchecked input 
1160 REM instruction) in order to test the effect of indirect FileAPI dependency (only the 
1170 REM called subroutine directly requires FileAPI now). 
1180 REM Generated by Structorizer 3.32-32 
1190 
1200 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1210 REM License: GPLv3-link 
1220 REM GNU General Public License (V 3) 
1230 REM https://www.gnu.org/licenses/gpl.html 
1240 REM http://www.gnu.de/documents/gpl.de.html 
1250 
1260 REM  
1270 REM program ComputeSum
1280 REM TODO: add the respective type suffixes to your variable names if required 
1290 DIM values() AS ???
1300 REM  
1310 LET fileNo = 1000
1320 REM Disable this if you enable the loop below! 
1330 PRINT "Name/path of the number file"; : INPUT file_name
1340 REM If you enable this loop, then the preceding input instruction is to be disabled 
1350 REM and the fileClose instruction in the alternative below is to be enabled. 
1360 REM DO 
1370 REM   PRINT "Name/path of the number file"; : INPUT file_name 
1380 REM   LET fileNo = fileOpen(file_name) 
1390 REM LOOP UNTIL fileNo > 0 OR file_name = "" 
1400 IF fileNo > 0 THEN
1410   REM This should be enabled if the input check loop above gets enabled. 
1420 REM   fileClose(fileNo) 
1430   LET nValues = 0
1440   ON ERROR GOTO 1480
1450   LET nValues = readNumbers(file_name, values, 1000)
1460   GOTO 1520
1470   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1480     PRINT failure
1490     REM FIXME: The following exit code was intended to pass: -7 
1500     STOP
1510   REM End of error handler, resume here ... 
1520   ON ERROR GOTO 0
1530   LET sum = 0.0
1540   FOR k = 0 TO nValues-1
1550     LET sum = sum + values(k)
1560   NEXT k
1570   PRINT "sum = "; sum
1580   PRINT "average = "; sum / nValues
1590 END IF
1600 END

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1610 REM ======= 8< =========================================================== 
1620 
1630 REM Reads a random number file and draws a histogram accotrding to the 
1640 REM user specifications 
1650 REM Generated by Structorizer 3.32-32 
1660 
1670 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1680 REM License: GPLv3-link 
1690 REM GNU General Public License (V 3) 
1700 REM https://www.gnu.org/licenses/gpl.html 
1710 REM http://www.gnu.de/documents/gpl.de.html 
1720 
1730 REM  
1740 REM program DrawRandomHistogram
1750 REM TODO: add the respective type suffixes to your variable names if required 
1760 DIM numberArray() AS ???
1770 DIM count() AS Integer
1780 REM  
1790 LET fileNo = -10
1800 DO
1810   PRINT "Name/path of the number file"; : INPUT file_name
1820   LET fileNo = fileOpen(file_name)
1830 LOOP UNTIL fileNo > 0 OR file_name = ""
1840 IF fileNo > 0 THEN
1850   fileClose(fileNo)
1860   PRINT "number of intervals"; : INPUT nIntervals
1870   REM Initialize the interval counters 
1880   FOR k = 0 TO nIntervals-1
1890     LET count(k) = 0
1900   NEXT k
1910   REM Index of the most populated interval 
1920   LET kMaxCount = 0
1930   LET nObtained = 0
1940   ON ERROR GOTO 1980
1950   LET nObtained = readNumbers(file_name, numberArray, 10000)
1960   GOTO 2000
1970   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1980     PRINT failure
1990   REM End of error handler, resume here ... 
2000   ON ERROR GOTO 0
2010   IF nObtained > 0 THEN
2020     LET min = numberArray(0)
2030     LET max = numberArray(0)
2040     FOR i = 1 TO nObtained-1
2050       IF numberArray(i) < min THEN
2060         LET min = numberArray(i)
2070       ELSE
2080         IF numberArray(i) > max THEN
2090           LET max = numberArray(i)
2100         END IF
2110       END IF
2120     NEXT i
2130     REM Interval width 
2140     LET width = (max - min) * 1.0 / nIntervals
2150     FOR i = 0 TO nObtained - 1
2160       LET value = numberArray(i)
2170       LET k = 1
2180       DO WHILE k < nIntervals AND value > min + k * width
2190         LET k = k + 1
2200       LOOP
2210       LET count(k-1) = count(k-1) + 1
2220       IF count(k-1) > count(kMaxCount) THEN
2230         LET kMaxCount = k-1
2240       END IF
2250     NEXT i
2260     CALL drawBarChart(count, nIntervals)
2270     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
2280     FOR k = 0 TO nIntervals-1
2290       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
2300     NEXT k
2310   ELSE
2320     PRINT "No numbers read."
2330   END IF
2340 END IF
2350 END
2360 REM  
2370 REM Draws a bar chart from the array "values" of size nValues. 
2380 REM Turtleizer must be activated and will scale the chart into a square of 
2390 REM 500 x 500 pixels 
2400 REM Note: The function is not robust against empty array or totally equal values. 
2410 REM TODO: Add type-specific suffixes where necessary! 
2420 SUB drawBarChart(values AS double(50), nValues)
2430   REM TODO: add the respective type suffixes to your variable names if required 
2440   REM  
2450   REM  
2460   REM Used range of the Turtleizer screen 
2470   LET xSize = 500
2480   LET ySize = 500
2490   LET kMin = 0
2500   LET kMax = 0
2510   FOR k = 1 TO nValues-1
2520     IF values(k) > values(kMax) THEN
2530       LET kMax = k
2540     ELSE
2550       IF values(k) < values(kMin) THEN
2560         LET kMin = k
2570       END IF
2580     END IF
2590   NEXT k
2600   LET valMin = values(kMin)
2610   LET valMax = values(kMax)
2620   LET yScale = valMax * 1.0 / (ySize - 1)
2630   LET yAxis = ySize - 1
2640   IF valMin < 0 THEN
2650     IF valMax > 0 THEN
2660       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
2670       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
2680     ELSE
2690       LET yAxis = 1
2700       LET yScale = valMin * 1.0 / (ySize - 1)
2710     END IF
2720   END IF
2730   REM draw coordinate axes 
2740   gotoXY(1, ySize - 1)
2750   forward(ySize -1) : REM color = ffffff
2760   penUp()
2770   backward(yAxis) : REM color = ffffff
2780   right(90)
2790   penDown()
2800   forward(xSize -1) : REM color = ffffff
2810   penUp()
2820   backward(xSize-1) : REM color = ffffff
2830   LET stripeWidth = xSize / nValues
2840   FOR k = 0 TO nValues-1
2850     LET stripeHeight = values(k) * 1.0 / yScale
2860     SELECT CASE k % 3
2870       CASE 0
2880         setPenColor(255,0,0)
2890       CASE 1
2900         setPenColor(0, 255,0)
2910       CASE 2
2920         setPenColor(0, 0, 255)
2930     END SELECT
2940     fd(1) : REM color = ffffff
2950     left(90)
2960     penDown()
2970     fd(stripeHeight) : REM color = ffffff
2980     right(90)
2990     fd(stripeWidth - 1) : REM color = ffffff
3000     right(90)
3010     forward(stripeHeight) : REM color = ffffff
3020     left(90)
3030     penUp()
3040   NEXT k
3050 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

