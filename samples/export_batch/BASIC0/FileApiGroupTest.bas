10 REM Tries to read as many integer values as possible upto maxNumbers 
20 REM from file fileName into the given array numbers. 
30 REM Returns the number of the actually read numbers. May cause an exception. 
40 REM Generated by Structorizer 3.32-26 
50 
60 REM Copyright (C) 2020-03-21 Kay Gürtzig 
70 REM License: GPLv3-link 
80 REM GNU General Public License (V 3) 
90 REM https://www.gnu.org/licenses/gpl.html 
100 REM http://www.gnu.de/documents/gpl.de.html 
110 
120 REM  
130 REM TODO: Add type-specific suffixes where necessary! 
140 FUNCTION readNumbers(fileName AS String, numbers AS integer(50), maxNumbers AS integer) AS integer
150   REM TODO: add the respective type suffixes to your variable names if required 
160   REM  
170   LET nNumbers = 0
180   LET fileNo = fileOpen(fileName)
190   IF fileNo <= 0 THEN
200     REM FIXME: Only a number is allowed as parameter: 
210     ERROR "File could not be opened!"
220   END IF
230   ON ERROR GOTO 320
240   DO WHILE NOT fileEOF(fileNo) AND nNumbers < maxNumbers
250     LET number = fileReadInt(fileNo)
260     DIM numbers() AS integer
270     LET numbers(nNumbers) = number
280     LET nNumbers = nNumbers + 1
290   LOOP
300   GOTO 350
310   REM Start of error handler, FIXME: variable 'error' should conatain error info ... 
320     REM FIXME: Only a number is allowed as parameter: 
330     ERROR 
340   REM End of error handler, resume here ... 
350   ON ERROR GOTO 0
360   fileClose(fileNo)
370   RETURN nNumbers
380 END FUNCTION
390 REM  
400 REM Draws a bar chart from the array "values" of size nValues. 
410 REM Turtleizer must be activated and will scale the chart into a square of 
420 REM 500 x 500 pixels 
430 REM Note: The function is not robust against empty array or totally equal values. 
440 REM TODO: Add type-specific suffixes where necessary! 
450 SUB drawBarChart(values AS double(50), nValues)
460   REM TODO: add the respective type suffixes to your variable names if required 
470   REM  
480   REM  
490   REM Used range of the Turtleizer screen 
500   LET xSize = 500
510   LET ySize = 500
520   LET kMin = 0
530   LET kMax = 0
540   FOR k = 1 TO nValues-1
550     IF values(k) > values(kMax) THEN
560       LET kMax = k
570     ELSE
580       IF values(k) < values(kMin) THEN
590         LET kMin = k
600       END IF
610     END IF
620   NEXT k
630   LET valMin = values(kMin)
640   LET valMax = values(kMax)
650   LET yScale = valMax * 1.0 / (ySize - 1)
660   LET yAxis = ySize - 1
670   IF valMin < 0 THEN
680     IF valMax > 0 THEN
690       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
700       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
710     ELSE
720       LET yAxis = 1
730       LET yScale = valMin * 1.0 / (ySize - 1)
740     END IF
750   END IF
760   REM draw coordinate axes 
770   gotoXY(1, ySize - 1)
780   forward(ySize -1) : REM color = ffffff
790   penUp()
800   backward(yAxis) : REM color = ffffff
810   right(90)
820   penDown()
830   forward(xSize -1) : REM color = ffffff
840   penUp()
850   backward(xSize-1) : REM color = ffffff
860   LET stripeWidth = xSize / nValues
870   FOR k = 0 TO nValues-1
880     LET stripeHeight = values(k) * 1.0 / yScale
890     SELECT CASE k % 3
900       CASE 0
910         setPenColor(255,0,0)
920       CASE 1
930         setPenColor(0, 255,0)
940       CASE 2
950         setPenColor(0, 0, 255)
960     END SELECT
970     fd(1) : REM color = ffffff
980     left(90)
990     penDown()
1000     fd(stripeHeight) : REM color = ffffff
1010     right(90)
1020     fd(stripeWidth - 1) : REM color = ffffff
1030     right(90)
1040     forward(stripeHeight) : REM color = ffffff
1050     left(90)
1060     penUp()
1070   NEXT k
1080 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1090 REM ======= 8< =========================================================== 
1100 
1110 REM Computes the sum and average of the numbers read from a user-specified 
1120 REM text file (which might have been created via generateRandomNumberFile(4)). 
1130 REM  
1140 REM This program is part of an arrangement used to test group code export (issue 
1150 REM #828) with FileAPI dependency. 
1160 REM The input check loop has been disabled (replaced by a simple unchecked input 
1170 REM instruction) in order to test the effect of indirect FileAPI dependency (only the 
1180 REM called subroutine directly requires FileAPI now). 
1190 REM Generated by Structorizer 3.32-26 
1200 
1210 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1220 REM License: GPLv3-link 
1230 REM GNU General Public License (V 3) 
1240 REM https://www.gnu.org/licenses/gpl.html 
1250 REM http://www.gnu.de/documents/gpl.de.html 
1260 
1270 REM  
1280 REM program ComputeSum
1290 REM TODO: add the respective type suffixes to your variable names if required 
1300 DIM values() AS ???
1310 REM  
1320 LET fileNo = 1000
1330 REM Disable this if you enable the loop below! 
1340 PRINT "Name/path of the number file"; : INPUT file_name
1350 REM If you enable this loop, then the preceding input instruction is to be disabled 
1360 REM and the fileClose instruction in the alternative below is to be enabled. 
1370 REM DO 
1380 REM   PRINT "Name/path of the number file"; : INPUT file_name 
1390 REM   LET fileNo = fileOpen(file_name) 
1400 REM LOOP UNTIL fileNo > 0 OR file_name = "" 
1410 IF fileNo > 0 THEN
1420   REM This should be enabled if the input check loop above gets enabled. 
1430 REM   fileClose(fileNo) 
1440   LET nValues = 0
1450   ON ERROR GOTO 1490
1460   LET nValues = readNumbers(file_name, values, 1000)
1470   GOTO 1520
1480   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1490     PRINT failure
1500     STOP
1510   REM End of error handler, resume here ... 
1520   ON ERROR GOTO 0
1530   LET sum = 0.0
1540   FOR k = 0 TO nValues-1
1550     LET sum = sum + values(k)
1560   NEXT k
1570   PRINT "sum = "; sum
1580   PRINT "average = "; sum / nValues
1590 END IF
1600 END

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

1610 REM ======= 8< =========================================================== 
1620 
1630 REM Reads a random number file and draws a histogram accotrding to the 
1640 REM user specifications 
1650 REM Generated by Structorizer 3.32-26 
1660 
1670 REM Copyright (C) 2020-03-21 Kay Gürtzig 
1680 REM License: GPLv3-link 
1690 REM GNU General Public License (V 3) 
1700 REM https://www.gnu.org/licenses/gpl.html 
1710 REM http://www.gnu.de/documents/gpl.de.html 
1720 
1730 REM  
1740 REM program DrawRandomHistogram
1750 REM TODO: add the respective type suffixes to your variable names if required 
1760 DIM numberArray() AS ???
1770 DIM count() AS Integer
1780 REM  
1790 LET fileNo = -10
1800 DO
1810   PRINT "Name/path of the number file"; : INPUT file_name
1820   LET fileNo = fileOpen(file_name)
1830 LOOP UNTIL fileNo > 0 OR file_name = ""
1840 IF fileNo > 0 THEN
1850   fileClose(fileNo)
1860   PRINT "number of intervals"; : INPUT nIntervals
1870   REM Initialize the interval counters 
1880   FOR k = 0 TO nIntervals-1
1890     LET count(k) = 0
1900   NEXT k
1910   REM Index of the most populated interval 
1920   LET kMaxCount = 0
1930   LET nObtained = 0
1940   ON ERROR GOTO 1980
1950   LET nObtained = readNumbers(file_name, numberArray, 10000)
1960   GOTO 2000
1970   REM Start of error handler, FIXME: variable 'failure' should conatain error info ... 
1980     PRINT failure
1990   REM End of error handler, resume here ... 
2000   ON ERROR GOTO 0
2010   IF nObtained > 0 THEN
2020     LET min = numberArray(0)
2030     LET max = numberArray(0)
2040     FOR i = 1 TO nObtained-1
2050       IF numberArray(i) < min THEN
2060         LET min = numberArray(i)
2070       ELSE
2080         IF numberArray(i) > max THEN
2090           LET max = numberArray(i)
2100         END IF
2110       END IF
2120     NEXT i
2130     REM Interval width 
2140     LET width = (max - min) * 1.0 / nIntervals
2150     FOR i = 0 TO nObtained - 1
2160       LET value = numberArray(i)
2170       LET k = 1
2180       DO WHILE k < nIntervals AND value > min + k * width
2190         LET k = k + 1
2200       LOOP
2210       LET count(k-1) = count(k-1) + 1
2220       IF count(k-1) > count(kMaxCount) THEN
2230         LET kMaxCount = k-1
2240       END IF
2250     NEXT i
2260     CALL drawBarChart(count, nIntervals)
2270     PRINT "Interval with max count: "; kMaxCount; " ("; count(kMaxCount); ")"
2280     FOR k = 0 TO nIntervals-1
2290       PRINT count(k); " numbers in interval "; k; " ("; min + k * width; " ... "; min + (k+1) * width; ")"
2300     NEXT k
2310   ELSE
2320     PRINT "No numbers read."
2330   END IF
2340 END IF
2350 END
2360 REM  
2370 REM Draws a bar chart from the array "values" of size nValues. 
2380 REM Turtleizer must be activated and will scale the chart into a square of 
2390 REM 500 x 500 pixels 
2400 REM Note: The function is not robust against empty array or totally equal values. 
2410 REM TODO: Add type-specific suffixes where necessary! 
2420 SUB drawBarChart(values AS double(50), nValues)
2430   REM TODO: add the respective type suffixes to your variable names if required 
2440   REM  
2450   REM  
2460   REM Used range of the Turtleizer screen 
2470   LET xSize = 500
2480   LET ySize = 500
2490   LET kMin = 0
2500   LET kMax = 0
2510   FOR k = 1 TO nValues-1
2520     IF values(k) > values(kMax) THEN
2530       LET kMax = k
2540     ELSE
2550       IF values(k) < values(kMin) THEN
2560         LET kMin = k
2570       END IF
2580     END IF
2590   NEXT k
2600   LET valMin = values(kMin)
2610   LET valMax = values(kMax)
2620   LET yScale = valMax * 1.0 / (ySize - 1)
2630   LET yAxis = ySize - 1
2640   IF valMin < 0 THEN
2650     IF valMax > 0 THEN
2660       LET yAxis = valMax * ySize * 1.0 / (valMax - valMin)
2670       LET yScale = (valMax - valMin) * 1.0 / (ySize - 1)
2680     ELSE
2690       LET yAxis = 1
2700       LET yScale = valMin * 1.0 / (ySize - 1)
2710     END IF
2720   END IF
2730   REM draw coordinate axes 
2740   gotoXY(1, ySize - 1)
2750   forward(ySize -1) : REM color = ffffff
2760   penUp()
2770   backward(yAxis) : REM color = ffffff
2780   right(90)
2790   penDown()
2800   forward(xSize -1) : REM color = ffffff
2810   penUp()
2820   backward(xSize-1) : REM color = ffffff
2830   LET stripeWidth = xSize / nValues
2840   FOR k = 0 TO nValues-1
2850     LET stripeHeight = values(k) * 1.0 / yScale
2860     SELECT CASE k % 3
2870       CASE 0
2880         setPenColor(255,0,0)
2890       CASE 1
2900         setPenColor(0, 255,0)
2910       CASE 2
2920         setPenColor(0, 0, 255)
2930     END SELECT
2940     fd(1) : REM color = ffffff
2950     left(90)
2960     penDown()
2970     fd(stripeHeight) : REM color = ffffff
2980     right(90)
2990     fd(stripeWidth - 1) : REM color = ffffff
3000     right(90)
3010     forward(stripeHeight) : REM color = ffffff
3020     left(90)
3030     penUp()
3040   NEXT k
3050 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

