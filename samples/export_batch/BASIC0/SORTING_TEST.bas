10 REM Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
20 REM to allow performance comparison via execution counting ("Collect Runtime Data" should 
30 REM sensibly be switched on). 
40 REM Requested input data are: Number of elements (size) and filing mode. 
50 REM Generated by Structorizer 3.32-26 
60 
70 REM Copyright (C) 2019-10-02 Kay Gürtzig 
80 REM License: GPLv3-link 
90 REM GNU General Public License (V 3) 
100 REM https://www.gnu.org/licenses/gpl.html 
110 REM http://www.gnu.de/documents/gpl.de.html 
120 
130 REM  
140 REM program SORTING_TEST_MAIN
150 REM TODO: add the respective type suffixes to your variable names if required 
160 DIM values3() AS Integer
170 DIM values2() AS Integer
180 DIM values1() AS Integer
190 REM  
200 DO
210   INPUT elementCount
220 LOOP UNTIL elementCount >= 1
230 DO
240   PRINT "Filling: 1 = random, 2 = increasing, 3 = decreasing"; : INPUT modus
250 LOOP UNTIL modus = 1 OR modus = 2 OR modus = 3
260 FOR i = 0 TO elementCount-1
270   SELECT CASE modus
280     CASE 1
290       LET values1(i) = random(10000)
300     CASE 2
310       LET values1(i) = i
320     CASE 3
330       LET values1(i) = -i
340   END SELECT
350 NEXT i
360 REM Copy the array for exact comparability 
370 FOR i = 0 TO elementCount-1
380   LET values2(i) = values1(i)
390   LET values3(i) = values1(i)
400 NEXT i
410 
420 REM ========================================================== 
430 REM ================= START PARALLEL SECTION ================= 
440 REM ========================================================== 
450 REM TODO: add the necessary code to run the threads concurrently 
460 
470   REM ----------------- START THREAD 0 ----------------- 
480     CALL bubbleSort(values1)
490   REM ------------------ END THREAD 0 ------------------ 
500 
510 
520   REM ----------------- START THREAD 1 ----------------- 
530     CALL quickSort(values2, 0, elementCount)
540   REM ------------------ END THREAD 1 ------------------ 
550 
560 
570   REM ----------------- START THREAD 2 ----------------- 
580     CALL heapSort(values3)
590   REM ------------------ END THREAD 2 ------------------ 
600 
610 REM ========================================================== 
620 REM ================== END PARALLEL SECTION ================== 
630 REM ========================================================== 
640 
650 LET ok1 = testSorted(values1)
660 LET ok2 = testSorted(values2)
670 LET ok3 = testSorted(values3)
680 IF NOT ok1 OR NOT ok2 OR NOT ok3 THEN
690   FOR i = 0 TO elementCount-1
700     IF values1(i) <> values2(i) OR values1(i) <> values3(i) THEN
710       PRINT "Difference at ["; i; "]: "; values1(i); " <-> "; values2(i); " <-> "; values3(i)
720     END IF
730   NEXT i
740 END IF
750 DO
760   PRINT "Show arrays (yes/no)?"; : INPUT show
770 LOOP UNTIL show = "yes" OR show = "no"
780 IF show = "yes" THEN
790   FOR i = 0 TO elementCount - 1
800     PRINT "["; i; "]:\t"; values1(i); "\t"; values2(i); "\t"; values3(i)
810   NEXT i
820 END IF
830 END
840 REM  
850 REM Implements the well-known BubbleSort algorithm. 
860 REM Compares neigbouring elements and swaps them in case of an inversion. 
870 REM Repeats this while inversions have been found. After every 
880 REM loop passage at least one element (the largest one out of the 
890 REM processed subrange) finds its final place at the end of the 
900 REM subrange. 
910 REM TODO: Add type-specific suffixes where necessary! 
920 SUB bubbleSort(values)
930   REM TODO: add the respective type suffixes to your variable names if required 
940   REM  
950   REM  
960   LET ende = length(values) - 2
970   DO
980     REM The index of the most recent swapping (-1 means no swapping done). 
990     LET posSwapped = -1
1000     FOR i = 0 TO ende
1010       IF values(i) > values(i+1) THEN
1020         LET temp = values(i)
1030         DIM values() AS ???
1040         LET values(i) = values(i+1)
1050         LET values(i+1) = temp
1060         LET posSwapped = i
1070       END IF
1080     NEXT i
1090     LET ende = posSwapped - 1
1100   LOOP UNTIL posSwapped < 0
1110 END SUB
1120 REM  
1130 REM Given a max-heap 'heap´ with element at index 'i´ possibly 
1140 REM violating the heap property wrt. its subtree upto and including 
1150 REM index range-1, restores heap property in the subtree at index i 
1160 REM again. 
1170 REM TODO: Add type-specific suffixes where necessary! 
1180 SUB maxHeapify(heap, i, range)
1190   REM TODO: add the respective type suffixes to your variable names if required 
1200   REM  
1210   REM  
1220   REM Indices of left and right child of node i 
1230   LET right = (i+1) * 2
1240   LET left = right - 1
1250   REM Index of the (local) maximum 
1260   LET max = i
1270   IF left < range AND heap(left) > heap(i) THEN
1280     LET max = left
1290   END IF
1300   IF right < range AND heap(right) > heap(max) THEN
1310     LET max = right
1320   END IF
1330   IF max <> i THEN
1340     LET temp = heap(i)
1350     DIM heap() AS ???
1360     LET heap(i) = heap(max)
1370     LET heap(max) = temp
1380     CALL maxHeapify(heap, max, range)
1390   END IF
1400 END SUB
1410 REM  
1420 REM Partitions array 'values´ between indices 'start´ und 'stop´-1 with 
1430 REM respect to the pivot element initially at index 'p´ into smaller 
1440 REM and greater elements. 
1450 REM Returns the new (and final) index of the pivot element (which 
1460 REM separates the sequence of smaller elements from the sequence 
1470 REM of greater elements). 
1480 REM This is not the most efficient algorithm (about half the swapping 
1490 REM might still be avoided) but it is pretty clear. 
1500 REM TODO: Add type-specific suffixes where necessary! 
1510 FUNCTION partition(values, start, stop, p) AS Integer
1520   REM TODO: add the respective type suffixes to your variable names if required 
1530   REM  
1540   REM  
1550   REM Cache the pivot element 
1560   LET pivot = values(p)
1570   REM Exchange the pivot element with the start element 
1580   DIM values() AS ???
1590   LET values(p) = values(start)
1600   LET values(start) = pivot
1610   LET p = start
1620   REM Beginning and end of the remaining undiscovered range 
1630   LET start = start + 1
1640   LET stop = stop - 1
1650   REM Still unseen elements? 
1660   REM Loop invariants: 
1670   REM 1. p = start - 1 
1680   REM 2. pivot = values[p] 
1690   REM 3. i < start → values[i] ≤ pivot 
1700   REM 4. stop < i → pivot < values[i] 
1710   DO WHILE start <= stop
1720     REM Fetch the first element of the undiscovered area 
1730     LET seen = values(start)
1740     REM Does the checked element belong to the smaller area? 
1750     IF seen <= pivot THEN
1760       REM Insert the seen element between smaller area and pivot element 
1770       LET values(p) = seen
1780       LET values(start) = pivot
1790       REM Shift the border between lower and undicovered area, 
1800       REM update pivot position. 
1810       LET p = p + 1
1820       LET start = start + 1
1830     ELSE
1840       REM Insert the checked element between undiscovered and larger area 
1850       LET values(start) = values(stop)
1860       LET values(stop) = seen
1870       REM Shift the border between undiscovered and larger area 
1880       LET stop = stop - 1
1890     END IF
1900   LOOP
1910   return p
1920 END FUNCTION
1930 REM  
1940 REM Checks whether or not the passed-in array is (ascendingly) sorted. 
1950 REM TODO: Add type-specific suffixes where necessary! 
1960 FUNCTION testSorted(numbers) AS bool
1970   REM TODO: add the respective type suffixes to your variable names if required 
1980   REM  
1990   REM  
2000   LET isSorted = true
2010   LET i = 0
2020   REM As we compare with the following element, we must stop at the penultimate index 
2030   DO WHILE isSorted AND (i <= length(numbers)-2)
2040     REM Is there an inversion? 
2050     IF numbers(i) > numbers(i+1) THEN
2060       LET isSorted = false
2070     ELSE
2080       LET i = i + 1
2090     END IF
2100   LOOP
2110   return isSorted
2120 END FUNCTION
2130 REM  
2140 REM Runs through the array heap and converts it to a max-heap 
2150 REM in a bottom-up manner, i.e. starts above the "leaf" level 
2160 REM (index >= length(heap) div 2) and goes then up towards 
2170 REM the root. 
2180 REM TODO: Add type-specific suffixes where necessary! 
2190 SUB buildMaxHeap(heap)
2200   REM TODO: add the respective type suffixes to your variable names if required 
2210   REM  
2220   REM  
2230   LET lgth = length(heap)
2240   FOR k = lgth / 2 - 1 TO 0 STEP -1
2250     CALL maxHeapify(heap, k, lgth)
2260   NEXT k
2270 END SUB
2280 REM  
2290 REM Recursively sorts a subrange of the given array 'values´.  
2300 REM start is the first index of the subsequence to be sorted, 
2310 REM stop is the index BEHIND the subsequence to be sorted. 
2320 REM TODO: Add type-specific suffixes where necessary! 
2330 SUB quickSort(values, start, stop)
2340   REM TODO: add the respective type suffixes to your variable names if required 
2350   REM  
2360   REM  
2370   REM At least 2 elements? (Less don't make sense.) 
2380   IF stop >= start + 2 THEN
2390     REM Select a pivot element, be p its index. 
2400     REM (here: randomly chosen element out of start ... stop-1) 
2410     LET p = random(stop-start) + start
2420     REM Partition the array into smaller and greater elements 
2430     REM Get the resulting (and final) position of the pivot element 
2440     LET p = partition(values, start, stop, p)
2450     REM Sort subsequances separately and independently ... 
2460 
2470     REM ========================================================== 
2480     REM ================= START PARALLEL SECTION ================= 
2490     REM ========================================================== 
2500     REM TODO: add the necessary code to run the threads concurrently 
2510 
2520       REM ----------------- START THREAD 0 ----------------- 
2530         REM Sort left (lower) array part 
2540         CALL quickSort(values, start, p)
2550       REM ------------------ END THREAD 0 ------------------ 
2560 
2570 
2580       REM ----------------- START THREAD 1 ----------------- 
2590         REM Sort right (higher) array part 
2600         CALL quickSort(values, p+1, stop)
2610       REM ------------------ END THREAD 1 ------------------ 
2620 
2630     REM ========================================================== 
2640     REM ================== END PARALLEL SECTION ================== 
2650     REM ========================================================== 
2660 
2670   END IF
2680 END SUB
2690 REM  
2700 REM Sorts the array 'values´ of numbers according to he heap sort 
2710 REM algorithm 
2720 REM TODO: Add type-specific suffixes where necessary! 
2730 SUB heapSort(values)
2740   REM TODO: add the respective type suffixes to your variable names if required 
2750   REM  
2760   REM  
2770   CALL buildMaxHeap(values)
2780   LET heapRange = length(values)
2790   FOR k = heapRange - 1 TO 1 STEP -1
2800     LET heapRange = heapRange - 1
2810     REM Swap the maximum value (root of the heap) to the heap end 
2820     LET maximum = values(0)
2830     DIM values() AS ???
2840     LET values(0) = values(heapRange)
2850     LET values(heapRange) = maximum
2860     CALL maxHeapify(values, 0, heapRange)
2870   NEXT k
2880 END SUB

REM = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

