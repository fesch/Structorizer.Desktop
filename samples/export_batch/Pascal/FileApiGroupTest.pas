UNIT FileApiGroupTest;
{ Generated by Structorizer 3.30-11 }

{ Copyright (C) 2020-03-21 Kay Gürtzig }
{ License: GPLv3-link }
{
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
}

INTERFACE
uses StructorizerFileAPI;

{
  Tries to read as many integer values as possible upto maxNumbers
  from file fileName into the given array numbers.
  Returns the number of the actually read numbers. May cause an exception.
}
var
  number: Longint;
  nNumbers: Longint;
  fileNo: Longint;
  error: Exception;

{
* Tries to read as many integer values as possible upto maxNumbers
* from file fileName into the given array numbers.
* Returns the number of the actually read numbers. May cause an exception.
}
function readNumbers(fileName: string; numbers: array [0..49] of Longint; maxNumbers: Longint): Longint;

IMPLEMENTATION

{
* Draws a bar chart from the array "values" of size nValues.
* Turtleizer must be activated and will scale the chart into a square of
* 500 x 500 pixels
* Note: The function is not robust against empty array or totally equal values.
}
procedure drawBarChart(values: array [0..49] of Double; nValues: ???);

const
  xSize = 500;
  ySize = 500;

var
  yScale: ???;	{ FIXME! }
  yAxis: ???;	{ FIXME! }
  valMin: ???;	{ FIXME! }
  valMax: ???;	{ FIXME! }
  stripeWidth: ???;	{ FIXME! }
  stripeHeight: ???;	{ FIXME! }
  kMin: Longint;
  kMax: Longint;
  k: Longint;

begin
  kMin := 0;
  kMax := 0;
  for k := 1 to nValues-1 do
  begin
    if (values[k] > values[kMax]) then
    begin
      kMax := k;
    end
    else
    begin
      if (values[k] < values[kMin]) then
      begin
        kMin := k;
      end;
    end;
  end;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  if (valMin < 0) then
  begin
    if (valMax > 0) then
    begin
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    end
    else
    begin
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    end;
  end;
  { draw coordinate axes }
  gotoXY(1, ySize - 1);
  forward(ySize -1); { color = ffffff }
  penUp();
  backward(yAxis); { color = ffffff }
  right(90);
  penDown();
  forward(xSize -1); { color = ffffff }
  penUp();
  backward(xSize-1); { color = ffffff }
  stripeWidth := xSize / nValues;
  for k := 0 to nValues-1 do
  begin
    stripeHeight := values[k] * 1.0 / yScale;
    case (k mod 3) of
      0:
        begin
          setPenColor(255,0,0);
        end;
      1:
        begin
          setPenColor(0, 255,0);
        end;
      2:
        begin
          setPenColor(0, 0, 255);
        end;
    end;
    fd(1); { color = ffffff }
    left(90);
    penDown();
    fd(stripeHeight); { color = ffffff }
    right(90);
    fd(stripeWidth - 1); { color = ffffff }
    right(90);
    forward(stripeHeight); { color = ffffff }
    left(90);
    penUp();
  end;

end;

{ = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = }


function readNumbers(fileName: string; numbers: array [0..49] of Longint; maxNumbers: Longint): Longint;

begin
  nNumbers := 0;
  assign(fileNo, fileName); open(fileNo);
  { TODO: Consider replacing this file test using IOResult! }
  if (fileNo <= 0) then
  begin
    raise Exception.Create('File could not be opened!');
  end;
  try
    try
      while (not eof(fileNo) and nNumbers < maxNumbers) do
      begin
        number := fileReadInt(fileNo);
        numbers[nNumbers] := number;
        nNumbers := nNumbers + 1;
      end;
    except
      on Ex : Exception do
      begin
        { FIXME: Ensure a declaration for variable error (String) in the VAR block! }
        error := Ex.Message;
        raise Exception.Create();
      end;
    end;
  finally
    closeFile(fileNo);
  end;
  readNumbers := nNumbers;

end;


BEGIN
  
END.

{ ======= 8< =========================================================== }

{
  Computes the sum and average of the numbers read from a user-specified
  text file (which might have been created via generateRandomNumberFile(4)).
  
  This program is part of an arrangement used to test group code export (issue
  #828) with FileAPI dependency.
  The input check loop has been disabled (replaced by a simple unchecked input
  instruction) in order to test the effect of indirect FileAPI dependency (only the
  called subroutine directly requires FileAPI now).
}
program ComputeSum;
{ Generated by Structorizer 3.30-11 }

{ Copyright (C) 2020-03-21 Kay Gürtzig }
{ License: GPLv3-link }
{
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
}

uses FileApiGroupTest;

var
  values: array [0..49] of ???;	{ FIXME! }
  sum: Double;
  nValues: Longint;
  k: Longint;
  { Disable this if you enable the loop below! }
  file_name: ???;	{ FIXME! }
  fileNo: Longint;
  failure: Exception;

{ = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = }


begin
  fileNo := 1000;
  { Disable this if you enable the loop below! }
  write('Name/path of the number file'); readln(file_name);
  {
    If you enable this loop, then the preceding input instruction is to be disabled
    and the fileClose instruction in the alternative below is to be enabled.
  }
{   repeat }
{     write('Name/path of the number file'); readln(file_name); }
{     assign(fileNo, file_name); open(fileNo); }
{     until (fileNo > 0 or file_name = ''); }
  if (fileNo > 0) then
  begin
    { This should be enabled if the input check loop above gets enabled. }
{     closeFile(fileNo); }
    { Hint: Automatically decomposed array initialization }
    nValues := 0;
    try
      nValues := readNumbers(file_name, values, 1000);
    except
      on Ex : Exception do
      begin
        { FIXME: Ensure a declaration for variable failure (String) in the VAR block! }
        failure := Ex.Message;
        writeln(failure);
        halt(-7);
      end;
    end;
    sum := 0.0;
    for k := 0 to nValues-1 do
    begin
      sum := sum + values[k];
    end;
    writeln('sum = ', sum);
    writeln('average = ', sum / nValues);
  end;
end.

{ ======= 8< =========================================================== }

{
  Reads a random number file and draws a histogram accotrding to the
  user specifications
}
program DrawRandomHistogram;
{ Generated by Structorizer 3.30-11 }

{ Copyright (C) 2020-03-21 Kay Gürtzig }
{ License: GPLv3-link }
{
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
}

uses FileApiGroupTest,StructorizerFileAPI;

var
  { Interval width }
  width: ???;	{ FIXME! }
  value: ???;	{ FIXME! }
  numberArray: array [0..49] of ???;	{ FIXME! }
  nObtained: Longint;
  nIntervals: ???;	{ FIXME! }
  min: ???;	{ FIXME! }
  max: ???;	{ FIXME! }
  kMaxCount: Longint;
  k: Longint;
  i: Longint;
  file_name: ???;	{ FIXME! }
  fileNo: ???;	{ FIXME! }
  count: array [0..49] of Longint;
  failure: Exception;

{
* Draws a bar chart from the array "values" of size nValues.
* Turtleizer must be activated and will scale the chart into a square of
* 500 x 500 pixels
* Note: The function is not robust against empty array or totally equal values.
}
procedure drawBarChart(values: array [0..49] of Double; nValues: ???);

begin
  kMin := 0;
  kMax := 0;
  for k := 1 to nValues-1 do
  begin
    if (values[k] > values[kMax]) then
    begin
      kMax := k;
    end
    else
    begin
      if (values[k] < values[kMin]) then
      begin
        kMin := k;
      end;
    end;
  end;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  if (valMin < 0) then
  begin
    if (valMax > 0) then
    begin
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    end
    else
    begin
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    end;
  end;
  { draw coordinate axes }
  gotoXY(1, ySize - 1);
  forward(ySize -1); { color = ffffff }
  penUp();
  backward(yAxis); { color = ffffff }
  right(90);
  penDown();
  forward(xSize -1); { color = ffffff }
  penUp();
  backward(xSize-1); { color = ffffff }
  stripeWidth := xSize / nValues;
  for k := 0 to nValues-1 do
  begin
    stripeHeight := values[k] * 1.0 / yScale;
    case (k mod 3) of
      0:
        begin
          setPenColor(255,0,0);
        end;
      1:
        begin
          setPenColor(0, 255,0);
        end;
      2:
        begin
          setPenColor(0, 0, 255);
        end;
    end;
    fd(1); { color = ffffff }
    left(90);
    penDown();
    fd(stripeHeight); { color = ffffff }
    right(90);
    fd(stripeWidth - 1); { color = ffffff }
    right(90);
    forward(stripeHeight); { color = ffffff }
    left(90);
    penUp();
  end;

end;

{ = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = }


begin
  fileNo := -10;
  repeat
    write('Name/path of the number file'); readln(file_name);
    assign(fileNo, file_name); open(fileNo);
    until (fileNo > 0 or file_name = '');
  { TODO: Consider replacing this file test using IOResult! }
  if (fileNo > 0) then
  begin
    closeFile(fileNo);
    write('number of intervals'); readln(nIntervals);
    { Initialize the interval counters }
    for k := 0 to nIntervals-1 do
    begin
      count[k] := 0;
    end;
    { Index of the most populated interval }
    kMaxCount := 0;
    { Hint: Automatically decomposed array initialization }
    nObtained := 0;
    try
      nObtained := readNumbers(file_name, numberArray, 10000);
    except
      on Ex : Exception do
      begin
        { FIXME: Ensure a declaration for variable failure (String) in the VAR block! }
        failure := Ex.Message;
        writeln(failure);
      end;
    end;
    if (nObtained > 0) then
    begin
      min := numberArray[0];
      max := numberArray[0];
      for i := 1 to nObtained-1 do
      begin
        if (numberArray[i] < min) then
        begin
          min := numberArray[i];
        end
        else
        begin
          if (numberArray[i] > max) then
          begin
            max := numberArray[i];
          end;
        end;
      end;
      { Interval width }
      width := (max - min) * 1.0 / nIntervals;
      for i := 0 to nObtained - 1 do
      begin
        value := numberArray[i];
        k := 1;
        while (k < nIntervals and value > min + k * width) do
        begin
          k := k + 1;
        end;
        count[k-1] := count[k-1] + 1;
        if (count[k-1] > count[kMaxCount]) then
        begin
          kMaxCount := k-1;
        end;
      end;
      drawBarChart(count, nIntervals);
      writeln('Interval with max count: ', kMaxCount, ' (', count[kMaxCount], ')');
      for k := 0 to nIntervals-1 do
      begin
        writeln(count[k], ' numbers in interval ', k, ' (', min + k * width, ' ... ', min + (k+1) * width, ')');
      end;
    end
    else
    begin
      writeln('No numbers read.');
    end;
  end;
end.
