{
  Creates three equal arrays of numbers and has them sorted with different sorting algorithms
  to allow performance comparison via execution counting ("Collect Runtime Data" should
  sensibly be switched on).
  Requested input data are: Number of elements (size) and filing mode.
}
program SORTING_TEST_MAIN;
{ Generated by Structorizer 3.32-32 }

{ Copyright (C) 2019-10-02 Kay Gürtzig }
{ License: GPLv3-link }
{
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
}

var
  values3: array [0..49] of Longint;
  values2: array [0..49] of Longint;
  values1: array [0..49] of Longint;
  show: ???;	{ FIXME! }
  ok3: Boolean;
  ok2: Boolean;
  ok1: Boolean;
  modus: ???;	{ FIXME! }
  i: Longint;
  elementCount: ???;	{ FIXME! }

{
  Implements the well-known BubbleSort algorithm.
  Compares neigbouring elements and swaps them in case of an inversion.
  Repeats this while inversions have been found. After every
  loop passage at least one element (the largest one out of the
  processed subrange) finds its final place at the end of the
  subrange.
}
procedure bubbleSort(values: ???);

var
  temp: ???;	{ FIXME! }
  posSwapped: Longint;
  i: Longint;
  ende: ???;	{ FIXME! }

begin
  ende := length(values) - 2;
  repeat
    { The index of the most recent swapping (-1 means no swapping done). }
    posSwapped := -1;
    for i := 0 to ende do
    begin
      if values[i] > values[i+1] then
      begin
        temp := values[i];
        values[i] := values[i+1];
        values[i+1] := temp;
        posSwapped := i;
      end;
    end;
    ende := posSwapped - 1;
  until posSwapped < 0;

end;

{
  Given a max-heap 'heap´ with element at index 'i´ possibly
  violating the heap property wrt. its subtree upto and including
  index range-1, restores heap property in the subtree at index i
  again.
}
procedure maxHeapify(heap: ???; i: ???; range: ???);

var
  temp: ???;	{ FIXME! }
  right: ???;	{ FIXME! }
  max: ???;	{ FIXME! }
  left: ???;	{ FIXME! }

begin
  { Indices of left and right child of node i }
  right := (i+1) * 2;
  left := right - 1;
  { Index of the (local) maximum }
  max := i;
  if left < range and heap[left] > heap[i] then
  begin
    max := left;
  end;
  if right < range and heap[right] > heap[max] then
  begin
    max := right;
  end;
  if max <> i then
  begin
    temp := heap[i];
    heap[i] := heap[max];
    heap[max] := temp;
    maxHeapify(heap, max, range);
  end;

end;

{
  Partitions array 'values´ between indices 'start´ und 'stop´-1 with
  respect to the pivot element initially at index 'p´ into smaller
  and greater elements.
  Returns the new (and final) index of the pivot element (which
  separates the sequence of smaller elements from the sequence
  of greater elements).
  This is not the most efficient algorithm (about half the swapping
  might still be avoided) but it is pretty clear.
}
function partition(values: ???; start: ???; stop: ???; p: ???): Longint;

var
  seen: ???;	{ FIXME! }
  pivot: ???;	{ FIXME! }

begin
  { Cache the pivot element }
  pivot := values[p];
  { Exchange the pivot element with the start element }
  values[p] := values[start];
  values[start] := pivot;
  p := start;
  { Beginning and end of the remaining undiscovered range }
  start := start + 1;
  stop := stop - 1;
  {
    Still unseen elements?
    Loop invariants:
    1. p = start - 1
    2. pivot = values[p]
    3. i < start → values[i] ≤ pivot
    4. stop < i → pivot < values[i]
  }
  while start <= stop do
  begin
    { Fetch the first element of the undiscovered area }
    seen := values[start];
    { Does the checked element belong to the smaller area? }
    if seen <= pivot then
    begin
      { Insert the seen element between smaller area and pivot element }
      values[p] := seen;
      values[start] := pivot;
      {
        Shift the border between lower and undicovered area,
        update pivot position.
      }
      p := p + 1;
      start := start + 1;
    end
    else
    begin
      { Insert the checked element between undiscovered and larger area }
      values[start] := values[stop];
      values[stop] := seen;
      { Shift the border between undiscovered and larger area }
      stop := stop - 1;
    end;
  end;
  partition := p;

end;

{ Checks whether or not the passed-in array is (ascendingly) sorted. }
function testSorted(numbers: ???): Boolean;

var
  isSorted: boolean;
  i: Longint;

begin
  isSorted := true;
  i := 0;
  { As we compare with the following element, we must stop at the penultimate index }
  while isSorted and (i <= length(numbers)-2) do
  begin
    { Is there an inversion? }
    if numbers[i] > numbers[i+1] then
    begin
      isSorted := false;
    end
    else
    begin
      i := i + 1;
    end;
  end;
  testSorted := isSorted;

end;

{
  Runs through the array heap and converts it to a max-heap
  in a bottom-up manner, i.e. starts above the "leaf" level
  (index >= length(heap) div 2) and goes then up towards
  the root.
}
procedure buildMaxHeap(heap: ???);

var
  lgth: Longint;
  k: Longint;

begin
  lgth := length(heap);
  for k := lgth div 2 - 1 downto 0 do
  begin
    maxHeapify(heap, k, lgth);
  end;

end;

{
  Recursively sorts a subrange of the given array 'values´. 
  start is the first index of the subsequence to be sorted,
  stop is the index BEHIND the subsequence to be sorted.
}
procedure quickSort(values: ???; start: ???; stop: ???);

var
  p: ???;	{ FIXME! }

begin
  { At least 2 elements? (Less don't make sense.) }
  if stop >= start + 2 then
  begin
    {
      Select a pivot element, be p its index.
      (here: randomly chosen element out of start ... stop-1)
    }
    p := random(stop-start) + start;
    {
      Partition the array into smaller and greater elements
      Get the resulting (and final) position of the pivot element
    }
    p := partition(values, start, stop, p);
    { Sort subsequances separately and independently ... }

    { ========================================================== }
    { ================= START PARALLEL SECTION ================= }
    { ========================================================== }
    { TODO: add the necessary code to run the threads concurrently }
    begin

      { ----------------- START THREAD 0 ----------------- }
      begin
        { Sort left (lower) array part }
        quickSort(values, start, p);
      end;
      { ------------------ END THREAD 0 ------------------ }


      { ----------------- START THREAD 1 ----------------- }
      begin
        { Sort right (higher) array part }
        quickSort(values, p+1, stop);
      end;
      { ------------------ END THREAD 1 ------------------ }

    end;
    { ========================================================== }
    { ================== END PARALLEL SECTION ================== }
    { ========================================================== }

  end;

end;

{
  Sorts the array 'values´ of numbers according to he heap sort
  algorithm
}
procedure heapSort(values: ???);

var
  maximum: ???;	{ FIXME! }
  k: Longint;
  heapRange: Longint;

begin
  buildMaxHeap(values);
  heapRange := length(values);
  for k := heapRange - 1 downto 1 do
  begin
    heapRange := heapRange - 1;
    { Swap the maximum value (root of the heap) to the heap end }
    maximum := values[0];
    values[0] := values[heapRange];
    values[heapRange] := maximum;
    maxHeapify(values, 0, heapRange);
  end;

end;

{ = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = }


begin
  repeat
    readln(elementCount);
  until elementCount >= 1;
  repeat
    write('Filling: 1 = random, 2 = increasing, 3 = decreasing'); readln(modus);
  until modus = 1 or modus = 2 or modus = 3;
  for i := 0 to elementCount-1 do
  begin
    case modus of
      1:
        begin
          values1[i] := random(10000);
        end;
      2:
        begin
          values1[i] := i;
        end;
      3:
        begin
          values1[i] := -i;
        end;
    end;
  end;
  { Copy the array for exact comparability }
  for i := 0 to elementCount-1 do
  begin
    values2[i] := values1[i];
    values3[i] := values1[i];
  end;

  { ========================================================== }
  { ================= START PARALLEL SECTION ================= }
  { ========================================================== }
  { TODO: add the necessary code to run the threads concurrently }
  begin

    { ----------------- START THREAD 0 ----------------- }
    begin
      bubbleSort(values1);
    end;
    { ------------------ END THREAD 0 ------------------ }


    { ----------------- START THREAD 1 ----------------- }
    begin
      quickSort(values2, 0, elementCount);
    end;
    { ------------------ END THREAD 1 ------------------ }


    { ----------------- START THREAD 2 ----------------- }
    begin
      heapSort(values3);
    end;
    { ------------------ END THREAD 2 ------------------ }

  end;
  { ========================================================== }
  { ================== END PARALLEL SECTION ================== }
  { ========================================================== }

  ok1 := testSorted(values1);
  ok2 := testSorted(values2);
  ok3 := testSorted(values3);
  if not ok1 or not ok2 or not ok3 then
  begin
    for i := 0 to elementCount-1 do
    begin
      if values1[i] <> values2[i] or values1[i] <> values3[i] then
      begin
        writeln('Difference at [', i, ']: ', values1[i], ' <-> ', values2[i], ' <-> ', values3[i]);
      end;
    end;
  end;
  repeat
    write('Show arrays (yes/no)?'); readln(show);
  until show = 'yes' or show = 'no';
  if show = 'yes' then
  begin
    for i := 0 to elementCount - 1 do
    begin
      writeln('[', i, ']:\t', values1[i], '\t', values2[i], '\t', values3[i]);
    end;
  end;
end.
