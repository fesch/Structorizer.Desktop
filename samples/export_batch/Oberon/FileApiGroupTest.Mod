MODULE FileApiGroupTest;
(* Generated by Structorizer 3.32-31 *)

(*
  Draws a bar chart from the array "values" of size nValues.
  Turtleizer must be activated and will scale the chart into a square of
  500 x 500 pixels
  Note: The function is not robust against empty array or totally equal values.
 *)
PROCEDURE drawBarChart(values: ARRAY 50 OF LONGREAL; nValues: ???);
CONST
  xSize = 500;
  ySize = 500;

VAR
  (* TODO: check and accomplish variable declarations *)
  yScale: ???;	(* FIXME! *)
  yAxis: ???;	(* FIXME! *)
  valMin: LONGREAL;
  valMax: LONGREAL;
  stripeWidth: ???;	(* FIXME! *)
  stripeHeight: ???;	(* FIXME! *)
  kMin: INTEGER;
  kMax: INTEGER;
  k: INTEGER;
BEGIN
  (* Used range of the Turtleizer screen *)
  kMin := 0;
  kMax := 0;
  FOR k := 1 TO nValues-1 DO
    IF values[k] > values[kMax] THEN
      kMax := k;
    ELSIF values[k] < values[kMin] THEN
      kMin := k;
    END;
  END;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  IF valMin < 0 THEN
    IF valMax > 0 THEN
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    ELSE
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    END;
  END;
  (* draw coordinate axes *)
  gotoXY(1, ySize - 1);
  forward(ySize -1); (* color = ffffff *)
  penUp();
  backward(yAxis); (* color = ffffff *)
  right(90);
  penDown();
  forward(xSize -1); (* color = ffffff *)
  penUp();
  backward(xSize-1); (* color = ffffff *)
  stripeWidth := xSize / nValues;
  FOR k := 0 TO nValues-1 DO
    stripeHeight := values[k] * 1.0 / yScale;
    CASE k MOD 3 OF
      0:
      setPenColor(255,0,0);
    |
      1:
      setPenColor(0, 255,0);
    |
      2:
      setPenColor(0, 0, 255);
    |
    END;
    fd(1); (* color = ffffff *)
    left(90);
    penDown();
    fd(stripeHeight); (* color = ffffff *)
    right(90);
    fd(stripeWidth - 1); (* color = ffffff *)
    right(90);
    forward(stripeHeight); (* color = ffffff *)
    left(90);
    penUp();
  END;
END drawBarChart;

(* = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *)

(*
  Tries to read as many integer values as possible upto maxNumbers
  from file fileName into the given array numbers.
  Returns the number of the actually read numbers. May cause an exception.
 *)
PROCEDURE readNumbers*(fileName: ARRAY 128 OF CHAR; VAR numbers: ARRAY 50 OF INTEGER; maxNumbers: INTEGER): INTEGER;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  number: INTEGER;
  nNumbers: INTEGER;
  fileNo: INTEGER;
  error: Exception;
BEGIN
  nNumbers := 0;
  fileNo := fileOpen(fileName);
  IF fileNo <= 0 THEN
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw "File could not be opened!" *)
  END;
  (* try (FIXME!) *)
    WHILE ~ fileEOF(fileNo) & nNumbers < maxNumbers DO
      number := fileReadInt(fileNo);
      numbers[nNumbers] := number;
      nNumbers := nNumbers + 1;
    END;
  (* catch error (FIXME!) *)
    (* FIXME: jump/exit instruction of unrecognised kind! *)
    (* throw *)
  (* finally (FIXME!) *)
    fileClose(fileNo);
  (* end try (FIXME!) *)
  RETURN nNumbers;
END readNumbers;

BEGIN
  
END FileApiGroupTest.

(* ======= 8< =========================================================== *)

(*
  Computes the sum and average of the numbers read from a user-specified
  text file (which might have been created via generateRandomNumberFile(4)).
  
  This program is part of an arrangement used to test group code export (issue
  #828) with FileAPI dependency.
  The input check loop has been disabled (replaced by a simple unchecked input
  instruction) in order to test the effect of indirect FileAPI dependency (only the
  called subroutine directly requires FileAPI now).
 *)
MODULE ComputeSum;
(* Generated by Structorizer 3.32-31 *)
IMPORT FileApiGroupTest,In,Out;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  values: ARRAY 50 OF ???;	(* FIXME! *)
  sum: LONGREAL;
  nValues: INTEGER;
  k: INTEGER;
  (* Disable this if you enable the loop below! *)
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  failure: Exception;

(* = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *)

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := 1000;
  (* Disable this if you enable the loop below! *)
  (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
  Out.String("Name/path of the number file"); In.TYPE(file_name);
  (*
    If you enable this loop, then the preceding input instruction is to be disabled
    and the fileClose instruction in the alternative below is to be enabled.
   *)
(*   REPEAT *)
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
(*     Out.String("Name/path of the number file"); In.TYPE(file_name); *)
(*     fileNo := fileOpen(file_name); *)
(*   UNTIL fileNo > 0 OR file_name = ""; *)
  IF fileNo > 0 THEN
    (* This should be enabled if the input check loop above gets enabled. *)
(*     fileClose(fileNo); *)
    (* Hint: Automatically decomposed array initialization *)
    nValues := 0;
    (* try (FIXME!) *)
      nValues := readNumbers(file_name, values, 1000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
      HALT(-7);
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    sum := 0.0;
    FOR k := 0 TO nValues-1 DO
      sum := sum + values[k];
    END;
    Out.String("sum = ");
    Out.Real(sum, 10);
    Out.Ln;
    Out.String("average = ");
    (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
    Out.TYPE(sum / nValues);
    Out.Ln;
  END;
END ComputeSum.

(* ======= 8< =========================================================== *)

(*
  Reads a random number file and draws a histogram accotrding to the
  user specifications
 *)
MODULE DrawRandomHistogram;
(* Generated by Structorizer 3.32-31 *)
IMPORT FileApiGroupTest,In,Out;

(* Copyright (C) 2020-03-21 Kay Gürtzig *)
(* License: GPLv3-link *)
(*
  GNU General Public License (V 3)
  https://www.gnu.org/licenses/gpl.html
  http://www.gnu.de/documents/gpl.de.html
 *)

VAR
  (* TODO: check and accomplish variable declarations *)
  (* Interval width *)
  width: ???;	(* FIXME! *)
  value: ???;	(* FIXME! *)
  numberArray: ARRAY 50 OF ???;	(* FIXME! *)
  nObtained: INTEGER;
  nIntervals: ???;	(* FIXME! *)
  min: ???;	(* FIXME! *)
  max: ???;	(* FIXME! *)
  kMaxCount: INTEGER;
  k: INTEGER;
  i: INTEGER;
  file_name: ???;	(* FIXME! *)
  fileNo: INTEGER;
  count: ARRAY 50 OF INTEGER;
  failure: Exception;

(*
  Draws a bar chart from the array "values" of size nValues.
  Turtleizer must be activated and will scale the chart into a square of
  500 x 500 pixels
  Note: The function is not robust against empty array or totally equal values.
 *)
PROCEDURE drawBarChart(values: ARRAY 50 OF LONGREAL; nValues: ???);

BEGIN
  (* Used range of the Turtleizer screen *)
  kMin := 0;
  kMax := 0;
  FOR k := 1 TO nValues-1 DO
    IF values[k] > values[kMax] THEN
      kMax := k;
    ELSIF values[k] < values[kMin] THEN
      kMin := k;
    END;
  END;
  valMin := values[kMin];
  valMax := values[kMax];
  yScale := valMax * 1.0 / (ySize - 1);
  yAxis := ySize - 1;
  IF valMin < 0 THEN
    IF valMax > 0 THEN
      yAxis := valMax * ySize * 1.0 / (valMax - valMin);
      yScale := (valMax - valMin) * 1.0 / (ySize - 1);
    ELSE
      yAxis := 1;
      yScale := valMin * 1.0 / (ySize - 1);
    END;
  END;
  (* draw coordinate axes *)
  gotoXY(1, ySize - 1);
  forward(ySize -1); (* color = ffffff *)
  penUp();
  backward(yAxis); (* color = ffffff *)
  right(90);
  penDown();
  forward(xSize -1); (* color = ffffff *)
  penUp();
  backward(xSize-1); (* color = ffffff *)
  stripeWidth := xSize / nValues;
  FOR k := 0 TO nValues-1 DO
    stripeHeight := values[k] * 1.0 / yScale;
    CASE k MOD 3 OF
      0:
      setPenColor(255,0,0);
    |
      1:
      setPenColor(0, 255,0);
    |
      2:
      setPenColor(0, 0, 255);
    |
    END;
    fd(1); (* color = ffffff *)
    left(90);
    penDown();
    fd(stripeHeight); (* color = ffffff *)
    right(90);
    fd(stripeWidth - 1); (* color = ffffff *)
    right(90);
    forward(stripeHeight); (* color = ffffff *)
    left(90);
    penUp();
  END;
END drawBarChart;

(* = = = = 8< = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *)

BEGIN
  In.Open;
  Out.Open;
  
  fileNo := -10;
  REPEAT
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("Name/path of the number file"); In.TYPE(file_name);
    fileNo := fileOpen(file_name);
  UNTIL fileNo > 0 OR file_name = "";
  IF fileNo > 0 THEN
    fileClose(fileNo);
    (* TODO: Replace "TYPE" by the the actual In procedure name for this type! *)
    Out.String("number of intervals"); In.TYPE(nIntervals);
    (* Initialize the interval counters *)
    FOR k := 0 TO nIntervals-1 DO
      count[k] := 0;
    END;
    (* Index of the most populated interval *)
    kMaxCount := 0;
    (* Hint: Automatically decomposed array initialization *)
    nObtained := 0;
    (* try (FIXME!) *)
      nObtained := readNumbers(file_name, numberArray, 10000);
    (* catch failure (FIXME!) *)
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(failure);
      Out.Ln;
    (* finally (FIXME!) *)
    (* end try (FIXME!) *)
    IF nObtained > 0 THEN
      min := numberArray[0];
      max := numberArray[0];
      FOR i := 1 TO nObtained-1 DO
        IF numberArray[i] < min THEN
          min := numberArray[i];
        ELSIF numberArray[i] > max THEN
          max := numberArray[i];
        END;
      END;
      (* Interval width *)
      width := (max - min) * 1.0 / nIntervals;
      FOR i := 0 TO nObtained - 1 DO
        value := numberArray[i];
        k := 1;
        WHILE k < nIntervals & value > min + k * width DO
          k := k + 1;
        END;
        count[k-1] := count[k-1] + 1;
        IF count[k-1] > count[kMaxCount] THEN
          kMaxCount := k-1;
        END;
      END;
      drawBarChart(count, nIntervals);
      Out.String("Interval with max count: ");
      Out.Int(kMaxCount, 10);
      Out.String(" (");
      (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
      Out.TYPE(count[kMaxCount]);
      Out.String(")");
      Out.Ln;
      FOR k := 0 TO nIntervals-1 DO
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(count[k]);
        Out.String(" numbers in interval ");
        Out.Int(k, 10);
        Out.String(" (");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + k * width);
        Out.String(" ... ");
        (* TODO: Replace "TYPE" by the the actual Out procedure name for this type and add a length argument where needed! *)
        Out.TYPE(min + (k+1) * width);
        Out.String(")");
        Out.Ln;
      END;
    ELSE
      Out.String("No numbers read.");
      Out.Ln;
    END;
  END;
END DrawRandomHistogram.
