! -----------------------------------------------------------------------------
! COBOL  -  COmmon Business Oriented Language
! GnuCOBOL grammar: COBOL 85,2002,2014 + multitude of vendor extensions
!
! The COBOL programmming language is one of the oldest still in use today. It
! was originally designed by the United States Department of defense under the
! supervision of the COnference on DAta SYstems Languages (CODASYL) Committee.
! Most of the groundwork and design of COBOL was done by General Grace Hopper
! of the United States Navy.
!
! The COBOL language was designed to be a self-documenting language where
! programs would read as close to English as possible. All interaction
! between the user, the terminal and files are performed through language
! statements rather than third-party libraries. The metaphor used for data
! types is abstract and completely platform independant. As a result of these
! factors, COBOL is a very portable language.
! -----------------------------------------------------------------------------
!
! Revisions:
!
!    17-04-13: Simon Sobisch
!       * Grammar converted from GnuCOBOL parser.y (lot of sed invocation and
!         manual work)
!    17-04-26: Simon Sobisch
!       * finished Terminals (conversion from GnuCOBOL reserved.c and 
!         scanner.l, some manual addons like PicDef and <_Comment Items>)
!    17-05-02: Simon Sobisch
!       * fixed edited Picture_Def
!       * updated "Known Issues" entries
!    17-05-19: Simon Sobisch
!       * added more alias names (in general this should be done by
!         dialect aware preprocessing!)
!       * fixed escaped literal terminators in NationalLiteral and ZLiteral
!
! -----------------------------------------------------------------------------
!
! Known issues:
! * Only works on pre-parsed files (Structorizer has a minimal pre-parser for
!   COBOL but doesn't either handle COPY or REPLACE statements nor most compiler
!   directives).
! * GOLD parser has no option to tell the grammar-compiler which shift to prefer
!   in case of conflicts (bison has %prec for this), see "Resolving Conglicts"
!   in http://goldparser.org/about/future-work.htm - therefore we have many
!   shift-reduce conflicts and may parse wrong in these places.
! * GOLD parser has no option to define states / recognize terminals according
!   to this. This results in terminals like Picture_Def (which should be a
!   PICTURE token) and the impossibility to handle DECIMAL-POINT IS COMMA
!   (which must be handled by the preparser).
! * While the definition of COBOL constans via "CONSTANT AS" and level 78 is
!   recognized it isn't resolved. They should either be replaced by its values
!   (especially for Picture_Def) and/or by a special token that we check here
!   instead of COBOLWord.
! * There is no option to define context-sensitive words which is needed in
!   general or remove / add words from the token list which is needed as it
!   includes a lot of extensions from different vendors that will break parsing
!   of source that is valid with another vendor (an example for both is the
!   extension TAB as screen option which breaks the otherwise normal COBOLWord).
! * Lots of "FIXME" and "HACK" entries and stuff that we may have to place in a
!   preparser, espacially "COMMA_DELIM" and replacing of constant values to a
!   different token than COBOLWord.
! * The C code that is part of the grammar should be investigated for parsing
!   hints and removed afterwards.
!
! -----------------------------------------------------------------------------

"Name"    = 'GnuCOBOL'
"Version" = '1.0'

"Author"  = 'Original Written by Keisuke Nishida, Roger While, Simon Sobisch, Edward Hart'

"About"   = 'Originally created in 1960, COBOL (COmmon Business Oriented Language)'
          | 'is one of the top 5 most popular languages in use today. COBOL was designed'
          | 'to be self-documenting by using a structure simular to basic English.'
          | ''
          | 'This is the main grammar of GnuCOBOL cobc/parser.y, combined with cobc/scanner.l. '
          | ' Copyright (C) 2001-2012, 2014-2017 Free Software Foundation, Inc.'
          | ''
          | 'It was was converted with `sed` and some manual tweaks by Simon Sobisch.'
          !  HOWTO:
          !   * convert to dos line ending
          !   * copy grammar rules -> everthing between %% and %%
          !   * remove C code or replace as comments 
          !     a) replace as comments 
          !     * replaces all occurences of '!' -> used as comment indicator in GOLD 
          !         !=  <> 
          !         '!'     C_EXCLAMATION_LIT 
          !         !!(\w)  C_MAKE_BOOL $1 
          !         !([\w$(])   C_NOT $1 
          !     * move source parts to multiline comments: 
          !         {   !* { 
          !         \}  } *! 
          !     b) remove code: everything between { and } - NOT greedy, until no replacements found 
          !   * replace comments: 
          !         /\* !* 
          !         */  *! 
          !         (//.*)  !* $1 *!   [this was not in the converted parser.y] 
          !   * until it is clear if this is possible: replace shift preference
          !         (%prec SHIFT_PREFER)    !* $1 *! 
          !   * replace definitions
          !         ^([a-z0-9_]+):\r\n  <$1>\r\n::=\t 
          !         ^([a-z0-9_]+):\t    <$1> ::=\t 
          !   * replace tokens (case-sensitive !!!)
          !         ^([ |] [^ !{}][^!\r\n]* )([a-z0-9_]+)   $1<$2>      at least. 2 tokens, replace last (do until no replacements occur) 
          !         ^([ |] )([a-z0-9_]+)                    $1<$2>      replace first 2 token 
          !         (::=\t+[^!{}][^!\r\n]* )([a-z_]+)       $1<$2>      at least. 2 tokens, replace last (do until no replacements occur) 
          !   * delete token endings
          !         ^;   
          !         ^(<.*);$    $1 
          !   * replace line breaks where necessary (can be improved...)
          !         \r\n(  [\w<])   $1 
          !         \r\n[ \t]*!\*   \t!* 
          !         ^(\s*)!([^*].*)(!\*)    $1!* $2*! $3 
          !         (::=\s*)!([^*].*)(!\*)  $1!* $2*! $3 
          !   * first test --> move "::=\s*!\*" where errors occurs [6 times with GC 2.2] 
          !   * add terminals, copy tokens from original source and do
          !         %token (\w+)$   $1 = $1 
          !         %token (\w+)\t+"(.+)"   $1 = $2 
          !         \s= ([^\w])$     = '$1'
          !   * create <COMMON_FUNCTION> from reserved.c FUNCTION_NAME
          !   * add synonyms from reserved.c
          !   * add synonyms from config/default.conf
          !   * add terminal definitions from scanner.l
          !   * comment <error> parts --> !bison error token
          !   * copy this header into the final grammar file

"Case Sensitive"   = False
"Start Symbol"     = <start>
                   
! ===================================================================

! Definition of Whitespace works in all places - but breaks the comments
!!{COBOLWhitespace}  = {All Space} + {All Newline} + {&09 .. &13} + [;]
!!{COBOLWhitespace}  = {Whitespace} + [;]
!Whitespace         = {COBOLWhitespace}+

! ===================================================================

! Comments
Comment Line  = '*>'

! ===================================================================

! Lexer terminals:

! variant for reading windows-cp1252 encoded files without setting 
!  {Printable} + {Printable Extended} + {&80 .. &9F}
! UTF-8 version:
{String Chars}     = {All Printable}

{String Chars 1}   = {String Chars} - ['']
{String Chars 2}   = {String Chars} - ["]
{Hex Chars}        = {Number} + [ABCDEF]
                   
StringLiteral      = '' ({String Chars 1} | '' '')*''
                   | '"'({String Chars 2} | '""')*'"'

HexLiteral         = 'X'(''{Hex Chars}+'' | '"'{Hex Chars}+'"')

! Split to additional LLiteral if needed
ZLiteral           = [ZL] '' ({String Chars 1} | '' '')*''
                   | [ZL] '"'({String Chars 2} | '""')*'"'
                   
BooleanLiteral     = 'B'(''[01]+'' | '"'[01]+'"')
BooleanHexLiteral  = 'BX'(''{Hex Chars}+'' | '"'{Hex Chars}+'"')

NationalLiteral    = 'N' '' ({String Chars 1} | '' '')*''
                   | 'N' '"'({String Chars 2} | '""')*'"'
NationalHexLiteral = 'NX'(''{Hex Chars}+'' | '"'{Hex Chars}+'"')

AcuBinNumLiteral   = 'B#'[01]+
AcuOctNumLiteral   = 'O#'{Number}+
AcuHexNumLiteral   = [XH]'#'{Hex Chars}+

IntLiteral         = [+-]?{Number}+
DecimalLiteral     = [+-]?{Number}+ '.' {Number}+
FloatLiteral       = [+-]?{Number}+ '.' {Number}+ 'E' [+-]?{Number}+

                  
{COBOLLetter}      = {Letter} + {&80 .. &FF} - {Whitespace}
{COBOLLetterFull}  = {COBOLLetter} + [_-]
{COBOLChars}       = {Number} + {COBOLLetter}
{COBOLCharsFull}   = {COBOLChars} + [_-]

COBOLWord          = {Number}* {COBOLLetter} ({COBOLCharsFull}*{COBOLChars}+)?
                   | {Number}+ {COBOLLetterFull} {COBOLCharsFull}* {COBOLChars}+
                        

! ===================================================================
! Picture Clause --> needs to be a terminal to be able to distinguish
!                    between IntLiteral, COBOLWord and PICTURE
! ===================================================================

{PicChar}    = [anxz$19*+-] + [pb0/,]
! "correct" defintion (not usable as we currently have to include CONSTANTs -> COBOLWords)
!Picture_Def = 'PIC'('TURE')? {Whitespace}+ (IS {Whitespace}+)? (CR|DB|[$s])? ({PicChar}+ ( '('{Number}+')' )?)+ ( [v.] ({PicChar}+ ( '('{Number}+')' )?)+ (('E' '9'+ ( '('{Number}+')' )?)?) | (CR|DB|[$s]))?
Picture_Def = 'PIC'('TURE')? {Whitespace}+ (IS {Whitespace}+)? (CR|DB|[$s])? ({PicChar}+ ( '('{COBOLCharsFull}+')' )?)+ ( [v.] ({PicChar}+ ( '('{COBOLCharsFull}+')' )?)+ (('E' '9'+ ( '('{COBOLCharsFull}+')' )?)?) | (CR|DB|[$s]))?

! ===================================================================

! Terminals
ACCEPT                         = 'ACCEPT'
ACCESS                         = 'ACCESS'
ADD                            = 'ADD'
ADDRESS                        = 'ADDRESS'
ADVANCING                      = 'ADVANCING'
AFTER                          = 'AFTER'
ALL                            = 'ALL'
ALLOCATE                       = 'ALLOCATE'
ALPHABET                       = 'ALPHABET'
ALPHABETIC                     = 'ALPHABETIC'
ALPHABETIC_LOWER               = 'ALPHABETIC-LOWER'
ALPHABETIC_UPPER               = 'ALPHABETIC-UPPER'
ALPHANUMERIC                   = 'ALPHANUMERIC'
ALPHANUMERIC_EDITED            = 'ALPHANUMERIC-EDITED'
ALSO                           = 'ALSO'
ALTER                          = 'ALTER'
ALTERNATE                      = 'ALTERNATE'
AND                            = 'AND'
ANY                            = 'ANY'
ARE                            = 'ARE'
AREA                           = 'AREA'
AREAS                          = 'AREAS'
ARGUMENT_NUMBER                = 'ARGUMENT-NUMBER'
ARGUMENT_VALUE                 = 'ARGUMENT-VALUE'
AS                             = 'AS'
ASCENDING                      = 'ASCENDING'
ASCII                          = 'ASCII'
ASSIGN                         = 'ASSIGN'
AT                             = 'AT'
ATTRIBUTE                      = 'ATTRIBUTE'
AUTO                           = 'AUTO' | 'AUTO-SKIP' | 'AUTOTERMINATE'
AUTOMATIC                      = 'AUTOMATIC'
AWAY_FROM_ZERO                 = 'AWAY-FROM-ZERO'
BACKGROUND_COLOR               = 'BACKGROUND-COLOR' | 'BACKGROUND-COLOUR'
BASED                          = 'BASED'
BEFORE                         = 'BEFORE'
BELL                           = 'BELL' | 'BEEP'
BINARY                         = 'BINARY'
BINARY_C_LONG                  = 'BINARY-C-LONG'
BINARY_CHAR                    = 'BINARY-CHAR'
BINARY_DOUBLE                  = 'BINARY-DOUBLE' | 'BINARY-LONG-LONG'
BINARY_LONG                    = 'BINARY-LONG' | 'BINARY-INT'
BINARY_SHORT                   = 'BINARY-SHORT'
BLANK                          = 'BLANK'
BLINK                          = 'BLINK'
BLOCK                          = 'BLOCK'
BY                             = 'BY'
BYTE_LENGTH                    = 'BYTE-LENGTH'
CALL                           = 'CALL'
CANCEL                         = 'CANCEL'
CAPACITY                       = 'CAPACITY'
CARD_PUNCH                     = 'CARD-PUNCH'
CARD_READER                    = 'CARD-READER'
CASSETTE                       = 'CASSETTE'
CD                             = 'CD'
CF                             = 'CF'
CH                             = 'CH'
CHAINING                       = 'CHAINING'
CHARACTER                      = 'CHARACTER'
CHARACTERS                     = 'CHARACTERS'
CLASS                          = 'CLASS'
CLASSIFICATION                 = 'CLASSIFICATION'
CLOSE                          = 'CLOSE'
COBOL                          = 'COBOL'
CODE                           = 'CODE'
CODE_SET                       = 'CODE-SET'
COLLATING                      = 'COLLATING'
COL                            = 'COL'
COLS                           = 'COLS'
COLUMN                         = 'COLUMN'
COLUMNS                        = 'COLUMNS'
COMMA                          = 'COMMA'
COMMAND_LINE                   = 'COMMAND-LINE'
COMMIT                         = 'COMMIT'
COMMON                         = 'COMMON'
COMMUNICATION                  = 'COMMUNICATION'
COMP                           = 'COMP'
COMPUTE                        = 'COMPUTE'
COMP_1                         = 'COMP-1'
COMP_2                         = 'COMP-2'
COMP_3                         = 'COMP-3'
COMP_4                         = 'COMP-4'
COMP_5                         = 'COMP-5'
COMP_6                         = 'COMP-6'
COMP_X                         = 'COMP-X'
!CONDITION                      = 'CONDITION'    ! already consumed by Terminals
CONFIGURATION                  = 'CONFIGURATION'
CONSTANT                       = 'CONSTANT'
CONTAINS                       = 'CONTAINS'
CONTENT                        = 'CONTENT'
CONTINUE                       = 'CONTINUE'
CONTROL                        = 'CONTROL'
CONTROLS                       = 'CONTROLS'
CONVERSION                     = 'CONVERSION'
CONVERTING                     = 'CONVERTING'
!COPY                           = 'COPY'         ! part of pre-parsing step
CORRESPONDING                  = 'CORRESPONDING' | 'CORR'
COUNT                          = 'COUNT'
CRT                            = 'CRT'
CRT_UNDER                      = 'CRT-UNDER'
CURRENCY                       = 'CURRENCY'
CURSOR                         = 'CURSOR'
CYCLE                          = 'CYCLE'
DATA                           = 'DATA'
DATE                           = 'DATE'
DAY                            = 'DAY'
DAY_OF_WEEK                    = 'DAY-OF-WEEK'
DE                             = 'DE'
DEBUGGING                      = 'DEBUGGING'
DECIMAL_POINT                  = 'DECIMAL-POINT'
DECLARATIVES                   = 'DECLARATIVES'
DEFAULT                        = 'DEFAULT'
DELETE                         = 'DELETE'
DELIMITED                      = 'DELIMITED'
DELIMITER                      = 'DELIMITER'
DEPENDING                      = 'DEPENDING'
DESCENDING                     = 'DESCENDING'
DESTINATION                    = 'DESTINATION'
DETAIL                         = 'DETAIL'
DISABLE                        = 'DISABLE'
DISC                           = 'DISC'
DISK                           = 'DISK'
DISPLAY                        = 'DISPLAY'
DIVIDE                         = 'DIVIDE'
DIVISION                       = 'DIVISION'
DOWN                           = 'DOWN'
DUPLICATES                     = 'DUPLICATES'
DYNAMIC                        = 'DYNAMIC'
EBCDIC                         = 'EBCDIC'
ECHO                           = 'ECHO'
EGI                            = 'EGI'
ENABLE                         = 'ENABLE'
ELSE                           = 'ELSE'
EMI                            = 'EMI'
!END                            = 'END'          ! already consumed by Terminals
END_ACCEPT                     = 'END-ACCEPT'
END_ADD                        = 'END-ADD'
END_CALL                       = 'END-CALL'
END_COMPUTE                    = 'END-COMPUTE'
END_DELETE                     = 'END-DELETE'
END_DISPLAY                    = 'END-DISPLAY'
END_DIVIDE                     = 'END-DIVIDE'
END_EVALUATE                   = 'END-EVALUATE'
END_IF                         = 'END-IF'
END_MULTIPLY                   = 'END-MULTIPLY'
END_PERFORM                    = 'END-PERFORM'
END_READ                       = 'END-READ'
END_RECEIVE                    = 'END-RECEIVE'
END_RETURN                     = 'END-RETURN'
END_REWRITE                    = 'END-REWRITE'
END_SEARCH                     = 'END-SEARCH'
END_START                      = 'END-START'
END_STRING                     = 'END-STRING'
END_SUBTRACT                   = 'END-SUBTRACT'
END_UNSTRING                   = 'END-UNSTRING'
END_WRITE                      = 'END-WRITE'
ENTRY                          = 'ENTRY'
ENTRY_CONVENTION               = 'ENTRY-CONVENTION'
ENVIRONMENT                    = 'ENVIRONMENT'
!ENVIRONMENT_NAME               = 'ENVIRONMENT-NAME'  ! already consumed by Terminals
ENVIRONMENT_VALUE              = 'ENVIRONMENT-VALUE'
EOL                            = 'EOL'
EOS                            = 'EOS'
ERASE                          = 'ERASE'
ERROR                          = 'ERROR'
!ESCAPE                         = 'ESCAPE'       ! already consumed by Terminals
ESI                            = 'ESI'
EVALUATE                       = 'EVALUATE'
!EXCEPTION                      = 'EXCEPTION'    ! already consumed by Terminals
EXCLUSIVE                      = 'EXCLUSIVE'
EXIT                           = 'EXIT'
EXTEND                         = 'EXTEND'
EXTERNAL                       = 'EXTERNAL'
F                              = 'F'
FD                             = 'FD'
FILE_CONTROL                   = 'FILE-CONTROL'
FILE_ID                        = 'FILE-ID'
FILLER                         = 'FILLER'
FINAL                          = 'FINAL'
FIRST                          = 'FIRST'
FIXED                          = 'FIXED'
FLOAT_BINARY_128               = 'FLOAT-BINARY-128'
FLOAT_BINARY_32                = 'FLOAT-BINARY-32'
FLOAT_BINARY_64                = 'FLOAT-BINARY-64'
FLOAT_DECIMAL_16               = 'FLOAT-DECIMAL-16'
FLOAT_DECIMAL_34               = 'FLOAT-DECIMAL-34'
FLOAT_DECIMAL_7                = 'FLOAT-DECIMAL-7'
FLOAT_EXTENDED                 = 'FLOAT-EXTENDED'
FLOAT_LONG                     = 'FLOAT-LONG'
FLOAT_SHORT                    = 'FLOAT-SHORT'
FOOTING                        = 'FOOTING'
FOR                            = 'FOR'
FOREGROUND_COLOR               = 'FOREGROUND-COLOR' | 'FOREGROUND-COLOUR'
FOREVER                        = 'FOREVER'
FREE                           = 'FREE'
FROM                           = 'FROM'
FULL                           = 'FULL' | 'LENGTH-CHECK'
FUNCTION                       = 'FUNCTION'
FUNCTION_ID                    = 'FUNCTION-ID'
GENERATE                       = 'GENERATE'
GIVING                         = 'GIVING'
GLOBAL                         = 'GLOBAL'
GO                             = 'GO'
GOBACK                         = 'GOBACK'
GRID                           = 'GRID'
GROUP                          = 'GROUP'
HEADING                        = 'HEADING'
HIGHLIGHT                      = 'HIGHLIGHT'
HIGH_VALUE                     = 'HIGH-VALUE' | 'HIGH-VALUES'
ID                             = 'ID'
IDENTIFICATION                 = 'IDENTIFICATION'
IF                             = 'IF'
IGNORE                         = 'IGNORE'
IGNORING                       = 'IGNORING'
IN                             = 'IN'
INDEX                          = 'INDEX'
INDEXED                        = 'INDEXED'
INDICATE                       = 'INDICATE'
INITIALIZE                     = 'INITIALIZE' | 'INITIALISE'
INITIALIZED                    = 'INITIALIZED' | 'INITIALISED'
INITIATE                       = 'INITIATE'
INPUT                          = 'INPUT'
INPUT_OUTPUT                   = 'INPUT-OUTPUT'
INSPECT                        = 'INSPECT'
INTERMEDIATE                   = 'INTERMEDIATE'
INTO                           = 'INTO'
INTRINSIC                      = 'INTRINSIC'
!INVALID                        = 'INVALID'      ! already consumed by Terminals
IS                             = 'IS'
I_O                            = 'I-O'
I_O_CONTROL                    = 'I-O-CONTROL'
JUSTIFIED                      = 'JUSTIFIED' | 'JUST'
KEPT                           = 'KEPT'
KEY                            = 'KEY'
KEYBOARD                       = 'KEYBOARD'
LABEL                          = 'LABEL'
LAST                           = 'LAST'
LEADING                        = 'LEADING'
LEFT                           = 'LEFT'
LEFTLINE                       = 'LEFTLINE'
LENGTH                         = 'LENGTH'
LIMIT                          = 'LIMIT'
LIMITS                         = 'LIMITS'
LINAGE                         = 'LINAGE'
LINAGE_COUNTER                 = 'LINAGE-COUNTER'
LINE                           = 'LINE'
LINE_COUNTER                   = 'LINE-COUNTER'
LINES                          = 'LINES'
LINKAGE                        = 'LINKAGE'
LOCALE                         = 'LOCALE'
LOCAL_STORAGE                  = 'LOCAL-STORAGE'
LOCK                           = 'LOCK'
LOWER                          = 'LOWER'
LOWLIGHT                       = 'LOWLIGHT'
LOW_VALUE                      = 'LOW-VALUE' | 'LOW-VALUES'
MANUAL                         = 'MANUAL'
MAGNETIC_TAPE                  = 'MAGNETIC-TAPE'
MEMORY                         = 'MEMORY'
MERGE                          = 'MERGE'
MESSAGE                        = 'MESSAGE'
MINUS                          = 'MINUS'
MODE                           = 'MODE'
MOVE                           = 'MOVE'
MULTIPLE                       = 'MULTIPLE'
MULTIPLY                       = 'MULTIPLY'
NAME                           = 'NAME'
NATIONAL                       = 'NATIONAL'
NATIONAL_EDITED                = 'NATIONAL-EDITED'
NATIVE                         = 'NATIVE'
NEAREST_AWAY_FROM_ZERO         = 'NEAREST-AWAY-FROM-ZERO'
NEAREST_EVEN                   = 'NEAREST-EVEN'
NEAREST_TOWARD_ZERO            = 'NEAREST-TOWARD-ZERO'
NEGATIVE                       = 'NEGATIVE'
NESTED                         = 'NESTED'
NEXT                           = 'NEXT'
NO                             = 'NO'
NO_ECHO                        = 'NO-ECHO'
NORMAL                         = 'NORMAL'
NOT                            = 'NOT'
NOTHING                        = 'NOTHING'
NUMBER                         = 'NUMBER'
NUMBERS                        = 'NUMBERS'
NUMERIC                        = 'NUMERIC'
NUMERIC_EDITED                 = 'NUMERIC-EDITED'
OBJECT_COMPUTER                = 'OBJECT-COMPUTER'
OCCURS                         = 'OCCURS'
OF                             = 'OF'
OFF                            = 'OFF'
OMITTED                        = 'OMITTED'
ON                             = 'ON'
ONLY                           = 'ONLY'
OPEN                           = 'OPEN'
OPTIONAL                       = 'OPTIONAL'
OPTIONS                        = 'OPTIONS'
OR                             = 'OR'
ORDER                          = 'ORDER'
ORGANIZATION                   = 'ORGANIZATION' | 'ORGANISATION'
OTHER                          = 'OTHER'
OUTPUT                         = 'OUTPUT'
OVERLINE                       = 'OVERLINE'
PACKED_DECIMAL                 = 'PACKED-DECIMAL'
PADDING                        = 'PADDING'
PAGE                           = 'PAGE'
PAGE_COUNTER                   = 'PAGE-COUNTER'
PARAGRAPH                      = 'PARAGRAPH'
PERFORM                        = 'PERFORM'
PH                             = 'PH'
PF                             = 'PF'
PLUS                           = 'PLUS'
POINTER                        = 'POINTER'
POSITION                       = 'POSITION'
POSITIVE                       = 'POSITIVE'
PRESENT                        = 'PRESENT'
PREVIOUS                       = 'PREVIOUS'
PRINT                          = 'PRINT'
PRINTER                        = 'PRINTER'
PRINTER_1                      = 'PRINTER-1'
PRINTING                       = 'PRINTING'
PROCEDURE                      = 'PROCEDURE'
PROCEDURES                     = 'PROCEDURES'
PROCEED                        = 'PROCEED'
PROGRAM                        = 'PROGRAM'
PROGRAM_ID                     = 'PROGRAM-ID'
PROGRAM_POINTER                = 'PROGRAM-POINTER'
PROHIBITED                     = 'PROHIBITED'
PROMPT                         = 'PROMPT'
PROTECTED                      = 'PROTECTED'
PURGE                          = 'PURGE'
QUEUE                          = 'QUEUE'
QUOTE                          = 'QUOTE' | 'QUOTES'
RANDOM                         = 'RANDOM'
RD                             = 'RD'
READ                           = 'READ'
RECEIVE                        = 'RECEIVE'
RECORD                         = 'RECORD'
RECORDING                      = 'RECORDING'
RECORDS                        = 'RECORDS'
RECURSIVE                      = 'RECURSIVE'
REDEFINES                      = 'REDEFINES'
REEL                           = 'REEL'
REFERENCE                      = 'REFERENCE'
REFERENCES                     = 'REFERENCES'
RELATIVE                       = 'RELATIVE'
RELEASE                        = 'RELEASE'
REMAINDER                      = 'REMAINDER'
REMOVAL                        = 'REMOVAL'
RENAMES                        = 'RENAMES'
!REPLACE                        = 'REPLACE'      ! part of pre-parsing step
REPLACING                      = 'REPLACING'
REPORT                         = 'REPORT'
REPORTING                      = 'REPORTING'
REPORTS                        = 'REPORTS'
REPOSITORY                     = 'REPOSITORY'
REQUIRED                       = 'REQUIRED' | 'EMPTY-CHECK'
RESERVE                        = 'RESERVE'
RESET                          = 'RESET'
RETRY                          = 'RETRY'
RETURN                         = 'RETURN'
RETURNING                      = 'RETURNING'
REVERSE                        = 'REVERSE'
REVERSE_VIDEO                  = 'REVERSE-VIDEO'
REVERSED                       = 'REVERSED'
REWIND                         = 'REWIND'
REWRITE                        = 'REWRITE'
RF                             = 'RF'
RH                             = 'RH'
RIGHT                          = 'RIGHT'
ROLLBACK                       = 'ROLLBACK'
ROUNDED                        = 'ROUNDED'
ROUNDING                       = 'ROUNDING'
RUN                            = 'RUN'
S                              = 'S'
SAME                           = 'SAME'
SCREEN                         = 'SCREEN'
SCROLL                         = 'SCROLL'
SD                             = 'SD'
SEARCH                         = 'SEARCH'
SECONDS                        = 'SECONDS'
SECTION                        = 'SECTION'
SECURE                         = 'SECURE'
SEGMENT                        = 'SEGMENT'
SEGMENT_LIMIT                  = 'SEGMENT-LIMIT'
SELECT                         = 'SELECT'
SEMI_COLON                     = ';'
SEND                           = 'SEND'
SENTENCE                       = 'SENTENCE'
SEPARATE                       = 'SEPARATE'
SEQUENCE                       = 'SEQUENCE'
SEQUENTIAL                     = 'SEQUENTIAL'
SET                            = 'SET'
SHARING                        = 'SHARING'
SIGN                           = 'SIGN'
SIGNED                         = 'SIGNED'
SIGNED_INT                     = 'SIGNED-INT'
SIGNED_LONG                    = 'SIGNED-LONG'
SIGNED_SHORT                   = 'SIGNED-SHORT'
SIZE                           = 'SIZE'
SORT                           = 'SORT'
SORT_MERGE                     = 'SORT-MERGE'
SOURCE                         = 'SOURCE'
SOURCE_COMPUTER                = 'SOURCE-COMPUTER'
SPACE                          = 'SPACE' | 'SPACES'
SPECIAL_NAMES                  = 'SPECIAL-NAMES'
STANDARD                       = 'STANDARD'
STANDARD_1                     = 'STANDARD-1'
STANDARD_2                     = 'STANDARD-2'
START                          = 'START'
STATIC                         = 'STATIC'
STATUS                         = 'STATUS'
STDCALL                        = 'STDCALL'
STEP                           = 'STEP'
STOP                           = 'STOP'
STRING                         = 'STRING'
SUB_QUEUE_1                    = 'SUB-QUEUE-1'
SUB_QUEUE_2                    = 'SUB-QUEUE-2'
SUB_QUEUE_3                    = 'SUB-QUEUE-3'
SUBTRACT                       = 'SUBTRACT'
SUM                            = 'SUM'
SUPPRESS                       = 'SUPPRESS'
SYMBOLIC                       = 'SYMBOLIC'
SYNCHRONIZED                   = 'SYNCHRONIZED' | 'SYNCHRONISED'
SYSTEM_DEFAULT                 = 'SYSTEM-DEFAULT'
SYSTEM_OFFSET                  = 'SYSTEM-OFFSET'
TAB                            = 'TAB'
TABLE                          = 'TABLE'
TALLYING                       = 'TALLYING'
TAPE                           = 'TAPE'
TERMINAL                       = 'TERMINAL'
TERMINATE                      = 'TERMINATE'
TEXT                           = 'TEXT'
TEST                           = 'TEST'
!THAN                           = 'THAN'         !  already consumed by Terminals
THEN                           = 'THEN'
THRU                           = 'THRU' | 'THROUGH'
TIME                           = 'TIME'
TIME_OUT                       = 'TIME-OUT' | 'TIMEOUT'
TIMES                          = 'TIMES'
TO                             = 'TO'
TOK_EXTERN                     = 'EXTERN'
TOK_FALSE                      = 'FALSE'
TOK_FILE                       = 'FILE'
TOK_INITIAL                    = 'INITIAL'
TOK_NULL                       = 'NULL'
TOK_TRUE                       = 'TRUE'
TOWARD_GREATER                 = 'TOWARD-GREATER'
TOWARD_LESSER                  = 'TOWARD-LESSER'
TRAILING                       = 'TRAILING'
TRANSFORM                      = 'TRANSFORM'
TRUNCATION                     = 'TRUNCATION'
TYPE                           = 'TYPE'
U                              = 'U'
UNBOUNDED                      = 'UNBOUNDED'
UNDERLINE                      = 'UNDERLINE'
UNIT                           = 'UNIT'
UNLOCK                         = 'UNLOCK'
UNSIGNED                       = 'UNSIGNED'
UNSIGNED_INT                   = 'UNSIGNED-INT'
UNSIGNED_LONG                  = 'UNSIGNED-LONG'
UNSIGNED_SHORT                 = 'UNSIGNED-SHORT'
UNSTRING                       = 'UNSTRING'
UNTIL                          = 'UNTIL'
UP                             = 'UP'
UPDATE                         = 'UPDATE'
UPON                           = 'UPON'
UPPER                          = 'UPPER'
USAGE                          = 'USAGE'
USE                            = 'USE'
USER                           = 'USER'
USER_DEFAULT                   = 'USER-DEFAULT'
USING                          = 'USING'
V                              = 'V'
VALUE                          = 'VALUE' | 'VALUES'
VARIABLE                       = 'VARIABLE'
VARYING                        = 'VARYING'
WAIT                           = 'WAIT'
WHEN                           = 'WHEN'
WITH                           = 'WITH'
WORDS                          = 'WORDS'
WORKING_STORAGE                = 'WORKING-STORAGE'
WRITE                          = 'WRITE'
YYYYDDD                        = 'YYYYDDD'
YYYYMMDD                       = 'YYYYMMDD'
ZERO                           = 'ZERO' | 'ZEROS' | 'ZEROES'

! Terminals from scanner.l
! FIXME - these overlap with IntLiteral
SIXTY_SIX                      = '66'
SEVENTY_EIGHT                  = '78'
EIGHTY_EIGHT                   = '88'

TOK_OPEN_PAREN                 = '('
TOK_CLOSE_PAREN                = ')'
NOT_EQUAL                      = '<>'
EXPONENTIATION                 = '**' !exponentiation operator'
TOK_DOT                        = '.'
TOK_AMPER                      = '&'
TOK_COLON                      = ':'
TOK_EQUAL                      = '='
TOK_DIV                        = '/'
TOK_MUL                        = '*'
TOK_PLUS                       = '+'
TOK_MINUS                      = '-'
TOK_LESS                       = '<'
TOK_GREATER                    = '>'
COMMA_DELIM                    = ',' !comma delimiter'

END_PROGRAM                    = 'END' {Whitespace}+ 'PROGRAM'
END_FUNCTION                   = 'END' {Whitespace}+ 'FUNCTION'
PICTURE_SYMBOL                 = 'PICTURE' {Whitespace}+ 'SYMBOL'
FROM_CRT                       = 'FROM' {Whitespace}+ 'CRT'
SCREEN_CONTROL                 = 'SCREEN' {Whitespace}+ 'CONTROL'
EVENT_STATUS                   = 'EVENT' {Whitespace}+ 'STATUS'
READY_TRACE                    = 'READY' {Whitespace}+ 'TRACE'
RESET_TRACE                    = 'RESET' {Whitespace}+ 'TRACE'
GREATER_OR_EQUAL               = 'GREATER' ({Whitespace}+ 'THAN')? {Whitespace}+ 'OR' {Whitespace}+ ('EQUAL'|'EQUALS') ({Whitespace}+ 'TO')? {Whitespace}
                               | '>='
GREATER                        = 'GREATER' ({Whitespace}+ 'THAN')? {Whitespace}
LESS_OR_EQUAL                  = 'LESS'    ({Whitespace}+ 'THAN')? {Whitespace}+ 'OR' {Whitespace}+ ('EQUAL'|'EQUALS') ({Whitespace}+ 'TO')? {Whitespace}
                               | '<='
LESS                           = 'LESS'    ({Whitespace}+ 'THAN')? {Whitespace}
EQUAL                          = ('EQUAL'|'EQUALS')  ({Whitespace}+ 'TO')? {Whitespace}
TOP                            = ('LINES' {Whitespace}+ ('AT' {Whitespace}+)?)? 'TOP' {Whitespace}
BOTTOM                         = ('LINES' {Whitespace}+ ('AT' {Whitespace}+)?)? 'BOTTOM' {Whitespace}
NO_ADVANCING                   = ('WITH' {Whitespace}+)? 'NO' {Whitespace}+ 'ADVANCING'
NEXT_PAGE                      = ('ON' {Whitespace}+)? 'NEXT' {Whitespace}+ 'PAGE' {Whitespace}
NOT_SIZE_ERROR                 = 'NOT' {Whitespace}+ ('ON' {Whitespace}+)? 'SIZE' {Whitespace}+ 'ERROR' {Whitespace}
SIZE_ERROR                     = ('ON' {Whitespace}+)? 'SIZE' {Whitespace}+ 'ERROR' {Whitespace}
NOT_ESCAPE                     = 'NOT' {Whitespace}+ ('ON' {Whitespace}+)? 'ESCAPE' {Whitespace}
NOT_EXCEPTION                  = 'NOT' {Whitespace}+ ('ON' {Whitespace}+)? 'EXCEPTION' {Whitespace}
! CHECKME - Possible wrong to have ACCEPT var FROM *ON ESCAPE* KEY with same name
ESCAPE                         = 'ON' {Whitespace}+ 'ESCAPE' {Whitespace}
! CHECKME - Possible wrong to have ACCEPT var FROM *ON EXCEPTION* KEY with same name
EXCEPTION                      = 'ON' {Whitespace}+ 'EXCEPTION' {Whitespace}
NOT_OVERFLOW                   = 'NOT' {Whitespace}+ ('ON' {Whitespace}+)? 'OVERFLOW' {Whitespace}
NOT_END                        = 'NOT' {Whitespace}+ ('AT' {Whitespace}+)? 'END' {Whitespace}
! CHECKME - Possible wrong to have *AT END* DECLARATIVES with same name
END                            = ('AT' {Whitespace}+)? 'END' {Whitespace}
TOK_OVERFLOW                   = ('ON' {Whitespace}+)? 'OVERFLOW' {Whitespace}
NOT_EOP                        = 'NOT' {Whitespace}+ ('AT' {Whitespace}+)? 'END-OF-PAGE' {Whitespace}
                               | 'NOT' {Whitespace}+ ('AT' {Whitespace}+)? 'EOP' {Whitespace}
EOP                            = ('AT' {Whitespace}+)? 'END-OF-PAGE' {Whitespace}
                               | ('AT' {Whitespace}+)? 'EOP' {Whitespace}
NOT_INVALID_KEY                = 'NOT' {Whitespace}+ 'INVALID' ({Whitespace}+ 'KEY')? {Whitespace}
INVALID_KEY                    = 'INVALID' ({Whitespace}+ 'KEY')? {Whitespace}
NO_DATA                        = 'NO' {Whitespace}+ 'DATA' {Whitespace}
WITH_DATA                      = 'WITH' {Whitespace}+ 'DATA' {Whitespace} ! minor issue: with should be optional
UPON_ENVIRONMENT_NAME          = 'UPON' {Whitespace}+ 'ENVIRONMENT-NAME'
UPON_ENVIRONMENT_VALUE         = 'UPON' {Whitespace}+ 'ENVIRONMENT-VALUE'
UPON_ARGUMENT_NUMBER           = 'UPON' {Whitespace}+ 'ARGUMENT-NUMBER'
UPON_COMMAND_LINE              = 'UPON' {Whitespace}+ 'COMMAND-LINE'
EXCEPTION_CONDITION            = ('AFTER' {Whitespace}+)? 'EXCEPTION' {Whitespace}+ 'CONDITION' {Whitespace}
EC                             = ('AFTER' {Whitespace}+)? 'EC' {Whitespace}
LENGTH_OF                      = 'LENGTH' {Whitespace}+ 'OF' {Whitespace}

CONCATENATE                    = 'CONCATENATE'
CURRENT_DATE                   = 'CURRENT-DATE'
DISPLAY_OF                     = 'DISPLAY-OF'
FORMATTED_DATE                 = 'FORMATTED-DATE'
FORMATTED_DATETIME             = 'FORMATTED-DATETIME'
FORMATTED_TIME                 = 'FORMATTED-TIME'
LOCALE_DATE                    = 'LOCALE-DATE'
LOCALE_TIME                    = 'LOCALE-TIME'
LOCALE_TIME_FROM_SECONDS       = 'LOCALE-TIME-FROM-SECONDS'
LOWER_CASE                     = 'LOWER-CASE'
NATIONAL_OF                    = 'NATIONAL-OF'
NUMVAL_C                       = 'NUMVAL-C'
SUBSTITUTE                     = 'SUBSTITUTE'
SUBSTITUTE_CASE                = 'SUBSTITUTE-CASE'
TRIM                           = 'TRIM'
UPPER_CASE                     = 'UPPER-CASE'
WHEN_COMPILED                  = 'WHEN-COMPILED'

ABS                            = 'ABS'
ACOS                           = 'ACOS'
ANNUITY                        = 'ANNUITY'
ASIN                           = 'ASIN'
ATAN                           = 'ATAN'
BOOLEAN_OF_INTEGER             = 'BOOLEAN-OF-INTEGER'
CHAR                           = 'CHAR'
CHAR_NATIONAL                  = 'CHAR-NATIONAL'
COMBINED_DATETIME              = 'COMBINED-DATETIME'
COS                            = 'COS'
CURRENCY_SYMBOL                = 'CURRENCY-SYMBOL'
DATE_OF_INTEGER                = 'DATE-OF-INTEGER'
DATE_TO_YYYYMMDD               = 'DATE-TO-YYYYMMDD'
DAY_OF_INTEGER                 = 'DAY-OF-INTEGER'
DAY_TO_YYYYDDD                 = 'DAY-TO-YYYYDDD'
E                              = 'E'
EXCEPTION_FILE                 = 'EXCEPTION-FILE'
EXCEPTION_FILE_N               = 'EXCEPTION-FILE-N'
EXCEPTION_LOCATION             = 'EXCEPTION-LOCATION'
EXCEPTION_LOCATION_N           = 'EXCEPTION-LOCATION-N'
EXCEPTION_STATEMENT            = 'EXCEPTION-STATEMENT'
EXCEPTION_STATUS               = 'EXCEPTION-STATUS'
EXP                            = 'EXP'
FACTORIAL                      = 'FACTORIAL'
FORMATTED_CURRENT_DATE         = 'FORMATTED-CURRENT-DATE'
FRACTION_PART                  = 'FRACTION-PART'
HIGHEST_ALGEBRAIC              = 'HIGHEST-ALGEBRAIC'
INTEGER                        = 'INTEGER'
INTEGER_OF_BOOLEAN             = 'INTEGER-OF-BOOLEAN'
INTEGER_OF_DATE                = 'INTEGER-OF-DATE'
INTEGER_OF_DAY                 = 'INTEGER-OF-DAY'
INTEGER_OF_FORMATTED_DATE      = 'INTEGER-OF-FORMATTED-DATE'
INTEGER_PART                   = 'INTEGER-PART'
LOCALE_COMPARE                 = 'LOCALE-COMPARE'
LOG                            = 'LOG'
LOWEST_ALGEBRAIC               = 'LOWEST-ALGEBRAIC'
MAX                            = 'MAX'
MEAN                           = 'MEAN'
MEDIAN                         = 'MEDIAN'
MIDRANGE                       = 'MIDRANGE'
MIN                            = 'MIN'
MOD                            = 'MOD'
MODULE_CALLER_ID               = 'MODULE-CALLER-ID'
MODULE_DATE                    = 'MODULE-DATE'
MODULE_FORMATTED_DATE          = 'MODULE-FORMATTED-DATE'
MODULE_ID                      = 'MODULE-ID'
MODULE_PATH                    = 'MODULE-PATH'
MODULE_SOURCE                  = 'MODULE-SOURCE'
MODULE_TIME                    = 'MODULE-TIME'
MONETARY_DECIMAL_POINT         = 'MONETARY-DECIMAL-POINT'
MONETARY_THOUSANDS_SEPARATOR   = 'MONETARY-THOUSANDS-SEPARATOR'
NUMERIC_DECIMAL_POINT          = 'NUMERIC-DECIMAL-POINT'
NUMERIC_THOUSANDS_SEPARATOR    = 'NUMERIC-THOUSANDS-SEPARATOR'
NUMVAL                         = 'NUMVAL'
NUMVAL_F                       = 'NUMVAL-F'
ORD                            = 'ORD'
ORD_MAX                        = 'ORD-MAX'
ORD_MIN                        = 'ORD-MIN'
PI                             = 'PI'
PRESENT_VALUE                  = 'PRESENT-VALUE'
RANGE                          = 'RANGE'
REM                            = 'REM'
SECONDS_FROM_FORMATTED_TIME    = 'SECONDS-FROM-FORMATTED-TIME'
SECONDS_PAST_MIDNIGHT          = 'SECONDS-PAST-MIDNIGHT'
SIN                            = 'SIN'
SQRT                           = 'SQRT'
STANDARD_COMPARE               = 'STANDARD-COMPARE'
STANDARD_DEVIATION             = 'STANDARD-DEVIATION'
STORED_CHAR_LENGTH             = 'STORED-CHAR-LENGTH'
TAN                            = 'TAN'
TEST_DATE_YYYYMMDD             = 'TEST-DATE-YYYYMMDD'
TEST_DAY_YYYYDDD               = 'TEST-DAY-YYYYDDD'
TEST_FORMATTED_DATETIME        = 'TEST-FORMATTED-DATETIME'
TEST_NUMVAL                    = 'TEST-NUMVAL'
TEST_NUMVAL_F                  = 'TEST-NUMVAL-F'
VARIANCE                       = 'VARIANCE'
YEAR_TO_YYYY                   = 'YEAR-TO-YYYY'

AUTHOR                         = 'AUTHOR'
INSTALLATION                   = 'INSTALLATION'
DATE_WRITTEN                   = 'DATE-WRITTEN'
DATE_COMPILED                  = 'DATE-COMPILED'
SECURITY                       = 'SECURITY'
  
! ===================================================================

! Lexer Tokens
<CLASS_NAME>              ::= COBOLWord ! class-name
<FUNCTION_NAME>           ::= FUNCTION <COMMON_FUNCTION> ! intrinsic function name
<MNEMONIC_NAME_TOK>       ::= MNEMONIC_NAME ! FIXME: must be resolved by preparser as it is a COBOLWord ! Mnemonic name
<PROGRAM_NAME>            ::= COBOLWord ! program name
<USER_FUNCTION_NAME>      ::= FUNCTION COBOLWord ! user function name
<WORD>                    ::= COBOLWord ! Identifier
                          
<LITERAL_TOK>             ::= StringLiteral
                            | HexLiteral
                            | ZLiteral
                            | BooleanLiteral
                            | BooleanHexLiteral
                            | NationalLiteral
                            | NationalHexLiteral
                            | AcuBinNumLiteral
                            | AcuOctNumLiteral
                            | AcuHexNumLiteral
                            | IntLiteral
                            | DecimalLiteral
                            | SIXTY_SIX | SEVENTY_EIGHT | EIGHTY_EIGHT  ! hack, maybe moved to preparser
                            | FloatLiteral
                       !    | COBOLWord   ! because of CONSTANT / lvl-78 items, maybe moved to preparser [raises a reduce-reduce-conflict here]

<CONCATENATE_FUNC>        ::= FUNCTION CONCATENATE
<CURRENT_DATE_FUNC>       ::= FUNCTION CURRENT_DATE
<DISPLAY_OF_FUNC>         ::= FUNCTION DISPLAY_OF
<FORMATTED_DATE_FUNC>     ::= FUNCTION FORMATTED_DATE
<FORMATTED_DATETIME_FUNC> ::= FUNCTION FORMATTED_DATETIME
<FORMATTED_TIME_FUNC>     ::= FUNCTION FORMATTED_TIME
<LENGTH_FUNC>             ::= FUNCTION LENGTH
                            | FUNCTION BYTE_LENGTH
<LOCALE_DATE_FUNC>        ::= FUNCTION LOCALE_DATE
<LOCALE_TIME_FUNC>        ::= FUNCTION LOCALE_TIME
<LOCALE_TIME_FROM_FUNC>   ::= FUNCTION LOCALE_TIME_FROM_SECONDS
<LOWER_CASE_FUNC>         ::= FUNCTION LOWER_CASE

<NATIONAL_OF_FUNC>        ::= FUNCTION NATIONAL_OF
<NUMVALC_FUNC>            ::= FUNCTION NUMVAL_C
<REVERSE_FUNC>            ::= FUNCTION REVERSE        ! not optional -> Reduce/Reduce Conflict
<SUBSTITUTE_FUNC>         ::= FUNCTION SUBSTITUTE
<SUBSTITUTE_CASE_FUNC>    ::= FUNCTION SUBSTITUTE_CASE
<TRIM_FUNC>               ::= FUNCTION TRIM
<UPPER_CASE_FUNC>         ::= FUNCTION UPPER_CASE
<WHEN_COMPILED_FUNC>      ::= FUNCTION WHEN_COMPILED

<COMMON_FUNCTION>         ::= ABS
                            | ACOS
                            | ANNUITY
                            | ASIN
                            | ATAN
                            | BOOLEAN_OF_INTEGER
                            | CHAR
                            | CHAR_NATIONAL
                            | COMBINED_DATETIME
                            | COS
                            | CURRENCY_SYMBOL
                            | DATE_OF_INTEGER
                            | DATE_TO_YYYYMMDD
                            | DAY_OF_INTEGER
                            | DAY_TO_YYYYDDD
                            | E
                            | EXCEPTION_FILE
                            | EXCEPTION_FILE_N
                            | EXCEPTION_LOCATION
                            | EXCEPTION_LOCATION_N
                            | EXCEPTION_STATEMENT
                            | EXCEPTION_STATUS
                            | EXP
                            | FACTORIAL
                            | FORMATTED_CURRENT_DATE
                            | FRACTION_PART
                            | HIGHEST_ALGEBRAIC
                            | INTEGER
                            | INTEGER_OF_BOOLEAN
                            | INTEGER_OF_DATE
                            | INTEGER_OF_DAY
                            | INTEGER_OF_FORMATTED_DATE
                            | INTEGER_PART
                            | LOCALE_COMPARE
                            | LOG
                            | LOWEST_ALGEBRAIC
                            | MAX
                            | MEAN
                            | MEDIAN
                            | MIDRANGE
                            | MIN
                            | MOD
                            | MODULE_CALLER_ID
                            | MODULE_DATE
                            | MODULE_FORMATTED_DATE
                            | MODULE_ID
                            | MODULE_PATH
                            | MODULE_SOURCE
                            | MODULE_TIME
                            | MONETARY_DECIMAL_POINT
                            | MONETARY_THOUSANDS_SEPARATOR
                            | NUMERIC_DECIMAL_POINT
                            | NUMERIC_THOUSANDS_SEPARATOR
                            | NUMVAL
                            | NUMVAL_F
                            | ORD
                            | ORD_MAX
                            | ORD_MIN
                            | PI
                            | PRESENT_VALUE
                            | RANDOM
                            | RANGE
                            | REM
                            | SECONDS_FROM_FORMATTED_TIME
                            | SECONDS_PAST_MIDNIGHT
                            | SIGN
                            | SIN
                            | SQRT
                            | STANDARD_COMPARE
                            | STANDARD_DEVIATION
                            | STORED_CHAR_LENGTH
                            | SUM
                            | TAN
                            | TEST_DATE_YYYYMMDD
                            | TEST_DAY_YYYYDDD
                            | TEST_FORMATTED_DATETIME
                            | TEST_NUMVAL
                            | TEST_NUMVAL_F
                            | VARIANCE
                            | YEAR_TO_YYYY

! FIXME: maybe include via preparser
!<_FUNCTION> ::= !* empty *!
!              | FUNCTION

! ===================================================================

!* COBOL Compilation Unit *!

<start> !* {
    clear_initial_values ();
    current_program = NULL;
    defined_prog_list = NULL;
    cobc_cs_check = 0;
    main_flag_set = 0;
    current_program = cb_build_program (NULL, 0);
    cb_build_registers ();
  } *!
::=  <compilation_group>    !* {
    if (C_NOT current_program->flag_validated) !* {
        current_program->flag_validated = 1;
        cb_validate_program_body (current_program);
    } *!
    if (depth > 1) !* {
        cb_error (_("multiple PROGRAM-ID's without matching END PROGRAM"));
    } *!
    if (cobc_flag_main && C_NOT main_flag_set) !* {
        cb_error (_("executable requested but no program found"));
    } *!
    if (errorcount > 0) !* {
        YYABORT;
    } *!
    if (C_NOT current_program->entry_list) !* {
        emit_entry (current_program->program_id, 0, NULL, NULL);
    } *!
  } *!


<compilation_group>
::=  <simple_prog>  !* extension: single program without PROCEDURE DIVISION *!
| <nested_list>


<nested_list>   !* {
    first_prog = 1;
    depth = 0;
    setup_from_identification = 0;
  } *!
::=  <source_element_list>


<source_element_list>
::=  <source_element>
| <source_element_list> <source_element>


<source_element>
::=  <program_definition>
| <function_definition>


<simple_prog>   !* {
    cb_tree     l;

    current_section = NULL;
    current_paragraph = NULL;
    l = cb_build_alphanumeric_literal (demangle_name,
                       strlen (demangle_name));
    current_program->program_id = cb_build_program_id (l, NULL, 0);
    current_program->prog_type = CB_PROGRAM_TYPE;
    if (C_NOT main_flag_set) !* {
        main_flag_set = 1;
        current_program->flag_main = cobc_flag_main;
    } *!
    check_relaxed_syntax (COBC_HD_PROGRAM_ID);
  } *!
::=  <_program_body>    !* do cleanup *!    !* {
    clean_up_program (NULL, CB_PROGRAM_TYPE);
  } *!


<program_definition>
::=  <_identification_header>  <program_id_paragraph> <_Comment Items> <_options_paragraph>  <_program_body>  <_end_program_list>   !*
     The _end_program_list above is used for allowing an end marker
     in a program which contains a nested program can have an end marker.
  *!


<function_definition>
::=  <_identification_header>  <function_id_paragraph> <_Comment Items> <_options_paragraph>  <_program_body>  <end_function>

<_Comment Items>
        ::= <_Comment Items> <Comment Item>
         |  !Zero or more

<Comment Item>
        ::= AUTHOR        TOK_DOT <NoiseList> TOK_DOT
         |  INSTALLATION  TOK_DOT <NoiseList> TOK_DOT
         |  DATE_WRITTEN  TOK_DOT <NoiseList> TOK_DOT
         |  DATE_COMPILED TOK_DOT <NoiseList> TOK_DOT
         |  SECURITY      TOK_DOT <NoiseList> TOK_DOT

<NoiseList>
        ::= <NoiseList> <Noise>
         |  <Noise>

!* This list is only a very partial list
   --> the preparser should place the complete noise
       into one string literal per line *!
<Noise>
        ::= StringLiteral
         |  IntLiteral
         |  DecimalLiteral
         |  COBOLWord
         |  COMMA_DELIM

<_end_program_list>
::=  !* empty (still do cleanup) *! !* {
    clean_up_program (NULL, CB_PROGRAM_TYPE);
  } *!
| <end_program_list>


<end_program_list>
::=  <end_program>
| <end_program_list> <end_program>


<end_program>
::=  END_PROGRAM <end_program_name> TOK_DOT !* {
    first_nested_program = 0;
    clean_up_program ($2, CB_PROGRAM_TYPE);
  } *!


<end_function>
::=  END_FUNCTION <end_program_name> TOK_DOT    !* {
    clean_up_program ($2, CB_FUNCTION_TYPE);
  } *!

    !* PROGRAM body *!

<_program_body>
::=  <_environment_division>  <_data_division>  <_procedure_division>

    !* IDENTIFICATION DIVISION *!

<_identification_header>
::=  !* %prec SHIFT_PREFER *!
| <identification_or_id> DIVISION TOK_DOT   !* {
    setup_program_start ();
    setup_from_identification = 1;
  } *!



<identification_or_id>
::=  IDENTIFICATION | ID


<program_id_paragraph>
::=  PROGRAM_ID !* {
    cobc_in_id = 1;
  } *!  TOK_DOT <program_id_name> <_as_literal> !* {
    if (setup_program ($4, $5, CB_PROGRAM_TYPE)) !* {
        YYABORT;
    } *!

    setup_prototype ($4, $5, CB_PROGRAM_TYPE, 1);
  } *!  <_program_type> TOK_DOT !* {
    cobc_cs_check = 0;
    cobc_in_id = 0;
  } *!


<function_id_paragraph>
::=  FUNCTION_ID    !* {
    cobc_in_id = 1;
  } *!  TOK_DOT <program_id_name> <_as_literal> TOK_DOT !* {
    if (setup_program ($4, $5, CB_FUNCTION_TYPE)) !* {
        YYABORT;
    } *!
    setup_prototype ($4, $5, CB_FUNCTION_TYPE, 1);
    cobc_cs_check = 0;
    cobc_in_id = 0;
  } *!


<program_id_name>
::=  <PROGRAM_NAME>   !* {
    if (CB_REFERENCE_P ($1) && CB_WORD_COUNT ($1) > 0) !* {
        redefinition_error ($1);
    } *!    !*
      The program name is a key part of defining the current_program, so we
      mustn't lose it (unlike in undefined_word).
    *!
    $$ = $1;
  } *!
| <LITERAL_TOK>   !* {
    cb_trim_program_id ($1);
  } *!


<end_program_name>
::=  <PROGRAM_NAME>
| <LITERAL_TOK>   !* {
    cb_trim_program_id ($1);
  } *!


<_as_literal>
::=  !* empty *!            !* { $$ = NULL; } *!
| AS <LITERAL_TOK>            !* { $$ = $2; } *!


<_program_type>
::=| <_is> <program_type_clause> <_program>


<program_type_clause>
::=  COMMON !* {
    if (C_NOT current_program->nested_level) !* {
        cb_error (_("COMMON may only be used in a contained program"));
    } *! else !* {
        current_program->flag_common = 1;
        cb_add_common_prog (current_program);
    } *!
  } *!
| <init_or_recurse_and_common>  !* {
    if (C_NOT current_program->nested_level) !* {
        cb_error (_("COMMON may only be used in a contained program"));
    } *! else !* {
        current_program->flag_common = 1;
        cb_add_common_prog (current_program);
    } *!
  } *!
| <init_or_recurse>
| EXTERNAL  !* {
    CB_PENDING (_("CALL prototypes"));
  } *!


<init_or_recurse_and_common>
::=  <init_or_recurse> COMMON
| COMMON <init_or_recurse>


<init_or_recurse>
::=  TOK_INITIAL    !* {
    current_program->flag_initial = 1;
  } *!
| RECURSIVE !* {
    current_program->flag_recursive = 1;
  } *!


<_options_paragraph>
::=  !* empty *!
| OPTIONS TOK_DOT  <_options_clauses>   !* {
    cobc_cs_check = 0;
  } *!


<_options_clauses>
::=  <_default_rounded_clause>  <_entry_convention_clause>  <_intermediate_rounding_clause>  TOK_DOT


<_default_rounded_clause>
::=  !* empty *!    !* {
    default_rounded_mode = cb_int (COB_STORE_ROUND);
  } *!
| DEFAULT ROUNDED <_mode> <_is> <round_choice>  !* {
    if ($5) !* {
        default_rounded_mode = $5;
    } *! else !* {
        default_rounded_mode = cb_int (COB_STORE_ROUND);
    } *!
  } *!


<_entry_convention_clause>
::=  !* empty *!
| ENTRY_CONVENTION <_is> <convention_type>  !* {
    current_program->entry_convention = $3;
    current_program->entry_convention->source_file = cb_source_file;
    current_program->entry_convention->source_line = cb_source_line;
  } *!


<convention_type>
::=  COBOL  !* {
    $$ = cb_int (CB_CONV_COBOL);
  } *!
| TOK_EXTERN    !* {
    $$ = cb_int (0);
  } *!
| STDCALL   !* {
    $$ = cb_int (CB_CONV_STDCALL);
  } *!


<_intermediate_rounding_clause>
::=  !* empty *!
| INTERMEDIATE ROUNDING <_is> <intermediate_rounding_choice>    !* {
    CB_PENDING ("INTERMEDIATE ROUNDING");
  } *!


<intermediate_rounding_choice>
::=  NEAREST_AWAY_FROM_ZERO !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_NEAR_AWAY_FROM_ZERO);
  } *!
| NEAREST_EVEN  !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_NEAR_EVEN);
  } *!
| PROHIBITED    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_PROHIBITED);
  } *!
| TRUNCATION    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_TRUNCATION);
  } *!

    !* ENVIRONMENT DIVISION *!

<_environment_division>
::=  <_environment_header>  <_configuration_section>  <_input_output_section>


<_environment_header>
::=| ENVIRONMENT DIVISION TOK_DOT   !* {
    header_check |= COBC_HD_ENVIRONMENT_DIVISION;
  } *!

    !* CONFIGURATION SECTION *!

<_configuration_section>
::=  <_configuration_header>  <_source_object_computer_paragraphs>  <_special_names_paragraph>  <_special_names_sentence_list>  <_repository_paragraph>


<_configuration_header>
::=| CONFIGURATION SECTION TOK_DOT  !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_CONFIGURATION_SECTION;
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "CONFIGURATION SECTION");
    } *!
  } *!


<_source_object_computer_paragraphs>
::=| <source_computer_paragraph>
| <object_computer_paragraph>
| <source_computer_paragraph> <object_computer_paragraph>
| <object_computer_paragraph> <source_computer_paragraph>   !* {
    if (warningopt && (check_comp_duplicate & SYN_CLAUSE_2)) !* {
        cb_warning (_("phrases in non-standard order"));
    } *!
  } *!


    !* SOURCE-COMPUTER paragraph *!

<source_computer_paragraph>
::=  SOURCE_COMPUTER TOK_DOT    !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION, 0, 0);
    check_repeated ("SOURCE-COMPUTER", SYN_CLAUSE_1, &check_comp_duplicate);
  } *!  <_source_computer_entry>


<_source_computer_entry>
::=  !* %prec SHIFT_PREFER *!
| <computer_words> <_with_debugging_mode> TOK_DOT


<_with_debugging_mode>
::=| <_with> DEBUGGING MODE !* {
    cb_verify (cb_debugging_line, "DEBUGGING MODE");
    current_program->flag_debugging = 1;
    needs_debug_item = 1;
    cobc_cs_check = 0;
    cb_build_debug_item ();
  } *!

    !* OBJECT-COMPUTER paragraph *!

<object_computer_paragraph>
::=  OBJECT_COMPUTER TOK_DOT    !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION, 0, 0);
    check_repeated ("OBJECT-COMPUTER", SYN_CLAUSE_2, &check_comp_duplicate);
  } *!  <_object_computer_entry>


<_object_computer_entry>
::=  !* %prec SHIFT_PREFER *!
| <computer_words> TOK_DOT
| <computer_words> <object_clauses_list> TOK_DOT
| <object_clauses_list> TOK_DOT


<object_clauses_list>
::=  <object_clauses>
| <object_clauses_list> <object_clauses>


<object_clauses>
::=  <object_computer_memory>
| <object_computer_sequence>
| <object_computer_segment>
| <object_computer_class>


<object_computer_memory>
::=  MEMORY SIZE <_is> <integer> <object_char_or_word>  !* {
    cb_verify (cb_memory_size_clause, "MEMORY SIZE");
  } *!  !* Ignore *!


<object_computer_sequence>
::=  <prog_coll_sequence> <_is> <single_reference>  !* {
    current_program->collating_sequence = $3;
  } *!


<object_computer_segment>
::=  SEGMENT_LIMIT <_is> <integer>  !* {    !* Ignore *!
  } *!


<object_computer_class>
::=  <_character> CLASSIFICATION <_is> <locale_class>   !* {
    if (current_program->classification) !* {
        cb_error (_("duplicate CLASSIFICATION clause"));
    } *! else !* {
        current_program->classification = $4;
    } *!
  } *!


<locale_class>
::=  <single_reference> !* {
    $$ = $1;
  } *!
| LOCALE    !* {
    $$ = NULL;
  } *!
| USER_DEFAULT  !* {
    $$ = cb_int1;
  } *!
| SYSTEM_DEFAULT    !* {
    $$ = cb_int1;
  } *!


<computer_words>
::=  <WORD>
| <computer_words> <WORD>

    !* REPOSITORY paragraph *!

<_repository_paragraph>
::=| REPOSITORY TOK_DOT !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION, 0, 0);
  } *!  <_repository_entry> !* {
    cobc_in_repository = 0;
  } *!


<_repository_entry>
::=| <repository_list> TOK_DOT
!bison error token | <repository_list> <error> TOK_DOT
!* {
    yyerrok;
  } *!


<repository_list>
::=  <repository_name>
| <repository_list> <repository_name>


<repository_name>
::=  FUNCTION ALL INTRINSIC !* {
    functions_are_all = 1;
  } *!
| FUNCTION <WORD> <_as_literal>   !* {
    if ($2 <> cb_error_node) !* {
        setup_prototype ($2, $3, CB_FUNCTION_TYPE, 0);
    } *!
  } *!
| FUNCTION <repository_name_list> INTRINSIC
| PROGRAM <WORD> <_as_literal>    !* {
      if ($2 <> cb_error_node
          && cb_verify (cb_program_prototypes, _("PROGRAM phrase"))) !* {
        setup_prototype ($2, $3, CB_PROGRAM_TYPE, 0);
    } *!
  } *!


<repository_name_list>
::=  <FUNCTION_NAME>  !* {
    current_program->function_spec_list =
        cb_list_add (current_program->function_spec_list, $1);
  } *!
| <repository_name_list> <FUNCTION_NAME>  !* {
    current_program->function_spec_list =
        cb_list_add (current_program->function_spec_list, $2);
  } *!


    !* SPECIAL-NAMES paragraph *!

<_special_names_paragraph>
::=| SPECIAL_NAMES TOK_DOT  !* {
    check_duplicate = 0;
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION, 0, 0);
    header_check |= COBC_HD_SPECIAL_NAMES;
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *!
  } *!


<_special_names_sentence_list>
::=| <special_names_sentence_list>


<special_names_sentence_list>
::=  <special_name_list> TOK_DOT
| <special_names_sentence_list> <special_name_list> TOK_DOT


<special_name_list>
::=  <special_name>
| <special_name_list> <special_name>


<special_name>
::=  <mnemonic_name_clause>
| <alphabet_name_clause>
| <symbolic_characters_clause>
| <locale_clause>
| <class_name_clause>
| <currency_sign_clause>
| <decimal_point_clause>
| <numeric_sign_clause>
| <cursor_clause>
| <crt_status_clause>
| <screen_control>
| <event_status>
| COMMA_DELIM !* HACK, should not reach parser *!

    !* Mnemonic name clause *!

<mnemonic_name_clause>
::=  <WORD>   !* {
    char system_name[16];
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    check_duplicate = 0;
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
        save_tree = NULL;
    } *! else !* {  !* get system name and revert word-combination of scanner.l,
           if necessary (e.g. SWITCH A <--> SWITCH_A) *!
        system_name[15] = 0;
        strncpy(system_name, CB_NAME ($1), 15);
        if (system_name [6] == '_') !* {
            system_name [6] = ' ';
        } *!    !* lookup system name *!
        save_tree = lookup_system_name (system_name);
        if (C_NOT save_tree) !* {
            cb_error_x ($1, _("invalid system-name '%s'"), system_name);
        } *!
    } *!
  } *!  <mnemonic_choices>


<mnemonic_choices>
::=  <_is> CRT  !* {
    if (save_tree) !* {
        if (CB_SYSTEM_NAME(save_tree)->token <> CB_DEVICE_CONSOLE) !* {
            cb_error_x (save_tree, _("invalid %s clause"), "");
        } *! else !* {
            current_program->flag_console_is_crt = 1;
        } *!
    } *!
  } *!  !* CALL-CONVENTION n is ... *!
| <integer> <_is> <undefined_word>  !* {
    if (save_tree) !* {
        if (CB_SYSTEM_NAME(save_tree)->token <> CB_FEATURE_CONVENTION) !* {
            cb_error_x (save_tree, _("invalid %s clause"), "SPECIAL NAMES");
        } *! else if (CB_VALID_TREE ($3)) !* {
            CB_SYSTEM_NAME(save_tree)->value = $1;
            cb_define ($3, save_tree);
            CB_CHAIN_PAIR (current_program->mnemonic_spec_list,
                    $3, save_tree); !* remove non-standard context-sensitive words when identical to mnemonic *!
            if (strcasecmp (CB_NAME($3), "EXTERN") == 0 ||
                strcasecmp (CB_NAME($3), "STDCALL") == 0 ||
                strcasecmp (CB_NAME($3), "STATIC") == 0) !* {
                remove_context_sensitivity (CB_NAME($3), CB_CS_CALL);
            } *!
        } *!
    } *!
  } *!
| <_is> <undefined_word> <_special_name_mnemonic_on_off>    !* {
    if (save_tree && CB_VALID_TREE ($2)) !* {
        cb_define ($2, save_tree);
        CB_CHAIN_PAIR (current_program->mnemonic_spec_list,
                $2, save_tree);
    } *!
  } *!
| <on_off_clauses>


<_special_name_mnemonic_on_off>
::=| <on_off_clauses>


<on_off_clauses>
::=  <on_off_clauses_1> !* {
      check_on_off_duplicate = 0;
  } *!


<on_off_clauses_1>
::=  <on_or_off> <_onoff_status> <undefined_word>   !* {
    cb_tree     x;
    !* cb_define_switch_name checks param validity *!
    x = cb_define_switch_name ($3, save_tree, $1 == cb_int1);
    if (x) !* {
        if ($1 == cb_int1) !* {
            check_repeated ("ON", SYN_CLAUSE_1, &check_on_off_duplicate);
        } *! else !* {
            check_repeated ("OFF", SYN_CLAUSE_2, &check_on_off_duplicate);
        } *!
        CB_CHAIN_PAIR (current_program->mnemonic_spec_list, $3, x);
    } *!
  } *!
| <on_off_clauses_1> <on_or_off> <_onoff_status> <undefined_word>   !* {
    cb_tree     x;
    !* cb_define_switch_name checks param validity *!
    x = cb_define_switch_name ($4, save_tree, $2 == cb_int1);
    if (x) !* {
        if ($2 == cb_int1) !* {
            check_repeated ("ON", SYN_CLAUSE_1, &check_on_off_duplicate);
        } *! else !* {
            check_repeated ("OFF", SYN_CLAUSE_2, &check_on_off_duplicate);
        } *!
        CB_CHAIN_PAIR (current_program->mnemonic_spec_list, $4, x);
    } *!
  } *!

    !* ALPHABET clause *!

<alphabet_name_clause>
::=  ALPHABET <undefined_word>  !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
        $$ = NULL;
    } *! else !* {  !* Returns null on error *!
        $$ = cb_build_alphabet_name ($2);
    } *!
  } *!  <_is> <alphabet_definition> !* {
    if ($3) !* {
        current_program->alphabet_name_list =
            cb_list_add (current_program->alphabet_name_list, $3);
    } *!
    cobc_cs_check = 0;
  } *!


<alphabet_definition>
::=  NATIVE !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_NATIVE;
    } *!
  } *!
| STANDARD_1    !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_ASCII;
    } *!
  } *!
| STANDARD_2    !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_ASCII;
    } *!
  } *!
| EBCDIC    !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_EBCDIC;
    } *!
  } *!
| ASCII !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_ASCII;
    } *!
  } *!
| <alphabet_literal_list>   !* {
    if ($-1) !* {
        CB_ALPHABET_NAME ($-1)->alphabet_type = CB_ALPHABET_CUSTOM;
        CB_ALPHABET_NAME ($-1)->custom_list = $1;
    } *!
  } *!


<alphabet_literal_list>
::=  <alphabet_literal> !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <alphabet_literal_list> <alphabet_literal>    !* {
    $$ = cb_list_add ($1, $2);
  } *!


<alphabet_literal>
::=  <alphabet_lits>    !* {
    $$ = $1;
  } *!
| <alphabet_lits> THRU <alphabet_lits>  !* {
    $$ = CB_BUILD_PAIR ($1, $3);
  } *!
| <alphabet_lits> ALSO  !* {
    $$ = CB_LIST_INIT ($1);
  } *!  <alphabet_also_sequence>    !* {
    $$ = $3;
  } *!


<alphabet_also_sequence>
::=  <alphabet_lits>    !* {
    cb_list_add ($0, $1);
  } *!
| <alphabet_also_sequence> ALSO <alphabet_lits> !* {
    cb_list_add ($0, $3);
  } *!


<alphabet_lits>
::=  <LITERAL_TOK>            !* { $$ = $1; } *!
| SPACE             !* { $$ = cb_space; } *!
| ZERO              !* { $$ = cb_zero; } *!
| QUOTE             !* { $$ = cb_quote; } *!
| HIGH_VALUE            !* { $$ = cb_norm_high; } *!
| LOW_VALUE         !* { $$ = cb_norm_low; } *!


<space_or_zero>
::=  SPACE              !* { $$ = cb_space; } *!
| ZERO              !* { $$ = cb_zero; } *!


    !* SYMBOLIC characters clause *!

<symbolic_characters_clause>
::=  <symbolic_collection> <_sym_in_word>   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else if ($1) !* {
        CB_CHAIN_PAIR (current_program->symbolic_char_list, $1, $2);
    } *!
  } *!


<_sym_in_word>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| IN <WORD>   !* {
    $$ = $2;
  } *!


<symbolic_collection>
::=  !* %prec SHIFT_PREFER *!  SYMBOLIC <_characters> <symbolic_chars_list> !* {
    $$ = $3;
  } *!


<symbolic_chars_list>
::=  <symbolic_chars_phrase>    !* {
    $$ = $1;
  } *!
| <symbolic_chars_list> <symbolic_chars_phrase> !* {
    if ($2) !* {
        $$ = cb_list_append ($1, $2);
    } *! else !* {
        $$ = $1;
    } *!
  } *!


<symbolic_chars_phrase>
::=  <char_list> <_is_are> <integer_list>   !* {
    cb_tree     l1;
    cb_tree     l2;

    if (cb_list_length ($1) <> cb_list_length ($3)) !* {
        cb_error (_("invalid %s clause"), "SYMBOLIC");
        $$ = NULL;
    } *! else !* {
        l1 = $1;
        l2 = $3;
        for (; l1; l1 = CB_CHAIN (l1), l2 = CB_CHAIN (l2)) !* {
            CB_PURPOSE (l1) = CB_VALUE (l2);
        } *!
        $$ = $1;
    } *!
  } *!


<char_list>
::=  <unique_word>  !* {
    if ($1 == NULL) !* {
        $$ = NULL;
    } *! else !* {
        $$ = CB_LIST_INIT ($1);
    } *!
  } *!
| <char_list> <unique_word> !* {
    if ($2 == NULL) !* {
        $$ = $1;
    } *! else !* {
        $$ = cb_list_add ($1, $2);
    } *!
  } *!


<integer_list>
::=  <symbolic_integer>     !* { $$ = CB_LIST_INIT ($1); } *!
| <integer_list> <symbolic_integer> !* { $$ = cb_list_add ($1, $2); } *!

    !* CLASS clause *!

<class_name_clause>
::=  CLASS <undefined_word> <_is> <class_item_list> !* {
    cb_tree     x;

    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {  !* Returns null on error *!
        x = cb_build_class_name ($2, $4);
        if (x) !* {
            current_program->class_name_list =
                cb_list_add (current_program->class_name_list, x);
        } *!
    } *!
  } *!


<class_item_list>
::=  <class_item>           !* { $$ = CB_LIST_INIT ($1); } *!
| <class_item_list> <class_item>    !* { $$ = cb_list_add ($1, $2); } *!


<class_item>
::=  <class_value>  !* {
    $$ = $1;
  } *!
| <class_value> THRU <class_value>  !* {
    if (CB_TREE_CLASS ($1) <> CB_CLASS_NUMERIC &&
        CB_LITERAL_P ($1) && CB_LITERAL ($1)->size <> 1) !* {
        cb_error (_("CLASS literal with THRU must have size 1"));
    } *!
    if (CB_TREE_CLASS ($3) <> CB_CLASS_NUMERIC &&
        CB_LITERAL_P ($3) && CB_LITERAL ($3)->size <> 1) !* {
        cb_error (_("CLASS literal with THRU must have size 1"));
    } *!
    if (literal_value ($1) <= literal_value ($3)) !* {
        $$ = CB_BUILD_PAIR ($1, $3);
    } *! else !* {
        $$ = CB_BUILD_PAIR ($3, $1);
    } *!
  } *!

    !* LOCALE clause *!

<locale_clause>
::=  LOCALE <undefined_word> <_is> <LITERAL_TOK>  !* {
    cb_tree l;

    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {  !* Returns null on error *!
        l = cb_build_locale_name ($2, $4);
        if (l) !* {
            current_program->locale_list =
                cb_list_add (current_program->locale_list, l);
        } *!
    } *!
  } *!

    !* CURRENCY SIGN clause *!

<currency_sign_clause>
::=  CURRENCY <_sign> <_is> <LITERAL_TOK> <_with_pic_symbol>  !* {
    unsigned char   *s = CB_LITERAL ($4)->data;
    unsigned int    error_ind = 0;
    unsigned int    char_seen = 0;

    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("CURRENCY", SYN_CLAUSE_1, &check_duplicate);
        if (strcmp("$", (const char *)s) <> 0) !* {
            if ($5 && CB_LITERAL ($4)->size <> 1) !* {
                CB_PENDING_X ($4, _("CURRENCY SIGN longer than one character"));
                error_ind = 1;
            } *!
            while (*s) !* {
                switch (*s) !* {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '+':
                case '-':
                case ',':
                case '.':
                case '*':
                    error_ind = 2;
                    break;
                case ' ':
                    break;
                default:
                    char_seen = 1;
                    break;
                } *!
                s++;
            } *!
            if (C_NOT char_seen) !* {
                error_ind = 2;
            } *!
        } *! else !* {
            if (error_ind > 1) !* {;
                CB_PENDING_X ($4, _("CURRENCY SIGN other than '$'"));
            } *!
        } *!
        switch (error_ind) !* {
        case 0:
        case 1: !* FIXME: currency sign/symbol are currently mixed in cobc and libcob *!    !* current_program->currency_sign = CB_LITERAL ($4); *!
            break;
        default:
            cb_error_x ($4, _("invalid CURRENCY SIGN '%s'"), (char*)CB_LITERAL ($4)->data);
            break;
        } *!
        if ($5) !* {
            set_currency_picture_symbol ($5);
        } *! else !* {
            set_currency_picture_symbol ($4);
        } *!
    } *!
  } *!



<_with_pic_symbol>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <_with> PICTURE_SYMBOL <LITERAL_TOK>    !* {
    $$ = $3;
  } *!

    !* DECIMAL-POINT clause *!

<decimal_point_clause>
::=  DECIMAL_POINT <_is> COMMA  !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("DECIMAL-POINT", SYN_CLAUSE_2, &check_duplicate);
        current_program->decimal_point = ',';
        current_program->numeric_separator = '.';
    } *!
  } *!


    !* NUMERIC SIGN clause *!

<numeric_sign_clause>
::=  NUMERIC SIGN <_is> TRAILING SEPARATE   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        current_program->flag_trailing_separate = 1;
    } *!
  } *!

    !* CURSOR clause *!

<cursor_clause>
::=  CURSOR <_is> <reference>   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("CURSOR", SYN_CLAUSE_3, &check_duplicate);
        current_program->cursor_pos = $3;
    } *!
  } *!


    !* CRT STATUS clause *!

<crt_status_clause>
::=  CRT STATUS <_is> <reference>   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("CRT STATUS", SYN_CLAUSE_4, &check_duplicate);
        current_program->crt_status = $4;
    } *!
  } *!


    !* SCREEN CONTROL *!

<screen_control>
::=  SCREEN_CONTROL <_is> <reference>   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("SCREEN CONTROL", SYN_CLAUSE_5, &check_duplicate);
        CB_PENDING ("SCREEN CONTROL");
    } *!
  } *!

    !* EVENT STATUS *!

<event_status>
::=  EVENT_STATUS <_is> <reference> !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_SPECIAL_NAMES, 0);
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "SPECIAL-NAMES");
    } *! else !* {
        check_repeated ("EVENT STATUS", SYN_CLAUSE_6, &check_duplicate);
        CB_PENDING ("EVENT STATUS");
    } *!
  } *!

    !* INPUT-OUTPUT SECTION *!

<_input_output_section>
::=  <_input_output_header>  <_file_control_header>  <_file_control_sequence>  <_i_o_control_header>  <_i_o_control>    !* {
    cb_validate_program_environment (current_program);
  } *!


<_input_output_header>
::=| INPUT_OUTPUT SECTION TOK_DOT   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_INPUT_OUTPUT_SECTION;
  } *!


<_file_control_header>
::=| FILE_CONTROL TOK_DOT   !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_INPUT_OUTPUT_SECTION, 0, 0);
    header_check |= COBC_HD_FILE_CONTROL;
  } *!


<_i_o_control_header>
::=| I_O_CONTROL TOK_DOT    !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_INPUT_OUTPUT_SECTION, 0, 0);
    header_check |= COBC_HD_I_O_CONTROL;
  } *!

    !* FILE-CONTROL paragraph *!

<_file_control_sequence>
::=| <_file_control_sequence> <file_control_entry>


<file_control_entry>
::=  SELECT <flag_optional> <undefined_word>    !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_INPUT_OUTPUT_SECTION,
                   COBC_HD_FILE_CONTROL, 0);
    check_duplicate = 0;
    if (CB_VALID_TREE ($3)) !* {    !* Build new file *!
        current_file = build_file ($3);
        current_file->optional = CB_INTEGER ($2)->val;
    !* Add file to current program list *!
        CB_ADD_TO_CHAIN (CB_TREE (current_file),
                 current_program->file_list);
    } *! else if (current_program->file_list) !* {
        current_program->file_list
            = CB_CHAIN (current_program->file_list);
    } *!
  } *!  <_select_clauses_or_error>  !* {
    if (CB_VALID_TREE ($3)) !* {
        validate_file (current_file, $3);
    } *!
  } *!


<_select_clauses_or_error>
::=  <_select_clause_sequence> TOK_DOT
!bison error token | <error> TOK_DOT
   !* {
    yyerrok;
  } *!


<_select_clause_sequence>
::=| <_select_clause_sequence> <select_clause>


<select_clause>
::=  <assign_clause>
| <access_mode_clause>
| <alternative_record_key_clause>
| <collating_sequence_clause>
| <file_status_clause>
| <lock_mode_clause>
| <organization_clause>
| <padding_character_clause>
| <record_delimiter_clause>
| <record_key_clause>
| <relative_key_clause>
| <reserve_clause>
| <sharing_clause>


    !* ASSIGN clause *!

<assign_clause>
::=  ASSIGN <_to_using> <_ext_clause> <_line_adv_file> <assignment_name>    !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    current_file->assign = cb_build_assignment_name (current_file, $5);
  } *!
| ASSIGN <_to_using> <_ext_clause> <general_device_name> <_assignment_name> !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    if ($5) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *! else !* {
        current_file->flag_fileid = 1;
    } *!
  } *!
| ASSIGN <_to_using> <_ext_clause> <line_seq_device_name> <_assignment_name>    !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    current_file->organization = COB_ORG_LINE_SEQUENTIAL;
    if ($5) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *! else !* {
        current_file->flag_fileid = 1;
    } *!
  } *!
| ASSIGN <_to_using> <_ext_clause> DISPLAY <_assignment_name>   !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    if ($5) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *! else !* {
        current_file->flag_ext_assign = 0;
        current_file->assign =
            cb_build_alphanumeric_literal ("stdout", (size_t)6);
        current_file->special = COB_SELECT_STDOUT;
    } *!
  } *!
| ASSIGN <_to_using> <_ext_clause> KEYBOARD <_assignment_name>  !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    if ($5) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *! else !* {
        current_file->flag_ext_assign = 0;
        current_file->assign =
            cb_build_alphanumeric_literal ("stdin", (size_t)5);
        current_file->special = COB_SELECT_STDIN;
    } *!
  } *!
| ASSIGN <_to_using> <_ext_clause> <printer_name> <_assignment_name>    !* {
    check_repeated ("ASSIGN", SYN_CLAUSE_1, &check_duplicate);
    cobc_cs_check = 0;
    current_file->organization = COB_ORG_LINE_SEQUENTIAL;
    if ($5) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *! else !* {  !* RM/COBOL always expects an assignment name here - we ignore this
           for PRINTER + PRINTER-1 as ACUCOBOL allows this for using as alias *!
        current_file->flag_ext_assign = 0;
        if ($4 == cb_int0) !* {
            current_file->assign =
                cb_build_alphanumeric_literal ("PRINTER", (size_t)7);
        } *! else if ($4 == cb_int1) !* {
            current_file->assign =
                cb_build_alphanumeric_literal ("PRINTER-1", (size_t)9);
        } *! else !* {
            current_file->assign =
                cb_build_alphanumeric_literal ("LPT1", (size_t)4);
        } *!

    } *!
  } *!


    !* Indicates a print-file *!    !* Hint: R/M-COBOL has PRINTER01 thru PRINTER99 !
         MF-COBOL handles these identical to PRINTER-1,
         with an optional file name PRINTER01 thru PRINTER99
*!
<printer_name>
::=  PRINTER    !* { $$ = cb_int0; } *!
| PRINTER_1 !* { $$ = cb_int1; } *!
| PRINT     !* { $$ = cb_int4; } *!

    !* Indicates no special processing *!
<general_device_name>
::=  DISC
| DISK
| TAPE
| RANDOM


<line_seq_device_name>
::=  CARD_PUNCH
| CARD_READER
| CASSETTE
| INPUT
| INPUT_OUTPUT
| MAGNETIC_TAPE
| OUTPUT


<_line_adv_file>
::=| LINE ADVANCING <_file> !* {
    current_file->flag_line_adv = 1;
  } *!


<_ext_clause>
::=| EXTERNAL   !* {
    current_file->flag_ext_assign = 1;
  } *!
| DYNAMIC


<assignment_name>
::=  <LITERAL_TOK>
| <qualified_word>


<_assignment_name>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <LITERAL_TOK>
| <qualified_word>


    !* ACCESS MODE clause *!

<access_mode_clause>
::=  ACCESS <_mode> <_is> <access_mode> !* {
    cobc_cs_check = 0;
    check_repeated ("ACCESS", SYN_CLAUSE_2, &check_duplicate);
  } *!


<access_mode>
::=  SEQUENTIAL     !* { current_file->access_mode = COB_ACCESS_SEQUENTIAL; } *!
| DYNAMIC       !* { current_file->access_mode = COB_ACCESS_DYNAMIC; } *!
| RANDOM        !* { current_file->access_mode = COB_ACCESS_RANDOM; } *!


    !* ALTERNATIVE RECORD KEY clause *!

<alternative_record_key_clause>
::=  ALTERNATE <_record> <_key> <_is> <key_or_split_keys> <flag_duplicates> <_suppress_clause>  !* {
    struct cb_alt_key *p;
    struct cb_alt_key *l;

    p = cobc_parse_malloc (sizeof (struct cb_alt_key));
    p->key = $5;
    p->duplicates = CB_INTEGER ($6)->val;
    p->next = NULL;
    !* Add to the end of list *!
    if (current_file->alt_key_list == NULL) !* {
        current_file->alt_key_list = p;
    } *! else !* {
        l = current_file->alt_key_list;
        for (; l->next; l = l->next) !* { ; } *!
        l->next = p;
    } *!
  } *!


<_suppress_clause>
::=  !* empty *!                   !* { } *!
|  SUPPRESS WHEN ALL <basic_value>  !* {
    CB_PENDING ("SUPPRESS WHEN ALL");
  } *!
|  SUPPRESS WHEN <space_or_zero>    !* {
    CB_PENDING ("SUPPRESS WHEN SPACE/ZERO");
  } *!


    !* COLLATING SEQUENCE clause *!

<collating_sequence_clause>
::=  <coll_sequence> <_is> <alphabet_name>  !* {
    check_repeated ("COLLATING", SYN_CLAUSE_3, &check_duplicate);
    CB_PENDING ("COLLATING SEQUENCE");
  } *!


<alphabet_name>
::=  <WORD>   !* {
      if (CB_ALPHABET_NAME_P (cb_ref ($1))) !* {
          $$ = $1;
      } *! else !* {
          cb_error_x ($1, _("'%s' is not an alphabet-name"),
                  cb_name ($1));
          $$ = cb_error_node;
      } *!
  } *!

    !* FILE STATUS clause *!

<file_status_clause>
::=  <_file_or_sort> STATUS <_is> <reference>   !* {
    check_repeated ("STATUS", SYN_CLAUSE_4, &check_duplicate);
    current_file->file_status = $4;
  } *!


<_file_or_sort>
::=  !* empty *!
| TOK_FILE
| SORT

    !* LOCK MODE clause *!

<lock_mode_clause>
::=  !* {
    check_repeated ("LOCK", SYN_CLAUSE_5, &check_duplicate);
  } *!  LOCK <_mode> <_is> <lock_mode>


<lock_mode>
::=  MANUAL <_lock_with>    !* {
    current_file->lock_mode |= COB_LOCK_MANUAL;
    cobc_cs_check = 0;
  } *!
| AUTOMATIC <_lock_with>    !* {
    current_file->lock_mode |= COB_LOCK_AUTOMATIC;
    cobc_cs_check = 0;
  } *!
| EXCLUSIVE !* {
    current_file->lock_mode |= COB_LOCK_EXCLUSIVE;
    cobc_cs_check = 0;
  } *!


<_lock_with>
::=| WITH LOCK ON <lock_records>
| WITH LOCK ON MULTIPLE <lock_records>  !* {
    current_file->lock_mode |= COB_LOCK_MULTIPLE;
  } *!
| WITH ROLLBACK !* {
    current_file->lock_mode |= COB_LOCK_MULTIPLE;
    CB_PENDING ("WITH ROLLBACK");
  } *!


    !* ORGANIZATION clause *!

<organization_clause>
::=  ORGANIZATION <_is> <organization>
| <organization>


<organization>
::=  INDEXED    !* {
    check_repeated ("ORGANIZATION", SYN_CLAUSE_6, &check_duplicate);
    current_file->organization = COB_ORG_INDEXED;
  } *!
| <_record> <_binary> SEQUENTIAL    !* {
    check_repeated ("ORGANIZATION", SYN_CLAUSE_6, &check_duplicate);
    current_file->organization = COB_ORG_SEQUENTIAL;
  } *!
| RELATIVE  !* {
    check_repeated ("ORGANIZATION", SYN_CLAUSE_6, &check_duplicate);
    current_file->organization = COB_ORG_RELATIVE;
  } *!
| LINE SEQUENTIAL   !* {
    check_repeated ("ORGANIZATION", SYN_CLAUSE_6, &check_duplicate);
    current_file->organization = COB_ORG_LINE_SEQUENTIAL;
  } *!


    !* PADDING CHARACTER clause *!

<padding_character_clause>
::=  PADDING <_character> <_is> <reference_or_literal>  !* {
    check_repeated ("PADDING", SYN_CLAUSE_7, &check_duplicate);
    cb_verify (cb_padding_character_clause, "PADDING CHARACTER");
  } *!


    !* RECORD DELIMITER clause *!

<record_delimiter_clause>
::=  RECORD DELIMITER <_is> STANDARD_1  !* {
    check_repeated ("RECORD DELIMITER", SYN_CLAUSE_8, &check_duplicate);
  } *!


    !* RECORD KEY clause *!

<record_key_clause>
::=  RECORD <_key> <_is> <key_or_split_keys>    !* {
    check_repeated ("RECORD KEY", SYN_CLAUSE_9, &check_duplicate);
    current_file->key = $4;
  } *!


<key_or_split_keys>
::=  <reference>                !* { $$ = $1; } *!
| <reference> TOK_EQUAL <reference_list>    !* { CB_PENDING ("SPLIT KEYS"); } *!
| <reference> SOURCE <_is> <reference_list> !* { CB_PENDING ("SPLIT KEYS"); } *!

    !* RELATIVE KEY clause *!

<relative_key_clause>
::=  RELATIVE <_key> <_is> <reference>  !* {
    check_repeated ("RELATIVE KEY", SYN_CLAUSE_10, &check_duplicate);
    current_file->key = $4;
  } *!


    !* RESERVE clause *!

<reserve_clause>
::=  RESERVE <no_or_integer> <_areas>   !* {
    check_repeated ("RESERVE", SYN_CLAUSE_11, &check_duplicate);
  } *!


<no_or_integer>
::=  NO
| <integer>

    !* SHARING clause *!

<sharing_clause>
::=  SHARING <_with> <sharing_option>   !* {
    check_repeated ("SHARING", SYN_CLAUSE_12, &check_duplicate);
    current_file->sharing = $3;
  } *!


<sharing_option>
::=  ALL <_other>           !* { $$ = NULL; } *!
| NO <_other>           !* { $$ = cb_int (COB_LOCK_OPEN_EXCLUSIVE); } *!
| READ ONLY         !* { $$ = NULL; } *!


    !* I-O-CONTROL paragraph *!

<_i_o_control>
::=| <i_o_control_list> TOK_DOT
!bison error token | <i_o_control_list> <error> TOK_DOT
  !* {
    yyerrok;
  } *!


<i_o_control_list>
::=  <i_o_control_clause>
| <i_o_control_list> <i_o_control_clause>


<i_o_control_clause>
::=  <same_clause>
| <multiple_file_tape_clause>

    !* SAME clause *!

<same_clause>
::=  SAME <_same_option> <_area> <_for> <file_name_list>    !* {
    cb_tree l;

    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_I_O_CONTROL, 0);
    switch (CB_INTEGER ($2)->val) !* {
    case 0: !* SAME AREA *!
        break;
    case 1: !* SAME RECORD *!
        for (l = $5; l; l = CB_CHAIN (l)) !* {
            if (CB_VALID_TREE (CB_VALUE (l))) !* {
                CB_FILE (cb_ref (CB_VALUE (l)))->same_clause = same_area;
            } *!
        } *!
        same_area++;
        break;
    case 2: !* SAME SORT-MERGE *!
        break;
    } *!
  } *!


<_same_option>
::=  !* empty *!            !* { $$ = cb_int0; } *!
| RECORD            !* { $$ = cb_int1; } *!
| SORT              !* { $$ = cb_int2; } *!
| SORT_MERGE            !* { $$ = cb_int2; } *!

    !* MULTIPLE FILE TAPE clause *!

<multiple_file_tape_clause>
::=  MULTIPLE   !* {    !* Fake for TAPE *!
    cobc_cs_check = CB_CS_ASSIGN;
  } *!  <_file> <_tape> <_contains> <multiple_file_list>    !* {
    check_headers_present (COBC_HD_ENVIRONMENT_DIVISION,
                   COBC_HD_CONFIGURATION_SECTION,
                   COBC_HD_I_O_CONTROL, 0);
    cb_verify (cb_multiple_file_tape_clause, "MULTIPLE FILE TAPE");
    cobc_cs_check = 0;
  } *!


<multiple_file_list>
::=  <multiple_file>
| <multiple_file_list> <multiple_file>


<multiple_file>
::=  <file_name> <_multiple_file_position>


<_multiple_file_position>
::=| POSITION <integer>


    !* DATA DIVISION *!

<_data_division>
::=  <_data_division_header>  <_file_section_header>  <_file_description_sequence>  !* {
    current_storage = CB_STORAGE_WORKING;
  } *!  <_working_storage_section>  <_communication_section>  <_local_storage_section>  <_linkage_section>  <_report_section>  <_screen_section>    !* {
    cb_validate_program_data (current_program);
  } *!


<_data_division_header>
::=| DATA DIVISION TOK_DOT  !* {
    header_check |= COBC_HD_DATA_DIVISION;
  } *!

    !* FILE SECTION *!

<_file_section_header>
::=| TOK_FILE SECTION TOK_DOT   !* {
    current_storage = CB_STORAGE_FILE;
    check_headers_present (COBC_HD_DATA_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_FILE_SECTION;
  } *!


<_file_description_sequence>
::=| <_file_description_sequence> <file_description>


<file_description>
::=  <file_description_entry>  <_record_description_list>   !* {
    if (CB_VALID_TREE (current_file)) !* {
        if (CB_VALID_TREE ($2)) !* {
            if (current_file->reports) !* {
                cb_error (_("RECORD description invalid with REPORT"));
            } *! else !* {
                finalize_file (current_file, CB_FIELD ($2));
            } *!
        } *! else if (C_NOT current_file->reports) !* {
            cb_error (_("RECORD description missing or invalid"));
        } *!
    } *!
  } *!

    !* File description entry *!

<file_description_entry>
::=  <file_type> <file_name>    !* {
    current_storage = CB_STORAGE_FILE;
    check_headers_present (COBC_HD_DATA_DIVISION,
                   COBC_HD_FILE_SECTION, 0, 0);
    check_duplicate = 0;
    if (CB_INVALID_TREE ($2) || cb_ref ($2) == cb_error_node) !* {
        YYERROR;
    } *!
    current_file = CB_FILE (cb_ref ($2));
    if (CB_VALID_TREE (current_file)) !* {
        if ($1) !* {
            current_file->organization = COB_ORG_SORT;
        } *!
    } *!
  } *!  <_file_description_clause_sequence> TOK_DOT
!bison error token | <file_type> <error> TOK_DOT 
!* {
    yyerrok;
  } *!


<file_type>
::=  FD !* {
    $$ = NULL;
  } *!
| SD    !* {
    $$ = cb_int1;
  } *!


<_file_description_clause_sequence>
::=| <_file_description_clause_sequence> <file_description_clause>


<file_description_clause>
::=  <_is> EXTERNAL !* {
    check_repeated ("EXTERNAL", SYN_CLAUSE_1, &check_duplicate);
#if 0   !* RXWRXW - Global/External *!
    if (current_file->flag_global) !* {
        cb_error (_("file cannot have both EXTERNAL and GLOBAL clauses"));
    } *!
#endif
    current_file->flag_external = 1;
  } *!
| <_is> GLOBAL  !* {
    check_repeated ("GLOBAL", SYN_CLAUSE_2, &check_duplicate);
#if 0   !* RXWRXW - Global/External *!
    if (current_file->flag_external) !* {
        cb_error (_("file cannot have both EXTERNAL and GLOBAL clauses"));
    } *!
#endif
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("%s is invalid in a user FUNCTION"), "GLOBAL");
    } *! else !* {
        current_file->flag_global = 1;
        current_program->flag_file_global = 1;
    } *!
  } *!
| <block_contains_clause>
| <record_clause>
| <label_records_clause>
| <value_of_clause>
| <data_records_clause>
| <linage_clause>
| <recording_mode_clause>
| <code_set_clause>
| <report_clause>


    !* BLOCK CONTAINS clause *!

<block_contains_clause>
::=  BLOCK <_contains> <integer> <_to_integer> <_records_or_characters> !* {
    check_repeated ("BLOCK", SYN_CLAUSE_3, &check_duplicate);   !* ignore *!
  } *!


<_records_or_characters> ::=    | RECORDS | CHARACTERS

    !* RECORD clause *!

<record_clause>
::=  RECORD <_contains> <integer> <_characters> !* {
    check_repeated ("RECORD", SYN_CLAUSE_4, &check_duplicate);
    if (current_file->organization == COB_ORG_LINE_SEQUENTIAL) !* {
        if (warningopt) !* {
            cb_warning (_("RECORD clause ignored for LINE SEQUENTIAL"));
        } *!
    } *! else !* {
        current_file->record_max = cb_get_int ($3);
        if (current_file->record_max < 1)  !* {
            current_file->record_max = 1;
            cb_error (_("RECORD clause invalid"));
        } *!
        if (current_file->record_max > MAX_FD_RECORD)  !* {
            current_file->record_max = MAX_FD_RECORD;
            cb_error (_("RECORD size exceeds maximum allowed (%d)"),
                  MAX_FD_RECORD);
        } *!
    } *!
  } *!
| RECORD <_contains> <integer> TO <integer> <_characters>   !* {
    int error_ind = 0;

    check_repeated ("RECORD", SYN_CLAUSE_4, &check_duplicate);
    if (current_file->organization == COB_ORG_LINE_SEQUENTIAL) !* {
        if (warningopt) !* {
            cb_warning (_("RECORD clause ignored for LINE SEQUENTIAL"));
        } *!
    } *! else !* {
        current_file->record_min = cb_get_int ($3);
        current_file->record_max = cb_get_int ($5);
        if (current_file->record_min < 0)  !* {
            current_file->record_min = 0;
            error_ind = 1;
        } *!
        if (current_file->record_max < 1)  !* {
            current_file->record_max = 1;
            error_ind = 1;
        } *!
        if (current_file->record_max > MAX_FD_RECORD)  !* {
            current_file->record_max = MAX_FD_RECORD;
            cb_error (_("RECORD size exceeds maximum allowed (%d)"),
                  MAX_FD_RECORD);
            error_ind = 1;
        } *!
        if (current_file->record_max <= current_file->record_min)  !* {
            error_ind = 1;
        } *!
        if (error_ind) !* {
            cb_error (_("RECORD clause invalid"));
        } *!
    } *!
  } *!
| RECORD <_is> VARYING <_in> <_size> <_from_integer> <_to_integer> <_characters>  <_record_depending>   !* {
    int error_ind = 0;

    check_repeated ("RECORD", SYN_CLAUSE_4, &check_duplicate);
    current_file->record_min = $6 ? cb_get_int ($6) : 0;
    current_file->record_max = $7 ? cb_get_int ($7) : 0;
    if ($6 && current_file->record_min < 0)  !* {
        current_file->record_min = 0;
        error_ind = 1;
    } *!
    if ($7 && current_file->record_max < 1)  !* {
        current_file->record_max = 1;
        error_ind = 1;
    } *!
    if ($7 && current_file->record_max > MAX_FD_RECORD)  !* {
        current_file->record_max = MAX_FD_RECORD;
        cb_error (_("RECORD size exceeds maximum allowed (%d)"),
              MAX_FD_RECORD);
        error_ind = 1;
    } *!
    if (($6 || $7) && current_file->record_max <= current_file->record_min)  !* {
        error_ind = 1;
    } *!
    if (error_ind) !* {
        cb_error (_("RECORD clause invalid"));
    } *!
  } *!


<_record_depending>
::=| DEPENDING <_on> <reference>    !* {
    current_file->record_depending = $3;
  } *!


<_from_integer>
::=  !* empty *!            !* { $$ = NULL; } *!
| <_from> <integer>         !* { $$ = $2; } *!


<_to_integer>
::=  !* empty *!            !* { $$ = NULL; } *!
| TO <integer>          !* { $$ = $2; } *!


    !* LABEL RECORDS clause *!

<label_records_clause>
::=  LABEL <records> <label_option> !* {
    check_repeated ("LABEL", SYN_CLAUSE_5, &check_duplicate);
    cb_verify (cb_label_records_clause, "LABEL RECORDS");
  } *!


    !* VALUE OF clause *!

<value_of_clause>
::=  VALUE OF <file_id> <_is> <valueof_name>    !* {
    check_repeated ("VALUE OF", SYN_CLAUSE_6, &check_duplicate);
    cb_verify (cb_value_of_clause, "VALUE OF");
  } *!
| VALUE OF FILE_ID <_is> <valueof_name> !* {
    check_repeated ("VALUE OF", SYN_CLAUSE_6, &check_duplicate);
    cb_verify (cb_value_of_clause, "VALUE OF");
    if (C_NOT current_file->assign) !* {
        current_file->assign = cb_build_assignment_name (current_file, $5);
    } *!
  } *!


<file_id>
::=  <WORD>
| ID


<valueof_name>
::=  <LITERAL_TOK>
| <qualified_word>

    !* DATA RECORDS clause *!

<data_records_clause>
::=  DATA <records> <optional_reference_list>   !* {
    check_repeated ("DATA", SYN_CLAUSE_7, &check_duplicate);
    cb_verify (cb_data_records_clause, "DATA RECORDS");
  } *!


    !* LINAGE clause *!

<linage_clause>
::=  LINAGE <_is> <reference_or_literal> <_lines>  <_linage_sequence>   !* {
    check_repeated ("LINAGE", SYN_CLAUSE_8, &check_duplicate);
    if (current_file->organization <> COB_ORG_LINE_SEQUENTIAL &&
        current_file->organization <> COB_ORG_SEQUENTIAL) !* {
        cb_error (_("LINAGE clause with wrong file type"));
    } *! else !* {
        current_file->linage = $3;
        current_file->organization = COB_ORG_LINE_SEQUENTIAL;
        if (current_linage == 0) !* {
            linage_file = current_file;
        } *!
        current_linage++;
    } *!
  } *!


<_linage_sequence>
::=| <_linage_sequence> <linage_lines>


<linage_lines>
::=  <linage_footing>
| <linage_top>
| <linage_bottom>


<linage_footing>
::=  <_with> FOOTING <_at> <reference_or_literal>   !* {
    current_file->latfoot = $4;
  } *!


<linage_top>
::=  TOP <reference_or_literal> !* {
    current_file->lattop = $2;
  } *!


<linage_bottom>
::=  BOTTOM <reference_or_literal>  !* {
    current_file->latbot = $2;
  } *!

    !* RECORDING MODE clause *!

<recording_mode_clause>
::=  RECORDING <_mode> <_is> <recording_mode>   !* {
    cobc_cs_check = 0;
    check_repeated ("RECORDING", SYN_CLAUSE_9, &check_duplicate);   !* ignore *!
  } *!


<recording_mode>
::=  F
| V
| FIXED
| VARIABLE
| <u_or_s>  !* {
    if (current_file->organization <> COB_ORG_SEQUENTIAL) !* {
        cb_error (_("RECORDING MODE U or S can only be used with RECORD SEQUENTIAL files"));
    } *!
  } *!


<u_or_s>
::=  U
| S

    !* CODE-SET clause *!

<code_set_clause>
::=  CODE_SET <_is> <alphabet_name> <_for_sub_records_clause>   !* {
    struct cb_alphabet_name *al;

    check_repeated ("CODE SET", SYN_CLAUSE_10, &check_duplicate);

    if (CB_VALID_TREE ($3)) !* {
        al = CB_ALPHABET_NAME (cb_ref ($3));
        switch (al->alphabet_type) !* {
#ifdef  COB_EBCDIC_MACHINE
        case CB_ALPHABET_ASCII:
#else
        case CB_ALPHABET_EBCDIC:
#endif
        case CB_ALPHABET_CUSTOM:
            current_file->code_set = al;
            break;
        default:
            if (warningopt && CB_VALID_TREE ($3)) !* {
                cb_warning_x ($3, _("ignoring CODE-SET '%s'"),
                          cb_name ($3));
            } *!
            break;
        } *!
    } *!

    if (current_file->organization <> COB_ORG_LINE_SEQUENTIAL &&
        current_file->organization <> COB_ORG_SEQUENTIAL) !* {
        cb_error (_("CODE-SET clause invalid for file type"));
    } *!

    if (warningopt) !* {
        CB_PENDING ("CODE-SET");
    } *!
  } *!


<_for_sub_records_clause>
::=| FOR <reference_list>   !* {
      if (warningopt) !* {
          CB_PENDING ("FOR sub-records");
      } *!

      current_file->code_set_items = CB_LIST ($2);
  } *!

    !* REPORT clause *!

<report_clause>
::=  <report_keyword> <rep_name_list>   !* {
    check_repeated ("REPORT", SYN_CLAUSE_11, &check_duplicate);
    CB_PENDING("REPORT WRITER");
    if (current_file->organization <> COB_ORG_LINE_SEQUENTIAL &&
        current_file->organization <> COB_ORG_SEQUENTIAL) !* {
        cb_error (_("REPORT clause with wrong file type"));
    } *! else !* {
        current_file->reports = $2;
        current_file->organization = COB_ORG_LINE_SEQUENTIAL;
    } *!
  } *!


<report_keyword>
::=  REPORT <_is>
| REPORTS <_are>


<rep_name_list>
::=  <undefined_word>   !* {
    current_report = build_report ($1);
    current_report->file = current_file;
    CB_ADD_TO_CHAIN (CB_TREE (current_report), current_program->report_list);
    if (report_count == 0) !* {
        report_instance = current_report;
    } *!
    report_count++;
  } *!
| <rep_name_list> <undefined_word>  !* {
    current_report = build_report ($2);
    CB_ADD_TO_CHAIN (CB_TREE (current_report), current_program->report_list);
    if (report_count == 0) !* {
        report_instance = current_report;
    } *!
    report_count++;
  } *!

    !* COMMUNICATION SECTION *!

<_communication_section>
::=| COMMUNICATION SECTION TOK_DOT  !* {
    current_storage = CB_STORAGE_COMMUNICATION;
    check_headers_present (COBC_HD_DATA_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_COMMUNICATION_SECTION;  !* add a compiler configuration if either *!
    if (cb_std_define > CB_STD_85) !* {
        cb_verify (CB_UNCONFORMABLE, _ ("COMMUNICATION SECTION"));
    } *! else if (cb_verify (CB_OBSOLETE, _("COMMUNICATION SECTION"))) !* {
        CB_PENDING ("COMMUNICATION SECTION");
    } *!
  } *!  <_communication_description_sequence>


<_communication_description_sequence>
::=| <_communication_description_sequence> <communication_description>


<communication_description>
::=  <communication_description_entry>  <_record_description_list>  !* {
    if (CB_VALID_TREE (current_cd)) !* {
        if (CB_VALID_TREE ($2)) !* {
            cb_finalize_cd (current_cd, CB_FIELD ($2));
        } *! else if (C_NOT current_cd->record) !* {
            cb_error (_("CD record missing"));
        } *!
    } *!
  } *!

    !* File description entry *!

<communication_description_entry>
::=  CD <undefined_word>    !* {    !* CD internally defines a new file *!
    if (CB_VALID_TREE ($2)) !* {
        current_cd = cb_build_cd ($2);

        CB_ADD_TO_CHAIN (CB_TREE (current_cd),
                 current_program->cd_list);
    } *! else !* {
        current_cd = NULL;  !* TO-DO: Is this necessary? *!
        if (current_program->cd_list) !* {
            current_program->cd_list
                = CB_CHAIN (current_program->cd_list);
        } *!
    } *!
    check_duplicate = 0;
  } *!  <_communication_description_clause_sequence> TOK_DOT


<_communication_description_clause_sequence>
::=| <_communication_description_clause_sequence> <communication_description_clause>


<communication_description_clause>
::=  <_for> <_initial> INPUT <_input_cd_clauses>
| <_for> OUTPUT <_output_cd_clauses>
| <_for> <_initial> I_O <_i_o_cd_clauses>


<_input_cd_clauses>
::=  !* empty *!
| <named_input_cd_clauses>
| <unnamed_input_cd_clauses>


<named_input_cd_clauses>
::=  <named_input_cd_clause>
| <named_input_cd_clauses> <named_input_cd_clause>


<named_input_cd_clause>
::=  <_symbolic> QUEUE <_is> <identifier>
| <_symbolic> SUB_QUEUE_1 <_is> <identifier>
| <_symbolic> SUB_QUEUE_2 <_is> <identifier>
| <_symbolic> SUB_QUEUE_3 <_is> <identifier>
| MESSAGE DATE <_is> <identifier>
| MESSAGE TIME <_is> <identifier>
| <_symbolic> SOURCE <_is> <identifier>
| TEXT LENGTH <_is> <identifier>
| END KEY <_is> <identifier>
| STATUS KEY <_is> <identifier>
| <_message> COUNT <_is> <identifier>


<unnamed_input_cd_clauses>
::=  <identifier> <identifier> <identifier> <identifier> <identifier> <identifier> <identifier>  <identifier> <identifier> <identifier> <identifier>


<_output_cd_clauses>
::=  !* empty *!
| <output_cd_clauses>


<output_cd_clauses>
::=  <output_cd_clause>
| <output_cd_clauses> <output_cd_clause>


<output_cd_clause>
::=  DESTINATION COUNT <_is> <identifier>
| TEXT LENGTH <_is> <identifier>
| STATUS KEY <_is> <identifier>
| DESTINATION TABLE OCCURS <integer> <_times> <_occurs_indexed>
| ERROR KEY <_is> <identifier>
| DESTINATION <_is> <identifier>
| SYMBOLIC DESTINATION <_is> <identifier>


<_i_o_cd_clauses>
::=  !* empty *!
| <named_i_o_cd_clauses>
| <unnamed_i_o_cd_clauses>


<named_i_o_cd_clauses>
::=  <named_i_o_cd_clause>
| <named_i_o_cd_clauses> <named_i_o_cd_clause>


<named_i_o_cd_clause>
::=  MESSAGE DATE <_is> <identifier>
| MESSAGE TIME <_is> <identifier>
| <_symbolic> TERMINAL <_is> <identifier>
| TEXT LENGTH <_is> <identifier>
| END KEY <_is> <identifier>
| STATUS KEY <_is> <identifier>


<unnamed_i_o_cd_clauses>
::=  <identifier> <identifier> <identifier> <identifier> <identifier> <identifier>

    !* WORKING-STORAGE SECTION *!

<_working_storage_section>
::=| WORKING_STORAGE SECTION TOK_DOT    !* {
    check_headers_present (COBC_HD_DATA_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_WORKING_STORAGE_SECTION;
    current_storage = CB_STORAGE_WORKING;
  } *!  <_record_description_list>  !* {
    if ($5) !* {
        CB_FIELD_ADD (current_program->working_storage, CB_FIELD ($5));
    } *!
  } *!


<_record_description_list>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
|   !* {
    current_field = NULL;
    description_field = NULL;
    cb_clear_real_field ();
  } *!  <record_description_list> !* {
    struct cb_field *p;

    for (p = description_field; p; p = p->sister) !* {
        cb_validate_field (p);
    } *!
    $$ = CB_TREE (description_field);
  } *!


<record_description_list>
::=  <data_description> TOK_DOT
| <record_description_list> <data_description> TOK_DOT


! FIXME: we use tokens SIXTY_SIX, SEVENTY_EIGHT, EIGHTY_EIGHT below
!        that overlap with IntLiteral, better moved to preparser
<data_description>
::=  <constant_entry>
| <renames_entry>
| <condition_name_entry>
| <level_number> <_entry_name>  !* {
    if (set_current_field ($1, $2)) !* {
        YYERROR;
    } *!
  } *!  <_data_description_clause_sequence> !* {
    if (C_NOT qualifier) !* {
        current_field->flag_filler = 1;
    } *!
    if (C_NOT description_field) !* {
        description_field = current_field;
    } *!
  } *!
!bison error token | <level_number> <error> TOK_DOT    
  !* {    !* Free tree associated with level number *!
    cobc_parse_free ($1);
    yyerrok;
    cb_unput_dot ();
    check_pic_duplicate = 0;
    check_duplicate = 0;
    current_field = cb_get_real_field ();
  } *!

<level_number> ::= IntLiteral
!* needs to be a Terminal for GOLDParser grammar
::=  <not_const_word> <WORD>  !* {
    $$ = $2;
  } *!
*!

<_filler>
::=  !* empty *!
| FILLER


<_entry_name>
::=  <_filler>  !* {
    $$ = cb_build_filler ();
    qualifier = NULL;
    keys_list = NULL;
    non_const_word = 0;
  } *!
| <user_entry_name>


<user_entry_name>
::=  <WORD>   !* {
    $$ = $1;
    qualifier = $1;
    keys_list = NULL;
    non_const_word = 0;
  } *!


<const_global>
::=  !* Nothing *!  !* {
    $$= NULL;
  } *!
| <_is> GLOBAL  !* {
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("%s is invalid in a user FUNCTION"), "GLOBAL");
        $$= NULL;
    } *! else !* {
        $$ = cb_null;
    } *!
  } *!


<lit_or_length>
::=  <literal>              !* { $$ = $1; } *!
| LENGTH_OF <con_identifier>        !* { $$ = cb_build_const_length ($2); } *!
| LENGTH <con_identifier>           !* { $$ = cb_build_const_length ($2); } *!
| BYTE_LENGTH <_of> <con_identifier>    !* { $$ = cb_build_const_length ($3); } *!
! | COBOLWord  ! because of CONSTANT / lvl-78 items, maybe moved to preparser [raises a reduce-reduce-conflict here]

<con_identifier>
::=  <identifier_1> !* {
    $$ = $1;
  } *!
| BINARY_CHAR   !* {
    $$ = cb_int1;
  } *!
| BINARY_SHORT  !* {
    $$ = cb_int2;
  } *!
| BINARY_LONG   !* {
    $$ = cb_int4;
  } *!
| BINARY_DOUBLE !* {
    $$ = cb_int (8);
  } *!
| BINARY_C_LONG !* {
    $$ = cb_int ((int)sizeof(long));
  } *!
| <pointer_len> !* {
    $$ = cb_int ((int)sizeof(void *));
  } *!
| <float_usage> !* {
    $$ = cb_int ((int)sizeof(float));
  } *!
| <double_usage>    !* {
    $$ = cb_int ((int)sizeof(double));
  } *!
| <fp32_usage>  !* {
    $$ = cb_int (4);
  } *!
| <fp64_usage>  !* {
    $$ = cb_int (8);
  } *!
| <fp128_usage> !* {
    $$ = cb_int (16);
  } *!
!bison error token | <error> TOK_DOT 
  !* {
    yyerrok;
    cb_unput_dot ();
    check_pic_duplicate = 0;
    check_duplicate = 0;
    current_field = cb_get_real_field ();
  } *!


<fp32_usage>
::=  FLOAT_BINARY_32
| FLOAT_DECIMAL_7


<fp64_usage>
::=  FLOAT_BINARY_64
| FLOAT_DECIMAL_16


<fp128_usage>
::=  FLOAT_BINARY_128
| FLOAT_DECIMAL_34
| FLOAT_EXTENDED


<pointer_len>
::=  POINTER
| PROGRAM_POINTER


<renames_entry>
::=  SIXTY_SIX <user_entry_name> RENAMES <qualified_word> <_renames_thru>   !* {
    if (set_current_field ($1, $2)) !* {
        YYERROR;
    } *!

    if (cb_ref ($4) <> cb_error_node) !* {
        error_if_invalid_level_for_renames ($4);
        current_field->redefines = CB_FIELD (cb_ref ($4));
    } *!

    if ($5) !* {
        error_if_invalid_level_for_renames ($5);
        current_field->rename_thru = CB_FIELD (cb_ref ($5));
    } *! else !* {  !* If there is no THRU clause, RENAMES acts like REDEFINES. *!
        current_field->pic = current_field->redefines->pic;
    } *!

    cb_validate_renames_item (current_field);
  } *!


<_renames_thru>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| THRU <qualified_word> !* {
    $$ = $2 == cb_error_node ? NULL : $2;
  } *!


<condition_name_entry>
::=  EIGHTY_EIGHT <user_entry_name> !* {
    if (set_current_field ($1, $2)) !* {
        YYERROR;
    } *!
  } *!  <value_clause>  !* {
    cb_validate_88_item (current_field);
  } *!


<constant_entry>
::=  <level_number> <user_entry_name> CONSTANT <const_global> <constant_source> !* {
    cb_tree x;
    int level;

    cobc_cs_check = 0;
    level = cb_get_level ($1);  !* Free tree associated with level number *!
    cobc_parse_free ($1);
    if (level <> 1) !* {
        cb_error (_("CONSTANT item not at 01 level"));
    } *! else if ($5) !* {
        x = cb_build_constant ($2, $5);
        CB_FIELD (x)->flag_item_78 = 1;
        CB_FIELD (x)->level = 1;
        cb_needs_01 = 1;
        if ($4) !* {
            CB_FIELD (x)->flag_is_global = 1;
        } *!    !* Ignore return value *!
        (void)cb_validate_78_item (CB_FIELD (x), 0);
    } *!
  } *!
| SEVENTY_EIGHT <user_entry_name>   !* {
    if (set_current_field ($1, $2)) !* {
        YYERROR;
    } *!
  } *!  <_global_clause> <value_clause> !* {    !* Reset to last non-78 item *!
    current_field = cb_validate_78_item (current_field, 0);
  } *!


<constant_source>
::=  <_as> <lit_or_length>  !* {
    $$ = $2;
  } *!
| FROM <WORD> !* {
    CB_PENDING ("CONSTANT FROM");
    $$ = NULL;
  } *!


<_data_description_clause_sequence>
::=  !* empty *!    !* {    !* Required to check redefines *!
    $$ = NULL;
  } *!
| <_data_description_clause_sequence>  <data_description_clause>    !* {    !* Required to check redefines *!
    $$ = cb_true;
  } *!


<data_description_clause>
::=  <redefines_clause>
| <external_clause>
| <global_clause>
| <picture_clause>
| <usage_clause>
| <sign_clause>
| <occurs_clause>
| <justified_clause>
| <synchronized_clause>
| <blank_clause>
| <based_clause>
| <value_clause>
| <any_length_clause>


    !* REDEFINES clause *!

<redefines_clause>
::=  REDEFINES <identifier_1>   !* {
    check_repeated ("REDEFINES", SYN_CLAUSE_1, &check_pic_duplicate);
    if ($0 <> NULL) !* {
        if (cb_relaxed_syntax_checks) !* {
            cb_warning_x ($2, _("REDEFINES clause should follow entry-name"));
        } *! else !* {
            cb_error_x ($2, _("REDEFINES clause must follow entry-name"));
        } *!
    } *!

    current_field->redefines = cb_resolve_redefines (current_field, $2);
    if (current_field->redefines == NULL) !* {
        current_field->flag_is_verified = 1;
        current_field->flag_invalid = 1;
        YYERROR;
    } *!
  } *!


    !* EXTERNAL clause *!

<external_clause>
::=  <_is> EXTERNAL <_as_extname>   !* {
    check_repeated ("EXTERNAL", SYN_CLAUSE_2, &check_pic_duplicate);
    if (current_storage <> CB_STORAGE_WORKING) !* {
        cb_error (_("%s not allowed here"), "EXTERNAL");
    } *! else if (current_field->level <> 1 && current_field->level <> 77) !* {
        cb_error (_("%s only allowed at 01/77 level"), "EXTERNAL");
    } *! else if (C_NOT qualifier) !* {
        cb_error (_("%s requires a data name"), "EXTERNAL");
#if 0   !* RXWRXW - Global/External *!
    } *! else if (current_field->flag_is_global) !* {
        cb_error (_("%s and %s are mutually exclusive"), "GLOBAL", "EXTERNAL");
#endif
    } *! else if (current_field->flag_item_based) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "EXTERNAL");
    } *! else if (current_field->redefines) !* {
        cb_error (_("%s and %s are mutually exclusive"), "EXTERNAL", "REDEFINES");
    } *! else if (current_field->flag_occurs) !* {
        cb_error (_("%s and %s are mutually exclusive"), "EXTERNAL", "OCCURS");
    } *! else !* {
        current_field->flag_external = 1;
        current_program->flag_has_external = 1;
    } *!
  } *!


<_as_extname>
::=  !* empty *!    !* {
    current_field->ename = cb_to_cname (current_field->name);
  } *!
| AS <LITERAL_TOK>    !* {
    current_field->ename = cb_to_cname ((const char *)CB_LITERAL ($2)->data);
  } *!

    !* GLOBAL clause *!

<_global_clause>
::=| <global_clause>


<global_clause>
::=  <_is> GLOBAL   !* {
    check_repeated ("GLOBAL", SYN_CLAUSE_3, &check_pic_duplicate);
    if (current_field->level <> 1 && current_field->level <> 77) !* {
        cb_error (_("%s only allowed at 01/77 level"), "GLOBAL");
    } *! else if (C_NOT qualifier) !* {
        cb_error (_("%s requires a data name"), "GLOBAL");
#if 0   !* RXWRXW - Global/External *!
    } *! else if (current_field->flag_external) !* {
        cb_error (_("%s and %s are mutually exclusive"), "GLOBAL", "EXTERNAL");
#endif
    } *! else if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("%s is invalid in a user FUNCTION"), "GLOBAL");
    } *! else if (current_storage == CB_STORAGE_LOCAL) !* {
        cb_error (_("%s not allowed here"), "GLOBAL");
    } *! else !* {
        current_field->flag_is_global = 1;
    } *!
  } *!


    !* PICTURE clause *!

<picture_clause>
::= Picture_Def
    !* {
    check_repeated ("PICTURE", SYN_CLAUSE_4, &check_pic_duplicate);
    current_field->pic = CB_PICTURE ($1);
  } *!

<usage_clause>
::=  <usage>
| USAGE <_is> <usage>


<usage>
::=  BINARY !* {
    check_and_set_usage (CB_USAGE_BINARY);
  } *!
| COMP  !* {
    check_and_set_usage (CB_USAGE_BINARY);
  } *!
| <float_usage> !* {
    check_and_set_usage (CB_USAGE_FLOAT);
  } *!
| <double_usage>    !* {
    check_and_set_usage (CB_USAGE_DOUBLE);
  } *!
| COMP_3    !* {
    check_and_set_usage (CB_USAGE_PACKED);
  } *!
| COMP_4    !* {
    check_and_set_usage (CB_USAGE_BINARY);
  } *!
| COMP_5    !* {
    check_and_set_usage (CB_USAGE_COMP_5);
  } *!
| COMP_6    !* {
    check_and_set_usage (CB_USAGE_COMP_6);
  } *!
| COMP_X    !* {
    check_and_set_usage (CB_USAGE_COMP_X);
  } *!
| DISPLAY   !* {
    check_and_set_usage (CB_USAGE_DISPLAY);
  } *!
| INDEX !* {
    check_and_set_usage (CB_USAGE_INDEX);
  } *!
| PACKED_DECIMAL    !* {
    check_and_set_usage (CB_USAGE_PACKED);
  } *!
| POINTER   !* {
    check_and_set_usage (CB_USAGE_POINTER);
    current_field->flag_is_pointer = 1;
  } *!
| PROGRAM_POINTER   !* {
    check_and_set_usage (CB_USAGE_PROGRAM_POINTER);
    current_field->flag_is_pointer = 1;
  } *!
| SIGNED_SHORT  !* {
    check_and_set_usage (CB_USAGE_SIGNED_SHORT);
  } *!
| SIGNED_INT    !* {
    check_and_set_usage (CB_USAGE_SIGNED_INT);
  } *!
| SIGNED_LONG   !* {
#ifdef COB_32_BIT_LONG
    check_and_set_usage (CB_USAGE_SIGNED_INT);
#else
    check_and_set_usage (CB_USAGE_SIGNED_LONG);
#endif
  } *!
| UNSIGNED_SHORT    !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_SHORT);
  } *!
| UNSIGNED_INT  !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_INT);
  } *!
| UNSIGNED_LONG !* {
#ifdef COB_32_BIT_LONG
    check_and_set_usage (CB_USAGE_UNSIGNED_INT);
#else
    check_and_set_usage (CB_USAGE_UNSIGNED_LONG);
#endif
  } *!
| BINARY_CHAR <_signed> !* {
    check_and_set_usage (CB_USAGE_SIGNED_CHAR);
  } *!
| BINARY_CHAR UNSIGNED  !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_CHAR);
  } *!
| BINARY_SHORT <_signed>    !* {
    check_and_set_usage (CB_USAGE_SIGNED_SHORT);
  } *!
| BINARY_SHORT UNSIGNED !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_SHORT);
  } *!
| BINARY_LONG <_signed> !* {
    check_and_set_usage (CB_USAGE_SIGNED_INT);
  } *!
| BINARY_LONG UNSIGNED  !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_INT);
  } *!
| BINARY_DOUBLE <_signed>   !* {
    check_and_set_usage (CB_USAGE_SIGNED_LONG);
  } *!
| BINARY_DOUBLE UNSIGNED    !* {
    check_and_set_usage (CB_USAGE_UNSIGNED_LONG);
  } *!
| BINARY_C_LONG <_signed>   !* {
#ifdef COB_32_BIT_LONG
    check_and_set_usage (CB_USAGE_SIGNED_INT);
#else
    check_and_set_usage (CB_USAGE_SIGNED_LONG);
#endif
  } *!
| BINARY_C_LONG UNSIGNED    !* {
#ifdef COB_32_BIT_LONG
    check_and_set_usage (CB_USAGE_UNSIGNED_INT);
#else
    check_and_set_usage (CB_USAGE_UNSIGNED_LONG);
#endif
  } *!
| FLOAT_BINARY_32   !* {
    check_and_set_usage (CB_USAGE_FP_BIN32);
  } *!
| FLOAT_BINARY_64   !* {
    check_and_set_usage (CB_USAGE_FP_BIN64);
  } *!
| FLOAT_BINARY_128  !* {
    check_and_set_usage (CB_USAGE_FP_BIN128);
  } *!
| FLOAT_DECIMAL_16  !* {
    check_and_set_usage (CB_USAGE_FP_DEC64);
  } *!
| FLOAT_DECIMAL_34  !* {
    check_and_set_usage (CB_USAGE_FP_DEC128);
  } *!
| NATIONAL  !* {
    check_repeated ("USAGE", SYN_CLAUSE_5, &check_pic_duplicate);
    CB_UNFINISHED ("USAGE NATIONAL");
  } *!


<float_usage>
::=  COMP_1
| FLOAT_SHORT


<double_usage>
::=  COMP_2
| FLOAT_LONG

    !* SIGN clause *!

<sign_clause>
::=  <_sign_is> LEADING <flag_separate> !* {
    check_repeated ("SIGN", SYN_CLAUSE_6, &check_pic_duplicate);
    current_field->flag_sign_clause = 1;
    current_field->flag_sign_separate = ($3 ? 1 : 0);
    current_field->flag_sign_leading  = 1;
  } *!
| <_sign_is> TRAILING <flag_separate>   !* {
    check_repeated ("SIGN", SYN_CLAUSE_6, &check_pic_duplicate);
    current_field->flag_sign_clause = 1;
    current_field->flag_sign_separate = ($3 ? 1 : 0);
    current_field->flag_sign_leading  = 0;
  } *!


    !* REPORT (RD) OCCURS clause *!

<report_occurs_clause>
::=  OCCURS <integer_or_word> <_occurs_to_integer> <_times>  <_occurs_depending> <_occurs_step> !* {    !* most of the field attributes are set when parsing the phrases *!;
    setup_occurs ();
    setup_occurs_min_max ($2, $3);
  } *!


<_occurs_step>
::=| STEP <integer_or_word> !* {
    current_field->step_count = cb_get_int ($2);
  } *!

    !* OCCURS clause *!

<occurs_clause>
::=  OCCURS <integer_or_word> <_occurs_to_integer> <_times>  <_occurs_depending> <_occurs_keys_and_indexed> !* {    !* most of the field attributes are set when parsing the phrases *!;
    setup_occurs ();
    setup_occurs_min_max ($2, $3);
  } *!
| OCCURS <_occurs_integer_to> UNBOUNDED <_times>  DEPENDING <_on> <reference> <_occurs_keys_and_indexed>    !* {
    current_field->flag_unbounded = 1;
    if (current_field->parent) !* {
        current_field->parent->flag_unbounded = 1;
    } *!
    current_field->depending = $7;  !* most of the field attributes are set when parsing the phrases *!;
    setup_occurs ();
    setup_occurs_min_max ($2, cb_int0);
  } *!
| OCCURS DYNAMIC <_capacity_in> <_occurs_from_integer>  <_occurs_to_integer> <_occurs_initialized> <_occurs_keys_and_indexed>   !* {
    setup_occurs ();
    current_field->occurs_min = $4 ? cb_get_int ($4) : 0;
    if ($5) !* {
        current_field->occurs_max = cb_get_int ($5);
        if (current_field->occurs_max <= current_field->occurs_min) !* {
            cb_error (_("OCCURS TO must be greater than OCCURS FROM"));
        } *!
    } *! else !* {
        current_field->occurs_max = 0;
    } *!
    CB_PENDING("OCCURS DYNAMIC");
  } *!


<_occurs_to_integer>
::=  !* empty *!            !* { $$ = NULL; } *!
| TO <integer_or_word>          !* { $$ = $2; } *!


<_occurs_from_integer>
::=  !* empty *!            !* { $$ = NULL; } *!
| FROM <integer_or_word>            !* { $$ = $2; } *!


<_occurs_integer_to>
::=  !* empty *!            !* { $$ = NULL; } *!
| <integer_or_word> TO          !* { $$ = $1; } *!

! HACK: added because of CONSTANT / lvl-78 items, maybe moved to preparser
! was <integer> before
<integer_or_word>
::= <integer>
|   COBOLWord 

<_occurs_depending>
::=| DEPENDING <_on> <reference>    !* {
    current_field->depending = $3;
  } *!

<_capacity_in>
::=| CAPACITY <_in> <WORD>    !* {
    $$ = cb_build_index ($3, cb_zero, 0, current_field);
    CB_FIELD_PTR ($$)->special_index = 1;
  } *!


<_occurs_initialized>
::=| INITIALIZED    !* {    !* current_field->initialized = 1; *!
  } *!


<_occurs_keys_and_indexed>
::=  !* empty *!
| <occurs_keys> <occurs_indexed>
| <occurs_indexed>  !* {
    if (C_NOT cb_relaxed_syntax_checks) !* {
        cb_error (_("INDEXED should follow ASCENDING/DESCENDING"));
    } *! else if(warningopt) !* {
        cb_warning (_("INDEXED should follow ASCENDING/DESCENDING"));
    } *!
  } *!  <occurs_keys>
| <occurs_indexed>
| <occurs_keys>


<occurs_keys>
::=  <occurs_key_list>  !* {
    if ($1) !* {
        cb_tree     l;
        struct cb_key   *keys;
        int     i;
        int     nkeys;

        l = $1;
        nkeys = cb_list_length ($1);
        keys = cobc_parse_malloc (sizeof (struct cb_key) * nkeys);

        for (i = 0; i < nkeys; i++) !* {
            keys[i].dir = CB_PURPOSE_INT (l);
            keys[i].key = CB_VALUE (l);
            l = CB_CHAIN (l);
        } *!
        current_field->keys = keys;
        current_field->nkeys = nkeys;
    } *!
  } *!


<occurs_key_list>
::=  <occurs_key_field>
| <occurs_key_field> <occurs_key_list>


<occurs_key_field>
::=  <ascending_or_descending> <_key> <_is> <reference_list>    !* {
    cb_tree l;

    for (l = $4; l; l = CB_CHAIN (l)) !* {
        CB_PURPOSE (l) = $1;
        if (qualifier && C_NOT CB_REFERENCE(CB_VALUE(l))->chain &&
            strcasecmp (CB_NAME(CB_VALUE(l)), CB_NAME(qualifier))) !* {
            CB_REFERENCE(CB_VALUE(l))->chain = qualifier;
        } *!
    } *!
    keys_list = cb_list_append (keys_list, $4);
    $$ = keys_list;
  } *!


<ascending_or_descending>
::=  ASCENDING          !* { $$ = cb_int (COB_ASCENDING); } *!
| DESCENDING            !* { $$ = cb_int (COB_DESCENDING); } *!


<_occurs_indexed>
::=  !* empty *!
| <occurs_indexed>

<occurs_indexed>
::=  INDEXED <_by> <occurs_index_list>  !* {
    current_field->index_list = $3;
  } *!


<occurs_index_list>
::=  <occurs_index>         !* { $$ = CB_LIST_INIT ($1); } *!
| <occurs_index_list>  <occurs_index>           !* { $$ = cb_list_add ($1, $2); } *!


<occurs_index>
::=  <WORD>   !* {
    $$ = cb_build_index ($1, cb_int1, 1U, current_field);
    CB_FIELD_PTR ($$)->special_index = 1;
  } *!


    !* JUSTIFIED clause *!

<justified_clause>
::=  JUSTIFIED <_right> !* {
    check_repeated ("JUSTIFIED", SYN_CLAUSE_8, &check_pic_duplicate);
    current_field->flag_justified = 1;
  } *!


    !* SYNCHRONIZED clause *!

<synchronized_clause>
::=  SYNCHRONIZED <_left_or_right>  !* {
    check_repeated ("SYNCHRONIZED", SYN_CLAUSE_9, &check_pic_duplicate);
    current_field->flag_synchronized = 1;
  } *!


    !* BLANK clause *!

<blank_clause>
::=  BLANK <_when> ZERO !* {
    check_repeated ("BLANK", SYN_CLAUSE_10, &check_pic_duplicate);
    current_field->flag_blank_zero = 1;
  } *!


    !* BASED clause *!

<based_clause>
::=  BASED  !* {
    check_repeated ("BASED", SYN_CLAUSE_11, &check_pic_duplicate);
    if (current_storage <> CB_STORAGE_WORKING &&
        current_storage <> CB_STORAGE_LINKAGE &&
        current_storage <> CB_STORAGE_LOCAL) !* {
        cb_error (_("%s not allowed here"), "BASED");
    } *! else if (current_field->level <> 1 && current_field->level <> 77) !* {
        cb_error (_("%s only allowed at 01/77 level"), "BASED");
    } *! else if (C_NOT qualifier) !* {
        cb_error (_("%s requires a data name"), "BASED");
    } *! else if (current_field->flag_external) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "EXTERNAL");
    } *! else if (current_field->redefines) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "REDEFINES");
    } *! else if (current_field->flag_any_length) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "ANY LENGTH");
    } *! else if (current_field->flag_occurs) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "OCCURS");
    } *! else !* {
        current_field->flag_item_based = 1;
    } *!
  } *!

    !* VALUE clause *!

<value_clause>
::= VALUE <_is_are> <value_item_list>  !* {
    check_repeated ("VALUE", SYN_CLAUSE_12, &check_pic_duplicate);
    current_field->values = $3;
  } *!  <_false_is>


<value_item_list>
::=  <value_item>           !* { $$ = CB_LIST_INIT ($1); } *!
| <value_item_list> <value_item>    !* { $$ = cb_list_add ($1, $2); } *!


<value_item>
::=  <lit_or_length>                !* { $$ = $1; } *!
| <lit_or_length> THRU <lit_or_length>  !* { $$ = CB_BUILD_PAIR ($1, $3); } *!
| COMMA_DELIM !* HACK, should not reach parser *!


<_false_is>
::=  !* empty *!
| <_when_set_to> TOK_FALSE <_is> <lit_or_length>    !* {
    if (current_field->level <> 88) !* {
        cb_error (_("FALSE clause only allowed for 88 level"));
    } *!
    current_field->false_88 = CB_LIST_INIT ($4);
  } *!

    !* ANY LENGTH clause *!

<any_length_clause>
::=  ANY LENGTH !* {
    check_repeated ("ANY", SYN_CLAUSE_14, &check_pic_duplicate);
    if (current_field->flag_item_based) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "ANY LENGTH");
    } *! else !* {
        current_field->flag_any_length = 1;
    } *!
  } *!
| ANY NUMERIC   !* {
    check_repeated ("ANY", SYN_CLAUSE_14, &check_pic_duplicate);
    if (current_field->flag_item_based) !* {
        cb_error (_("%s and %s are mutually exclusive"), "BASED", "ANY NUMERIC");
    } *! else !* {
        current_field->flag_any_length = 1;
        current_field->flag_any_numeric = 1;
    } *!
  } *!

    !* LOCAL-STORAGE SECTION *!

<_local_storage_section>
::=| LOCAL_STORAGE SECTION TOK_DOT  !* {
    check_headers_present (COBC_HD_DATA_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_LOCAL_STORAGE_SECTION;
    current_storage = CB_STORAGE_LOCAL;
    if (current_program->nested_level) !* {
        cb_error (_("%s not allowed in nested programs"), "LOCAL-STORAGE");
    } *!
  } *!  <_record_description_list>  !* {
    if ($5) !* {
        current_program->local_storage = CB_FIELD ($5);
    } *!
  } *!


    !* LINKAGE SECTION *!

<_linkage_section>
::=| LINKAGE SECTION TOK_DOT    !* {
    check_headers_present (COBC_HD_DATA_DIVISION, 0, 0, 0);
    header_check |= COBC_HD_LINKAGE_SECTION;
    current_storage = CB_STORAGE_LINKAGE;
  } *!  <_record_description_list>  !* {
    if ($5) !* {
        current_program->linkage_storage = CB_FIELD ($5);
    } *!
  } *!

    !* REPORT SECTION *!

<_report_section>
::=| REPORT SECTION TOK_DOT !* {
    CB_PENDING("REPORT SECTION");
    current_storage = CB_STORAGE_REPORT;
    cb_clear_real_field ();
  } *!  <_report_description_sequence>


<_report_description_sequence>
::=| <_report_description_sequence> <report_description>

    !* RD report description *!

<report_description>
::=  RD <report_name>   !* {
    if (CB_INVALID_TREE ($2)) !* {
        YYERROR;
    } *! else !* {
        current_report = CB_REPORT (cb_ref ($2));
    } *!
    check_duplicate = 0;
  } *!  <_report_description_options> TOK_DOT  <_report_group_description_list>


<_report_description_options>
::=| <_report_description_options> <report_description_option>
!bison error token | <error> TOK_DOT 
  !* {
    yyerrok;
  } *!


<report_description_option>
::=  <_is> GLOBAL   !* {
    check_repeated ("GLOBAL", SYN_CLAUSE_1, &check_duplicate);
    cb_error (_("GLOBAL is not allowed with RD"));
  } *!
| CODE <_is> <id_or_lit>    !* {
    check_repeated ("CODE", SYN_CLAUSE_2, &check_duplicate);
  } *!
| <control_clause>
| <page_limit_clause>

    !* REPORT control breaks *!

<control_clause>
::=  <control_keyword> <control_field_list> !* {
    check_repeated ("CONTROL", SYN_CLAUSE_3, &check_duplicate);
  } *!


<control_field_list>
::=  <_final> <identifier_list>


<identifier_list>
::=  <identifier>
| <identifier_list> <identifier>

    !* PAGE clause *!

<page_limit_clause>
::=  PAGE <_limits> <page_line_column>  <_page_heading_list>    !* {
    check_repeated ("PAGE", SYN_CLAUSE_4, &check_duplicate);
    if (C_NOT current_report->heading) !* {
        current_report->heading = 1;
    } *!
    if (C_NOT current_report->first_detail) !* {
        current_report->first_detail = current_report->heading;
    } *!
    if (C_NOT current_report->last_control) !* {
        if (current_report->last_detail) !* {
            current_report->last_control = current_report->last_detail;
        } *! else if (current_report->footing) !* {
            current_report->last_control = current_report->footing;
        } *! else !* {
            current_report->last_control = current_report->lines;
        } *!
    } *!
    if (C_NOT current_report->last_detail && C_NOT current_report->footing) !* {
        current_report->last_detail = current_report->lines;
        current_report->footing = current_report->lines;
    } *! else if (C_NOT current_report->last_detail) !* {
        current_report->last_detail = current_report->footing;
    } *! else if (C_NOT current_report->footing) !* {
        current_report->footing = current_report->last_detail;
    } *!
    if (current_report->heading > current_report->first_detail ||
        current_report->first_detail > current_report->last_control ||
        current_report->last_control > current_report->last_detail ||
        current_report->last_detail > current_report->footing) !* {
        cb_error (_("invalid %s clause"), "PAGE");
    } *!
  } *!


<page_line_column>
::=  <report_integer>   !* {
    current_report->lines = cb_get_int ($1);
  } *!
| <report_integer> <line_or_lines> <report_integer> <columns_or_cols>   !* {
    current_report->lines = cb_get_int ($1);
    current_report->columns = cb_get_int ($3);
  } *!
| <report_integer> <line_or_lines>  !* {
    current_report->lines = cb_get_int ($1);
  } *!


<_page_heading_list>
::=| <_page_heading_list> <page_detail>



<page_detail>
::=  <heading_clause>
| <first_detail>
| <last_heading>
| <last_detail>
| <footing_clause>


<heading_clause>
::=  HEADING <_is> <report_integer> !* {
    current_report->heading = cb_get_int ($3);
  } *!


<first_detail>
::=  FIRST <detail_keyword> <_is> <report_integer>  !* {
    current_report->first_detail = cb_get_int ($4);
  } *!


<last_heading>
::=  LAST <ch_keyword> <_is> <report_integer>   !* {
    current_report->last_control = cb_get_int ($4);
  } *!


<last_detail>
::=  LAST <detail_keyword> <_is> <report_integer>   !* {
    current_report->last_detail = cb_get_int ($4);
  } *!


<footing_clause>
::=  FOOTING <_is> <report_integer> !* {
    current_report->footing = cb_get_int ($3);
  } *!


<_report_group_description_list>
::=| <_report_group_description_list> <report_group_description_entry>


<report_group_description_entry>
::=  <level_number> <_entry_name>   !* {
    check_pic_duplicate = 0;
  } *!  <_report_group_options> TOK_DOT


<_report_group_options>
::=| <_report_group_options> <report_group_option>


<report_group_option>
::=  <type_clause>
| <next_group_clause>
| <line_clause>
| <picture_clause>
| <report_usage_clause>
| <sign_clause>
| <justified_clause>
| <column_clause>
| <blank_clause>
| <source_clause>
| <sum_clause_list>
| <value_clause>
| <present_when_condition>
| <group_indicate_clause>
| <report_occurs_clause>
| <varying_clause>


<type_clause>
::=  TYPE <_is> <type_option>   !* {
    check_repeated ("TYPE", SYN_CLAUSE_16, &check_pic_duplicate);
  } *!


<type_option>
::=  <rh_keyword>
| <ph_keyword>
| <ch_keyword> <_control_final>
| <detail_keyword>
| <cf_keyword> <_control_final>
| <pf_keyword>
| <rf_keyword>


<_control_final>
::=| <identifier> <_or_page>
| FINAL <_or_page>


<_or_page>
::=| OR PAGE


<next_group_clause>
::=  NEXT GROUP <_is> <line_or_plus>    !* {
    check_repeated ("NEXT GROUP", SYN_CLAUSE_17, &check_pic_duplicate);
  } *!


<sum_clause_list>
::=  SUM <_of> <report_x_list> <_reset_clause>  !* {
    check_repeated ("SUM", SYN_CLAUSE_19, &check_pic_duplicate);
  } *!


<_reset_clause>
::=| RESET <_on> <data_or_final>


<data_or_final>
::=  <identifier>
| FINAL


<present_when_condition>
::=  PRESENT WHEN <condition>   !* {
    check_repeated ("PRESENT", SYN_CLAUSE_20, &check_pic_duplicate);
  } *!


<varying_clause>
::=  VARYING <identifier> FROM <arith_x> BY <arith_x>


<line_clause>
::=  <line_keyword_clause> <report_line_integer_list>   !* {
    check_repeated ("LINE", SYN_CLAUSE_21, &check_pic_duplicate);
  } *!


<line_keyword_clause>
::=  LINE <_numbers> <_is_are>
| LINES <_are>


<column_clause>
::=  <col_keyword_clause> <report_col_integer_list> !* {
    check_repeated ("COLUMN", SYN_CLAUSE_18, &check_pic_duplicate);
  } *!


<col_keyword_clause>
::=  <column_or_col> <_numbers> <_is_are>
| <columns_or_cols> <_are>


<report_line_integer_list>
::=  <line_or_plus>
| <report_line_integer_list> <line_or_plus>


<line_or_plus>
::=  PLUS <integer>
| <report_integer>
| NEXT_PAGE


<report_col_integer_list>
::=  <col_or_plus>
| <report_col_integer_list> <col_or_plus>


<col_or_plus>
::=  PLUS <integer>
| <report_integer>


<source_clause>
::=  SOURCE <_is> <arith_x> <flag_rounded>  !* {
    check_repeated ("SOURCE", SYN_CLAUSE_22, &check_pic_duplicate);
  } *!


<group_indicate_clause>
::=  GROUP <_indicate>  !* {
    check_repeated ("GROUP", SYN_CLAUSE_23, &check_pic_duplicate);
  } *!


<report_usage_clause>
::=  USAGE <_is> DISPLAY    !* {
    check_repeated ("USAGE", SYN_CLAUSE_24, &check_pic_duplicate);
  } *!

    !* SCREEN SECTION *!

<_screen_section>
::=| SCREEN SECTION TOK_DOT !* {
    current_storage = CB_STORAGE_SCREEN;
    current_field = NULL;
    description_field = NULL;
    cb_clear_real_field ();
  } *!  <_screen_description_list>  !* {
    struct cb_field *p;

    if (description_field) !* {
        for (p = description_field; p; p = p->sister) !* {
            cb_validate_field (p);
        } *!
        current_program->screen_storage = description_field;
        current_program->flag_screen = 1;
    } *!
  } *!


<_screen_description_list>
::=| <screen_description_list>


<screen_description_list>
::=  <screen_description> TOK_DOT
| <screen_description_list> <screen_description> TOK_DOT


<screen_description>
::=  <constant_entry>
| <level_number> <_entry_name>  !* {
    cb_tree x;

    x = cb_build_field_tree ($1, $2, current_field, current_storage,
                 current_file, 0);  !* Free tree associated with level number *!
    cobc_parse_free ($1);
    check_pic_duplicate = 0;
    if (CB_INVALID_TREE (x)) !* {
        YYERROR;
    } *!

    current_field = CB_FIELD (x);
    if (current_field->parent) !* {
        current_field->screen_foreg = current_field->parent->screen_foreg;
        current_field->screen_backg = current_field->parent->screen_backg;
        current_field->screen_prompt = current_field->parent->screen_prompt;
    } *!
  } *!  <_screen_options>   !* {
    cob_flags_t flags;

    if (current_field->parent) !* {
        flags = current_field->parent->screen_flag;
        flags &= ~COB_SCREEN_BLANK_LINE;
        flags &= ~COB_SCREEN_BLANK_SCREEN;
        flags &= ~COB_SCREEN_ERASE_EOL;
        flags &= ~COB_SCREEN_ERASE_EOS;
        flags &= ~COB_SCREEN_LINE_PLUS;
        flags &= ~COB_SCREEN_LINE_MINUS;
        flags &= ~COB_SCREEN_COLUMN_PLUS;
        flags &= ~COB_SCREEN_COLUMN_MINUS;

        flags = zero_conflicting_flags (current_field->screen_flag,
                        flags);

        current_field->screen_flag |= flags;
    } *!

    if (current_field->screen_flag & COB_SCREEN_INITIAL) !* {
        if (C_NOT (current_field->screen_flag & COB_SCREEN_INPUT)) !* {
            cb_error (_("INITIAL specified on non-input field"));
        } *!
    } *!
    if (C_NOT qualifier) !* {
        current_field->flag_filler = 1;
    } *!

    if (likely (current_field)) !* {
        if (C_NOT description_field) !* {
            description_field = current_field;
        } *!
        if (current_field->flag_occurs
            && C_NOT has_relative_pos (current_field)) !* {
            cb_error (_("relative LINE/COLUMN clause required with OCCURS"));
        } *!
    } *!
  } *!
!bison error token | <level_number> <error> TOK_DOT  
 !* {    !* Free tree associated with level number *!
    cobc_parse_free ($1);
    yyerrok;
    cb_unput_dot ();
    check_pic_duplicate = 0;
    check_duplicate = 0;
#if 1   !* RXWRXW Screen field *!
    if (current_field) !* {
        current_field->flag_is_verified = 1;
        current_field->flag_invalid = 1;
    } *!
#endif
    current_field = cb_get_real_field ();
  } *!


<_screen_options>
::=  !* empty *!
| <_screen_options> <screen_option>


<screen_option>
::=  BLANK LINE !* {
    set_screen_attr_with_conflict ("BLANK LINE", COB_SCREEN_BLANK_LINE,
                       "BLANK SCREEN", COB_SCREEN_BLANK_SCREEN);
  } *!
| BLANK SCREEN  !* {
    set_screen_attr_with_conflict ("BLANK SCREEN", COB_SCREEN_BLANK_SCREEN,
                       "BLANK LINE", COB_SCREEN_BLANK_LINE);
  } *!
| BELL  !* {
    set_screen_attr ("BELL", COB_SCREEN_BELL);
  } *!
| BLINK !* {
    set_screen_attr ("BLINK", COB_SCREEN_BLINK);
  } *!
| ERASE <eol>   !* {
    set_screen_attr_with_conflict ("ERASE EOL", COB_SCREEN_ERASE_EOL,
                       "ERASE EOS", COB_SCREEN_ERASE_EOS);
  } *!
| ERASE <eos>   !* {
    set_screen_attr_with_conflict ("ERASE EOS", COB_SCREEN_ERASE_EOS,
                       "ERASE EOL", COB_SCREEN_ERASE_EOL);
  } *!
| HIGHLIGHT !* {
    set_screen_attr_with_conflict ("HIGHLIGHT", COB_SCREEN_HIGHLIGHT,
                       "LOWLIGHT", COB_SCREEN_LOWLIGHT);
  } *!
| LOWLIGHT  !* {
    set_screen_attr_with_conflict ("LOWLIGHT", COB_SCREEN_LOWLIGHT,
                       "HIGHLIGHT", COB_SCREEN_HIGHLIGHT);
  } *!
| <reverse_video>   !* {
    set_screen_attr ("REVERSE-VIDEO", COB_SCREEN_REVERSE);
  } *!
| UNDERLINE !* {
    set_screen_attr ("UNDERLINE", COB_SCREEN_UNDERLINE);
  } *!
| OVERLINE  !* {
    set_screen_attr ("OVERLINE", COB_SCREEN_OVERLINE);
    CB_PENDING ("OVERLINE");
  } *!
| GRID  !* {
    set_screen_attr ("GRID", COB_SCREEN_GRID);
    CB_PENDING ("GRID");
  } *!
| LEFTLINE  !* {
    set_screen_attr ("LEFTLINE", COB_SCREEN_LEFTLINE);
    CB_PENDING ("LEFTLINE");
  } *!
| AUTO  !* {
    set_screen_attr_with_conflict ("AUTO", COB_SCREEN_AUTO,
                       "TAB", COB_SCREEN_TAB);
  } *!
| TAB   !* {
    set_screen_attr_with_conflict ("TAB", COB_SCREEN_TAB,
                       "AUTO", COB_SCREEN_AUTO);
  } *!
| SECURE    !* {
    set_screen_attr_with_conflict ("SECURE", COB_SCREEN_SECURE,
                       "NO-ECHO", COB_SCREEN_NO_ECHO);
  } *!
| <no_echo> !* {
    if (cb_no_echo_means_secure) !* {
        set_screen_attr ("SECURE", COB_SCREEN_SECURE);
    } *! else !* {
        set_screen_attr_with_conflict ("NO-ECHO", COB_SCREEN_NO_ECHO,
                           "SECURE", COB_SCREEN_SECURE);
    } *!
  } *!
| REQUIRED  !* {
    set_screen_attr ("REQUIRED", COB_SCREEN_REQUIRED);
  } *!
| FULL  !* {
    set_screen_attr ("FULL", COB_SCREEN_FULL);
  } *!
| PROMPT CHARACTER <_is> <id_or_lit>    !* {
    set_screen_attr ("PROMPT", COB_SCREEN_PROMPT);
    current_field->screen_prompt = $4;
  } *!
| PROMPT    !* {
    set_screen_attr ("PROMPT", COB_SCREEN_PROMPT);
  } *!
| TOK_INITIAL   !* {
    set_screen_attr ("INITIAL", COB_SCREEN_INITIAL);
  } *!
| LINE <screen_line_number> !* {
    check_repeated ("LINE", SYN_CLAUSE_16, &check_pic_duplicate);
  } *!
| <column_or_col> <screen_col_number>   !* {
    check_repeated ("COLUMN", SYN_CLAUSE_17, &check_pic_duplicate);
  } *!
| FOREGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("FOREGROUND-COLOR", SYN_CLAUSE_18, &check_pic_duplicate);
    current_field->screen_foreg = $3;
  } *!
| BACKGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("BACKGROUND-COLOR", SYN_CLAUSE_19, &check_pic_duplicate);
    current_field->screen_backg = $3;
  } *!
| <usage_clause>
| <blank_clause>
| <screen_global_clause>
| <justified_clause>
| <sign_clause>
| <value_clause>
| <picture_clause>
| <screen_occurs_clause>
| USING <identifier>    !* {
    check_not_88_level ($2);

    check_repeated ("USING", SYN_CLAUSE_20, &check_pic_duplicate);
    current_field->screen_from = $2;
    current_field->screen_to = $2;
    current_field->screen_flag |= COB_SCREEN_INPUT;
  } *!
| FROM <from_parameter> !* {
    check_repeated ("FROM", SYN_CLAUSE_21, &check_pic_duplicate);
    current_field->screen_from = $2;
  } *!
| TO <identifier>   !* {
    check_not_88_level ($2);

    check_repeated ("TO", SYN_CLAUSE_22, &check_pic_duplicate);
    current_field->screen_to = $2;
    current_field->screen_flag |= COB_SCREEN_INPUT;
  } *!


<eol>
::=  EOL
| <_end_of> LINE


<eos>
::=  EOS
| <_end_of> SCREEN


<plus_plus>
::=  PLUS
| TOK_PLUS


<minus_minus>
::=  MINUS
| TOK_MINUS


<screen_line_number>
::=  <_number> <_is> <_screen_line_plus_minus> <num_id_or_lit>  !* {
    if ($4) !* {
        current_field->screen_line = $4;
    } *!
  } *!


<_screen_line_plus_minus>
::=  !* empty *!    !* {    !* Nothing *!
  } *!
| <plus_plus>   !* {
    current_field->screen_flag |= COB_SCREEN_LINE_PLUS;
  } *!
| <minus_minus> !* {
    current_field->screen_flag |= COB_SCREEN_LINE_MINUS;
  } *!


<screen_col_number>
::=  <_number> <_is> <_screen_col_plus_minus> <num_id_or_lit>   !* {
    if ($4) !* {
        current_field->screen_column = $4;
    } *!
  } *!


<_screen_col_plus_minus>
::=  !* empty *!    !* {    !* Nothing *!
  } *!
| <plus_plus>   !* {
    current_field->screen_flag |= COB_SCREEN_COLUMN_PLUS;
  } *!
| <minus_minus> !* {
    current_field->screen_flag |= COB_SCREEN_COLUMN_MINUS;
  } *!


<screen_occurs_clause>
::=  OCCURS <integer> <_times>  !* {
    check_repeated ("OCCURS", SYN_CLAUSE_23, &check_pic_duplicate);
    current_field->occurs_max = cb_get_int ($2);
    current_field->occurs_min = current_field->occurs_max;
    current_field->indexes++;
    current_field->flag_occurs = 1;
  } *!


<screen_global_clause>
::=  <_is> GLOBAL   !* {
    CB_PENDING (_("GLOBAL screen items"));
  } *!

    !* PROCEDURE DIVISION *!

<_procedure_division>
::=  !* empty *!    !* {
    current_section = NULL;
    current_paragraph = NULL;
    check_pic_duplicate = 0;
    check_duplicate = 0;
    if (C_NOT current_program->entry_convention) !* {
        current_program->entry_convention = cb_int (CB_CONV_COBOL);
    } *!
  } *!
| PROCEDURE DIVISION <_mnemonic_conv> <_procedure_using_chaining> <_procedure_returning> TOK_DOT    !* {
    current_section = NULL;
    current_paragraph = NULL;
    check_pic_duplicate = 0;
    check_duplicate = 0;
    cobc_in_procedure = 1U;
    cb_set_system_names ();
    if ($3) !* {
        if (current_program->entry_convention) !* {
            cb_warning (_("overriding convention specified in ENTRY-CONVENTION"));
        } *!
        current_program->entry_convention = $3;
    } *! else if (C_NOT current_program->entry_convention) !* {
        current_program->entry_convention = cb_int (CB_CONV_COBOL);
    } *!
    header_check |= COBC_HD_PROCEDURE_DIVISION;
  } *!  <_procedure_declaratives>   !* {
    if (current_program->flag_main && C_NOT current_program->flag_chained && $4) !* {
        cb_error (_("executable program requested but PROCEDURE/ENTRY has USING clause"));
    } *!    !* Main entry point *!
    emit_entry (current_program->program_id, 0, $4, NULL);
    current_program->num_proc_params = cb_list_length ($4);
    if (current_program->source_name) !* {
        emit_entry (current_program->source_name, 1, $4, NULL);
    } *!
  } *!  <_procedure_list>   !* {
    if (current_paragraph) !* {
        if (current_paragraph->exit_label) !* {
            emit_statement (current_paragraph->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_paragraph));
    } *!
    if (current_section) !* {
        if (current_section->exit_label) !* {
            emit_statement (current_section->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_section));
    } *!
  } *!
|   !* {
    cb_tree label;
    !* No PROCEDURE DIVISION header here *! !* Only a statement is allowed as first element *!  !* Thereafter, sections/paragraphs may be used *!
    check_pic_duplicate = 0;
    check_duplicate = 0;
    if (C_NOT current_program->entry_convention) !* {
        current_program->entry_convention = cb_int (CB_CONV_COBOL);
    } *!
    cobc_in_procedure = 1U;
    label = cb_build_reference ("MAIN SECTION");
    current_section = CB_LABEL (cb_build_label (label, NULL));
    current_section->flag_section = 1;
    current_section->flag_dummy_section = 1;
    current_section->flag_skip_label = C_MAKE_BOOL skip_statements;
    current_section->flag_declaratives = C_MAKE_BOOL in_declaratives;
    current_section->xref.skip = 1;
    CB_TREE (current_section)->source_file = cb_source_file;
    CB_TREE (current_section)->source_line = cb_source_line;
    emit_statement (CB_TREE (current_section));
    label = cb_build_reference ("MAIN PARAGRAPH");
    current_paragraph = CB_LABEL (cb_build_label (label, NULL));
    current_paragraph->flag_declaratives = C_MAKE_BOOL in_declaratives;
    current_paragraph->flag_skip_label = C_MAKE_BOOL skip_statements;
    current_paragraph->flag_dummy_paragraph = 1;
    current_paragraph->xref.skip = 1;
    CB_TREE (current_paragraph)->source_file = cb_source_file;
    CB_TREE (current_paragraph)->source_line = cb_source_line;
    emit_statement (CB_TREE (current_paragraph));
    cb_set_system_names ();
  } *!  <statements> TOK_DOT <_procedure_list>


<_procedure_using_chaining>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| USING !* {
    call_mode = CB_CALL_BY_REFERENCE;
    size_mode = CB_SIZE_4;
  } *!  <procedure_param_list>  !* {
    if (cb_list_length ($3) > MAX_CALL_FIELD_PARAMS) !* {
        cb_error (_("number of parameters exceeds maximum %d"),
              MAX_CALL_FIELD_PARAMS);
    } *!
    $$ = $3;
  } *!
| CHAINING  !* {
    call_mode = CB_CALL_BY_REFERENCE;
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("CHAINING invalid in user FUNCTION"));
    } *! else !* {
        current_program->flag_chained = 1;
    } *!
  } *!  <procedure_param_list>  !* {
    if (cb_list_length ($3) > MAX_CALL_FIELD_PARAMS) !* {
        cb_error (_("number of parameters exceeds maximum %d"),
              MAX_CALL_FIELD_PARAMS);
    } *!
    $$ = $3;
  } *!


<procedure_param_list>
::=  <procedure_param>      !* { $$ = $1; } *!
| <procedure_param_list>  <procedure_param>     !* { $$ = cb_list_append ($1, $2); } *!


<procedure_param>
::=  <_procedure_type> <_size_optional> <_procedure_optional> <WORD>  !* {
    cb_tree     x;
    struct cb_field *f;

    x = cb_build_identifier ($4, 0);
    if ($3 == cb_int1 && CB_VALID_TREE (x) && cb_ref (x) <> cb_error_node) !* {
        f = CB_FIELD (cb_ref (x));
        f->flag_is_pdiv_opt = 1;
    } *!

    if (call_mode == CB_CALL_BY_VALUE
        && CB_REFERENCE_P ($4)
        && CB_FIELD (cb_ref ($4))->flag_any_length) !* {
        cb_error_x ($4, _("ANY LENGTH items may only be BY REFERENCE formal parameters"));
    } *!

    $$ = CB_BUILD_PAIR (cb_int (call_mode), x);
    CB_SIZES ($$) = size_mode;
  } *!
| COMMA_DELIM !* HACK, should not reach parser *!


<_procedure_type>
::=  !* empty *!
| <_by> REFERENCE   !* {
    call_mode = CB_CALL_BY_REFERENCE;
  } *!
| <_by> VALUE   !* {
    if (current_program->flag_chained) !* {
        cb_error (_("%s not allowed in CHAINED programs"), "BY VALUE");
    } *! else !* {
        CB_UNFINISHED (_("parameters passed BY VALUE"));
        call_mode = CB_CALL_BY_VALUE;
    } *!
  } *!


<_size_optional>
::=  !* empty *!
| SIZE <_is> AUTO   !* {
    if (call_mode <> CB_CALL_BY_VALUE) !* {
        cb_error (_("SIZE only allowed for BY VALUE items"));
    } *! else !* {
        size_mode = CB_SIZE_AUTO;
    } *!
  } *!
| SIZE <_is> DEFAULT    !* {
    if (call_mode <> CB_CALL_BY_VALUE) !* {
        cb_error (_("SIZE only allowed for BY VALUE items"));
    } *! else !* {
        size_mode = CB_SIZE_4;
    } *!
  } *!
| UNSIGNED SIZE <_is> AUTO  !* {
    if (call_mode <> CB_CALL_BY_VALUE) !* {
        cb_error (_("SIZE only allowed for BY VALUE items"));
    } *! else !* {
        size_mode = CB_SIZE_AUTO | CB_SIZE_UNSIGNED;
    } *!
  } *!
| UNSIGNED <size_is_integer>    !* {
    if (size_mode) !* {
        size_mode |= CB_SIZE_UNSIGNED;
    } *!
  } *!
| <size_is_integer>


<size_is_integer>
::=  SIZE <_is> <integer>   !* {
    unsigned char *s = CB_LITERAL ($3)->data;
    size_mode = 0;

    if (call_mode <> CB_CALL_BY_VALUE) !* {
        cb_error (_("SIZE only allowed for BY VALUE items"));
    } *! else if (CB_LITERAL ($3)->size <> 1) !* {
        cb_error_x ($3, _("invalid value for SIZE"));
    } *! else !* {
        size_mode = 0;
        switch (*s) !* {
        case '1':
            size_mode = CB_SIZE_1;
            break;
        case '2':
            size_mode = CB_SIZE_2;
            break;
        case '4':
            size_mode = CB_SIZE_4;
            break;
        case '8':
            size_mode = CB_SIZE_8;
            break;
        default:
            cb_error_x ($3, _("invalid value for SIZE"));
            break;
        } *!
    } *!
  } *!


<_procedure_optional>
::=  !* empty *!    !* {
    $$ = cb_int0;
  } *!
| OPTIONAL  !* {
    if (call_mode <> CB_CALL_BY_REFERENCE) !* {
        cb_error (_("OPTIONAL only allowed for BY REFERENCE items"));
        $$ = cb_int0;
    } *! else !* {
        $$ = cb_int1;
    } *!
  } *!


<_procedure_returning>
::=  !* empty *!    !* {
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("RETURNING clause is required for a FUNCTION"));
    } *!
  } *!
| RETURNING OMITTED !* {
    if (current_program->flag_main) !* {
        cb_error (_("RETURNING clause cannot be OMITTED for main program"));
    } *!
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("RETURNING clause cannot be OMITTED for a FUNCTION"));
    } *!
    current_program->flag_void = 1;
  } *!
| RETURNING <WORD>    !* {
    struct cb_field *f;

    if (cb_ref ($2) <> cb_error_node) !* {
        f = CB_FIELD_PTR ($2);  !* standard rule: returning item is allocated in the
           activating runtime element *!
        if (f->storage <> CB_STORAGE_LINKAGE) !* {
            cb_error (_("RETURNING item is not defined in LINKAGE SECTION"));
        } *! else if (f->level <> 1 && f->level <> 77) !* {
            cb_error (_("RETURNING item must have level 01"));
        } *! else if (f->flag_occurs) !* {
            cb_error (_("RETURNING item should not have OCCURS"));
        } *! else if (f->storage == CB_STORAGE_LOCAL) !* {
            cb_error (_("RETURNING item should not be in LOCAL-STORAGE"));
        } *! else !* {
            if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
                if (f->flag_any_length) !* {
                    cb_error (_("function RETURNING item may not be ANY LENGTH"));
                } *!

                f->flag_is_returning = 1;
            } *!
            current_program->returning = $2;
        } *!
    } *!
  } *!


<_procedure_declaratives>
::=| DECLARATIVES TOK_DOT   !* {
    in_declaratives = 1;
    emit_statement (cb_build_comment ("DECLARATIVES"));
  } *!  <_procedure_list>  END DECLARATIVES TOK_DOT !* {
    if (needs_field_debug) !* {
        start_debug = 1;
    } *!
    in_declaratives = 0;
    in_debugging = 0;
    if (current_paragraph) !* {
        if (current_paragraph->exit_label) !* {
            emit_statement (current_paragraph->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_paragraph));
        current_paragraph = NULL;
    } *!
    if (current_section) !* {
        if (current_section->exit_label) !* {
            emit_statement (current_section->exit_label);
        } *!
        current_section->flag_fatal_check = 1;
        emit_statement (cb_build_perform_exit (current_section));
        current_section = NULL;
    } *!
    skip_statements = 0;
    emit_statement (cb_build_comment ("END DECLARATIVES"));
    check_unreached = 0;
  } *!


    !* Procedure list *!

<_procedure_list>
::=| <_procedure_list> <procedure>


<procedure>
::=  <section_header>
| <paragraph_header>
| <statements> TOK_DOT  !* {
    if (next_label_list) !* {
        cb_tree plabel;
        char    name[32];

        snprintf (name, sizeof(name), "L$%d", next_label_id);
        plabel = cb_build_label (cb_build_reference (name), NULL);
        CB_LABEL (plabel)->flag_next_sentence = 1;
        emit_statement (plabel);
        current_program->label_list =
            cb_list_append (current_program->label_list, next_label_list);
        next_label_list = NULL;
        next_label_id++;
    } *!    !* check_unreached = 0; *!
  } *!
!| <invalid_statement> !* %prec SHIFT_PREFER *!
| TOK_DOT   !* {    !* check_unreached = 0; *!
  } *!


    !* Section/Paragraph *!

<section_header>
::=  <WORD> SECTION <_segment> TOK_DOT    !* {
    non_const_word = 0;
    check_unreached = 0;
    if (cb_build_section_name ($1, 0) == cb_error_node) !* {
        YYERROR;
    } *!
    !* Exit the last paragraph/section *!
    if (current_paragraph) !* {
        if (current_paragraph->exit_label) !* {
            emit_statement (current_paragraph->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_paragraph));
    } *!
    if (current_section) !* {
        if (current_section->exit_label) !* {
            emit_statement (current_section->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_section));
    } *!
    if (current_program->flag_debugging && C_NOT in_debugging) !* {
        if (current_paragraph || current_section) !* {
            emit_statement (cb_build_comment (
                    "DEBUGGING - Fall through"));
            emit_statement (cb_build_debug (cb_debug_contents,
                    "FALL THROUGH", NULL));
        } *!
    } *!
    !* Begin a new section *!
    current_section = CB_LABEL (cb_build_label ($1, NULL));
    if ($3) !* {
        current_section->segment = cb_get_int ($3);
    } *!
    current_section->flag_section = 1;  !* Careful here, one negation *!
    current_section->flag_real_label = C_NOT in_debugging;
    current_section->flag_declaratives = C_MAKE_BOOL in_declaratives;
    current_section->flag_skip_label = C_MAKE_BOOL skip_statements;
    CB_TREE (current_section)->source_file = cb_source_file;
    CB_TREE (current_section)->source_line = cb_source_line;
    current_paragraph = NULL;
  } *!  <_use_statement>    !* {
    emit_statement (CB_TREE (current_section));
  } *!


<_use_statement>
::=| <use_statement> TOK_DOT


<paragraph_header>
::=  <IntLiteral or WORD> TOK_DOT   !* {
    cb_tree label;

    non_const_word = 0;
    check_unreached = 0;
    if (cb_build_section_name ($1, 1) == cb_error_node) !* {
        YYERROR;
    } *!
    !* Exit the last paragraph *!
    if (current_paragraph) !* {
        if (current_paragraph->exit_label) !* {
            emit_statement (current_paragraph->exit_label);
        } *!
        emit_statement (cb_build_perform_exit (current_paragraph));
        if (current_program->flag_debugging && C_NOT in_debugging) !* {
            emit_statement (cb_build_comment (
                    "DEBUGGING - Fall through"));
            emit_statement (cb_build_debug (cb_debug_contents,
                    "FALL THROUGH", NULL));
        } *!
    } *!
    !* Begin a new paragraph *!
    if (C_NOT current_section) !* {
        label = cb_build_reference ("MAIN SECTION");
        current_section = CB_LABEL (cb_build_label (label, NULL));
        current_section->flag_section = 1;
        current_section->flag_dummy_section = 1;
        current_section->flag_declaratives = C_MAKE_BOOL in_declaratives;
        current_section->flag_skip_label = C_MAKE_BOOL skip_statements;
        current_section->xref.skip = 1;
        CB_TREE (current_section)->source_file = cb_source_file;
        CB_TREE (current_section)->source_line = cb_source_line;
        emit_statement (CB_TREE (current_section));
    } *!
    current_paragraph = CB_LABEL (cb_build_label ($1, current_section));
    current_paragraph->flag_declaratives = C_MAKE_BOOL in_declaratives;
    current_paragraph->flag_skip_label = C_MAKE_BOOL skip_statements;
    current_paragraph->flag_real_label = C_NOT in_debugging;
    current_paragraph->segment = current_section->segment;
    CB_TREE (current_paragraph)->source_file = cb_source_file;
    CB_TREE (current_paragraph)->source_line = cb_source_line;
    emit_statement (CB_TREE (current_paragraph));
  } *!

<IntLiteral or WORD>
::= IntLiteral
  | <WORD> 

!<invalid_statement>
!::=  <WORD>   !* {
!    non_const_word = 0;
!    check_unreached = 0;
!    if (cb_build_section_name ($1, 0) <> cb_error_node) !* {
!        if (is_reserved_word (CB_NAME ($1))) !* {
!            cb_error_x ($1, _("'%s' is not a statement"), CB_NAME ($1));
!        } *! else if (is_default_reserved_word (CB_NAME ($1))) !* {
!            cb_error_x ($1, _("unknown statement '%s'; it may exist in another dialect"),
!                    CB_NAME ($1));
!        } *! else !* {
!            cb_error_x ($1, _("unknown statement '%s'"), CB_NAME ($1));
!        } *!
!    } *!
!    YYERROR;
!  } *!


<_segment>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <integer> !* {
    if (in_declaratives) !* {
        cb_error (_("SECTION segment invalid within DECLARATIVE"));
    } *!
    if (cb_verify (cb_section_segments, _("SECTION segment"))) !* {
        current_program->flag_segments = 1;
        $$ = $1;
    } *! else !* {
        $$ = NULL;
    } *!
  } *!


    !* Statements *!

<statement_list>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = current_program->exec_list;
    current_program->exec_list = NULL;
    check_unreached = 0;
  } *!  !* {
    $$ = CB_TREE (current_statement);
    current_statement = NULL;
  } *!  <statements>    !* {
    $$ = cb_list_reverse (current_program->exec_list);
    current_program->exec_list = $1;
    current_statement = CB_STATEMENT ($2);
  } *!


<statements>
::=  !* {
    cb_tree label;

    if (C_NOT current_section) !* {
        label = cb_build_reference ("MAIN SECTION");
        current_section = CB_LABEL (cb_build_label (label, NULL));
        current_section->flag_section = 1;
        current_section->flag_dummy_section = 1;
        current_section->flag_skip_label = C_MAKE_BOOL skip_statements;
        current_section->flag_declaratives = C_MAKE_BOOL in_declaratives;
        current_section->xref.skip = 1;
        CB_TREE (current_section)->source_file = cb_source_file;
        CB_TREE (current_section)->source_line = cb_source_line;
        emit_statement (CB_TREE (current_section));
    } *!
    if (C_NOT current_paragraph) !* {
        label = cb_build_reference ("MAIN PARAGRAPH");
        current_paragraph = CB_LABEL (cb_build_label (label, NULL));
        current_paragraph->flag_declaratives = C_MAKE_BOOL in_declaratives;
        current_paragraph->flag_skip_label = C_MAKE_BOOL skip_statements;
        current_paragraph->flag_dummy_paragraph = 1;
        current_paragraph->xref.skip = 1;
        CB_TREE (current_paragraph)->source_file = cb_source_file;
        CB_TREE (current_paragraph)->source_line = cb_source_line;
        emit_statement (CB_TREE (current_paragraph));
    } *!
    if (check_headers_present (COBC_HD_PROCEDURE_DIVISION, 0, 0, 0) == 1) !* {
        if (current_program->prog_type == CB_PROGRAM_TYPE) !* {
            emit_entry (current_program->program_id, 0, NULL, NULL);
        } *!
    } *!
  } *!  <statement> !* {
    cobc_cs_check = 0;
  } *!
| <statements> <statement>  !* {
    cobc_cs_check = 0;
  } *!


<statement>
::=  <accept_statement>
| <add_statement>
| <allocate_statement>
| <alter_statement>
| <call_statement>
| <cancel_statement>
| <close_statement>
| <commit_statement>
| <compute_statement>
| <continue_statement>
| <delete_statement>
| <disable_statement>
| <display_statement>
| <divide_statement>
| <enable_statement>
| <entry_statement>
| <evaluate_statement>
| <exit_statement>
| <free_statement>
| <generate_statement>
| <goto_statement>
| <goback_statement>
| <if_statement>
| <initialize_statement>
| <initiate_statement>
| <inspect_statement>
| <merge_statement>
| <move_statement>
| <multiply_statement>
| <open_statement>
| <perform_statement>
| <purge_statement>
| <read_statement>
| <ready_statement>
| <receive_statement>
| <release_statement>
| <reset_statement>
| <return_statement>
| <rewrite_statement>
| <rollback_statement>
| <search_statement>
| <send_statement>
| <set_statement>
| <sort_statement>
| <start_statement>
| <stop_statement>
| <string_statement>
| <subtract_statement>
| <suppress_statement>
| <terminate_statement>
| <transform_statement>
| <unlock_statement>
| <unstring_statement>
| <write_statement>
| !* %prec SHIFT_PREFER *!  NEXT SENTENCE   !* {
    if (cb_verify (cb_next_sentence_phrase, "NEXT SENTENCE")) !* {
        cb_tree label;
        char    name[32];

        begin_statement ("NEXT SENTENCE", 0);
        sprintf (name, "L$%d", next_label_id);
        label = cb_build_reference (name);
        next_label_list = cb_list_add (next_label_list, label);
        emit_statement (cb_build_goto (label, NULL));
    } *!
    check_unreached = 0;
  } *!
!bison error token | <error> <error_stmt_recover>
  !* {
    yyerrok;
    cobc_cs_check = 0;
  } *!


    !* ACCEPT statement *!

<accept_statement>
::=  ACCEPT !* {
    begin_statement ("ACCEPT", TERM_ACCEPT);
    cobc_cs_check = CB_CS_ACCEPT;
  } *!  <accept_body>  <end_accept>


<accept_body>
::=  <accp_identifier>  !* {
      check_duplicate = 0;
      check_line_col_duplicate = 0;
      line_column = NULL;
  } *!  <_accept_clauses> <_accept_exception_phrases>   !* {    !* Check for invalid use of screen clauses *!
    if (current_statement->attr_ptr
        || (C_NOT is_screen_field ($1) && line_column)) !* {
        cb_verify_x ($1, cb_accept_display_extensions,
                 _("non-standard ACCEPT"));
    } *!

    if (cb_accept_update && C_NOT has_dispattr (COB_SCREEN_NO_UPDATE)) !* {
        set_dispattr (COB_SCREEN_UPDATE);
    } *!
    if (cb_accept_auto && C_NOT has_dispattr (COB_SCREEN_TAB)) !* {
        set_dispattr (COB_SCREEN_AUTO);
    } *!
    if ($1 == cb_null && current_statement->attr_ptr) !* {
        if (current_statement->attr_ptr->prompt) !* {
            emit_conflicting_clause_message ("ACCEPT OMITTED",
                _("PROMPT clause"));
        } *!
        if (current_statement->attr_ptr->size_is) !* {
            emit_conflicting_clause_message ("ACCEPT OMITTED",
                _("SIZE IS clause"));
        } *!
    } *!
    cobc_cs_check = 0;
    cb_emit_accept ($1, line_column, current_statement->attr_ptr);
  } *!
| <identifier> FROM <lines_or_number>   !* {
    cb_emit_accept_line_or_col ($1, 0);
  } *!
| <identifier> FROM <columns_or_cols>   !* {
    cb_emit_accept_line_or_col ($1, 1);
  } *!
| <identifier> FROM DATE YYYYMMDD   !* {
    cobc_cs_check = 0;
    cb_emit_accept_date_yyyymmdd ($1);
  } *!
| <identifier> FROM DATE    !* {
    cobc_cs_check = 0;
    cb_emit_accept_date ($1);
  } *!
| <identifier> FROM DAY YYYYDDD !* {
    cobc_cs_check = 0;
    cb_emit_accept_day_yyyyddd ($1);
  } *!
| <identifier> FROM DAY !* {
    cobc_cs_check = 0;
    cb_emit_accept_day ($1);
  } *!
| <identifier> FROM DAY_OF_WEEK !* {
    cb_emit_accept_day_of_week ($1);
  } *!
| <identifier> FROM ESCAPE KEY  !* {
    cb_emit_accept_escape_key ($1);
  } *!
| <identifier> FROM EXCEPTION STATUS    !* {
    cb_emit_accept_exception_status ($1);
  } *!
| <identifier> FROM TIME    !* {
    cb_emit_accept_time ($1);
  } *!
| <identifier> FROM USER NAME   !* {
    cobc_cs_check = 0;
    cb_emit_accept_user_name ($1);
  } *!
| <identifier> FROM COMMAND_LINE    !* {
    cb_emit_accept_command_line ($1);
  } *!
| <identifier> FROM ENVIRONMENT_VALUE <_accept_exception_phrases>   !* {
    cb_emit_accept_environment ($1);
  } *!
| <identifier> FROM ENVIRONMENT <simple_display_value> <_accept_exception_phrases>  !* {
    cb_emit_get_environment ($4, $1);
  } *!
| <identifier> FROM ARGUMENT_NUMBER !* {
    cb_emit_accept_arg_number ($1);
  } *!
| <identifier> FROM ARGUMENT_VALUE <_accept_exception_phrases>  !* {
    cb_emit_accept_arg_value ($1);
  } *!
| <identifier> FROM <mnemonic_name> !* {
    cb_emit_accept_mnemonic ($1, $3);
  } *!
| <identifier> FROM <WORD>    !* {
    cb_emit_accept_name ($1, $3);
  } *!
| <cd_name> <_message> COUNT    !* {
    CB_PENDING ("ACCEPT MESSAGE COUNT");
  } *!


<accp_identifier>
::=  <identifier>
| OMITTED   !* {
    $$ = cb_null;
  } *!


<_accept_clauses>
::=  !* empty *!
| <accept_clauses>


<accept_clauses>
::=  <accept_clause>
| <accept_clauses> <accept_clause>


<accept_clause>
::=  <at_line_column>
| FROM_CRT  !* {
      check_repeated ("FROM CRT", SYN_CLAUSE_2, &check_duplicate);
  } *!
| <mode_is_block>   !* {
      check_repeated ("MODE IS BLOCK", SYN_CLAUSE_3, &check_duplicate);
  } *!
| <_with> <accp_attr>
| <_before> TIME <positive_id_or_lit>   !* {
    check_repeated (_("TIME-OUT or BEFORE TIME clauses"), SYN_CLAUSE_4,
            &check_duplicate);
    set_attribs (NULL, NULL, NULL, $3, NULL, NULL, 0);
  } *!


<lines_or_number>
::=  LINES
| LINE NUMBER


<at_line_column>
::=  <_at> <line_number>    !* {
    set_attr_with_conflict ("LINE", SYN_CLAUSE_1,
                _("AT screen-location"), SYN_CLAUSE_3, 1,
                &check_line_col_duplicate);

    if ((CB_LITERAL_P ($2) && cb_get_int ($2) == 0) || $2 == cb_zero) !* {
        cb_verify (cb_accept_display_extensions, "LINE 0");
    } *!

    if (C_NOT line_column) !* {
        line_column = CB_BUILD_PAIR ($2, cb_int0);
    } *! else !* {
        CB_PAIR_X (line_column) = $2;
    } *!
  } *!
| <_at> <column_number> !* {
    set_attr_with_conflict ("COLUMN", SYN_CLAUSE_2,
                _("AT screen-location"), SYN_CLAUSE_3, 1,
                &check_line_col_duplicate);

    if ((CB_LITERAL_P ($2) && cb_get_int ($2) == 0) || $2 == cb_zero) !* {
        cb_verify (cb_accept_display_extensions, "COLUMN 0");
    } *!

    if (C_NOT line_column) !* {
        line_column = CB_BUILD_PAIR (cb_int0, $2);
    } *! else !* {
        CB_PAIR_Y (line_column) = $2;
    } *!
  } *!
| AT <num_id_or_lit>    !* {
    set_attr_with_conflict (_("AT screen-location"), SYN_CLAUSE_3,
                _("LINE or COLUMN"), SYN_CLAUSE_1 | SYN_CLAUSE_2,
                1, &check_line_col_duplicate);

    cb_verify (cb_accept_display_extensions, "AT clause");

    line_column = $2;
  } *!


<line_number>
::=  LINE <_number> <num_id_or_lit> !* { $$ = $3; } *!


<column_number>
::=  <column_or_col> <_number> <num_id_or_lit>  !* { $$ = $3; } *!
| POSITION <_number> <num_id_or_lit>    !* { $$ = $3; } *!


<mode_is_block>
::=  MODE <_is> BLOCK   !* {
    cobc_cs_check = 0;
  } *!


<accp_attr>
::=  AUTO   !* {
    check_repeated ("AUTO", SYN_CLAUSE_5, &check_duplicate);
    set_dispattr_with_conflict ("AUTO", COB_SCREEN_AUTO,
                    "TAB", COB_SCREEN_TAB);
  } *!
| TAB   !* {
    check_repeated ("TAB", SYN_CLAUSE_6, &check_duplicate);
    set_dispattr_with_conflict ("TAB", COB_SCREEN_TAB,
                    "AUTO", COB_SCREEN_AUTO);
  } *!
| BELL  !* {
    check_repeated ("BELL", SYN_CLAUSE_7, &check_duplicate);
    set_dispattr (COB_SCREEN_BELL);
  } *!
| BLINK !* {
        check_repeated ("BLINK", SYN_CLAUSE_8, &check_duplicate);
    set_dispattr (COB_SCREEN_BLINK);
  } *!
| CONVERSION    !* {
    check_repeated ("CONVERSION", SYN_CLAUSE_9, &check_duplicate);
    CB_PENDING ("ACCEPT CONVERSION");
  } *!
| FULL  !* {
    check_repeated ("FULL", SYN_CLAUSE_10, &check_duplicate);
    set_dispattr (COB_SCREEN_FULL);
  } *!
| HIGHLIGHT !* {
    check_repeated ("HIGHLIGHT", SYN_CLAUSE_11, &check_duplicate);
    set_dispattr_with_conflict ("HIGHLIGHT", COB_SCREEN_HIGHLIGHT,
                    "LOWLIGHT", COB_SCREEN_LOWLIGHT);
  } *!
| LEFTLINE  !* {
    check_repeated ("LEFTLINE", SYN_CLAUSE_12, &check_duplicate);
    set_dispattr (COB_SCREEN_LEFTLINE);
  } *!
| LOWER !* {
    check_repeated ("LOWER", SYN_CLAUSE_13, &check_duplicate);
    set_dispattr_with_conflict ("LOWER", COB_SCREEN_LOWER,
                    "UPPER", COB_SCREEN_UPPER);
  } *!
| LOWLIGHT  !* {
    check_repeated ("LOWLIGHT", SYN_CLAUSE_14, &check_duplicate);
    set_dispattr_with_conflict ("LOWLIGHT", COB_SCREEN_LOWLIGHT,
                    "HIGHLIGHT", COB_SCREEN_HIGHLIGHT);
  } *!
| <no_echo> !* {
    if (cb_no_echo_means_secure) !* {
        check_repeated ("SECURE", SYN_CLAUSE_20, &check_duplicate);
        set_dispattr (COB_SCREEN_SECURE);
    } *! else !* {
        check_repeated ("NO-ECHO", SYN_CLAUSE_15, &check_duplicate);
        set_dispattr_with_conflict ("NO-ECHO", COB_SCREEN_NO_ECHO,
                        "SECURE", COB_SCREEN_SECURE);
    } *!
  } *!
| OVERLINE  !* {
    check_repeated ("OVERLINE", SYN_CLAUSE_16, &check_duplicate);
    set_dispattr (COB_SCREEN_OVERLINE);
  } *!
| PROMPT CHARACTER <_is> <id_or_lit>    !* {
    check_repeated ("PROMPT", SYN_CLAUSE_17, &check_duplicate);
    set_attribs (NULL, NULL, NULL, NULL, $4, NULL, COB_SCREEN_PROMPT);
  } *!
| PROMPT    !* {
    check_repeated ("PROMPT", SYN_CLAUSE_17, &check_duplicate);
    set_dispattr (COB_SCREEN_PROMPT);
  } *!
| REQUIRED  !* {
    check_repeated ("REQUIRED", SYN_CLAUSE_18, &check_duplicate);
    set_dispattr (COB_SCREEN_REQUIRED);
  } *!
| <reverse_video>   !* {
    check_repeated ("REVERSE-VIDEO", SYN_CLAUSE_19, &check_duplicate);
    set_dispattr (COB_SCREEN_REVERSE);
  } *!
| SECURE    !* {
    check_repeated ("SECURE", SYN_CLAUSE_20, &check_duplicate);
    set_dispattr_with_conflict ("SECURE", COB_SCREEN_SECURE,
                    "NO-ECHO", COB_SCREEN_NO_ECHO);
  } *!
| PROTECTED SIZE <_is> <num_id_or_lit>  !* {
    check_repeated ("SIZE", SYN_CLAUSE_21, &check_duplicate);
    set_attribs (NULL, NULL, NULL, NULL, NULL, $4, 0);
  } *!
| SIZE <_is> <num_id_or_lit>    !* {
    check_repeated ("SIZE", SYN_CLAUSE_21, &check_duplicate);
    set_attribs (NULL, NULL, NULL, NULL, NULL, $3, 0);
  } *!
| UNDERLINE !* {
    check_repeated ("UNDERLINE", SYN_CLAUSE_22, &check_duplicate);
    set_dispattr (COB_SCREEN_UNDERLINE);
  } *!
| NO <update_default>   !* {
    check_repeated ("NO UPDATE", SYN_CLAUSE_23, &check_duplicate);
    set_dispattr_with_conflict ("NO UPDATE", COB_SCREEN_NO_UPDATE,
                    "UPDATE", COB_SCREEN_UPDATE);
  } *!
| <update_default>  !* {
    check_repeated ("UPDATE", SYN_CLAUSE_24, &check_duplicate);
    set_dispattr_with_conflict ("UPDATE", COB_SCREEN_UPDATE,
                    "NO UPDATE", COB_SCREEN_NO_UPDATE);
  } *!
| UPPER !* {
    check_repeated ("UPPER", SYN_CLAUSE_25, &check_duplicate);
    set_dispattr_with_conflict ("UPPER", COB_SCREEN_UPPER,
                    "LOWER", COB_SCREEN_LOWER);
  } *!
| FOREGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("FOREGROUND-COLOR", SYN_CLAUSE_26, &check_duplicate);
    set_attribs ($3, NULL, NULL, NULL, NULL, NULL, 0);
  } *!
| BACKGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("BACKGROUND-COLOR", SYN_CLAUSE_27, &check_duplicate);
    set_attribs (NULL, $3, NULL, NULL, NULL, NULL, 0);
  } *!
| SCROLL UP <_scroll_lines> !* {
    check_repeated ("SCROLL UP", SYN_CLAUSE_28, &check_duplicate);
    set_attribs_with_conflict (NULL, NULL, $3, NULL, NULL, NULL,
                   "SCROLL UP", COB_SCREEN_SCROLL_UP,
                   "SCROLL DOWN", COB_SCREEN_SCROLL_DOWN);
  } *!
| SCROLL DOWN <_scroll_lines>   !* {
    check_repeated ("SCROLL DOWN", SYN_CLAUSE_19, &check_duplicate);
    set_attribs_with_conflict (NULL, NULL, $3, NULL, NULL, NULL,
                   "SCROLL DOWN", COB_SCREEN_SCROLL_DOWN,
                   "SCROLL UP", COB_SCREEN_SCROLL_UP);
  } *!
| TIME_OUT <_after> <positive_id_or_lit>    !* {
    check_repeated (_("TIME-OUT or BEFORE TIME clauses"), SYN_CLAUSE_4,
            &check_duplicate);
    set_attribs (NULL, NULL, NULL, $3, NULL, NULL, 0);
  } *!


<no_echo>
::=  NO ECHO
| NO_ECHO
| OFF


<reverse_video>
::=  REVERSE_VIDEO
| REVERSED
| REVERSE


<update_default>
::=  UPDATE
| DEFAULT


<end_accept>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, ACCEPT);
  } *!
| END_ACCEPT    !* {
    TERMINATOR_CLEAR ($-2, ACCEPT);
# if 0 !* activate only for debugging purposes for attribs *!
    if (current_statement->attr_ptr) !* {
        print_bits (current_statement->attr_ptr->dispattrs);
    } *! else !* {
        fprintf(stderr, "No Attribs\n");
    } *!
#endif
  } *!


    !* ADD statement *!

<add_statement>
::=  ADD    !* {
    begin_statement ("ADD", TERM_ADD);
  } *!  <add_body>  <end_add>


<add_body>
::=  <x_list> TO <arithmetic_x_list> <on_size_error_phrases>    !* {
    cb_emit_arithmetic ($3, '+', cb_build_binary_list ($1, '+'));
  } *!
| <x_list> <_add_to> GIVING <arithmetic_x_list> <on_size_error_phrases> !* {
    cb_emit_arithmetic ($4, 0, cb_build_binary_list ($1, '+'));
  } *!
| CORRESPONDING <identifier> TO <identifier> <flag_rounded> <on_size_error_phrases> !* {
    cb_emit_corresponding (cb_build_add, $4, $2, $5);
  } *!
| TABLE <table_identifier> TO <table_identifier> <flag_rounded> <_from_idx_to_idx> <_dest_index> <on_size_error_phrases>    !* {
    CB_PENDING ("ADD TABLE");
    cb_emit_tab_arithmetic (cb_build_add, $4, $2, $5, $6, $7);
  } *!


<_add_to>
::=| TO <x> !* {
    cb_list_add ($0, $2);
  } *!


<end_add>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, ADD);
  } *!
| END_ADD   !* {
    TERMINATOR_CLEAR ($-2, ADD);
  } *!


    !* ALLOCATE statement *!

<allocate_statement>
::=  ALLOCATE   !* {
    begin_statement ("ALLOCATE", 0);
    current_statement->flag_no_based = 1;
  } *!  <allocate_body>


<allocate_body>
::=  <identifier> <flag_initialized> <allocate_returning>   !* {
    cb_emit_allocate ($1, $3, NULL, $2);
  } *!
| <exp> CHARACTERS <flag_initialized_to> <allocate_returning>   !* {
    if ($4 == NULL) !* {
        cb_error_x (CB_TREE (current_statement),
                _("ALLOCATE CHARACTERS requires RETURNING clause"));
    } *! else !* {
        cb_emit_allocate (NULL, $4, $1, $3);
    } *!
  } *!


<allocate_returning>
::=  !* empty *!            !* { $$ = NULL; } *!
| RETURNING <target_x>      !* { $$ = $2; } *!


    !* ALTER statement *!

<alter_statement>
::=  ALTER  !* {
    begin_statement ("ALTER", 0);
    cb_verify (cb_alter_statement, "ALTER");
  } *!  <alter_body>


<alter_body>
::=  <alter_entry>
| <alter_body> <alter_entry>


<alter_entry>
::=  <procedure_name> TO <_proceed_to> <procedure_name> !* {
    cb_emit_alter ($1, $4);
  } *!


<_proceed_to> ::=   | PROCEED TO

    !* CALL statement *!

<call_statement>
::=  CALL   !* {
    begin_statement ("CALL", TERM_CALL);
    cobc_cs_check = CB_CS_CALL;
    call_nothing = 0;
    cobc_allow_program_name = 1;
  } *!  <call_body>  <end_call>


<call_body>
::=  <_mnemonic_conv> <program_or_prototype>    !* {
    cobc_allow_program_name = 0;
  } *!  <call_using>  <call_returning>  <call_exception_phrases>    !* {
    int call_conv = 0;

    if (current_program->prog_type == CB_PROGRAM_TYPE
        && C_NOT current_program->flag_recursive
        && is_recursive_call ($2)) !* {
        cb_warning_x ($2, _("recursive program call - assuming RECURSIVE attribute"));
        current_program->flag_recursive = 1;
    } *!
    call_conv = current_call_convention;
    if ($1 && CB_INTEGER_P ($1)) !* {
        call_conv |= CB_INTEGER ($1)->val;
        if (CB_INTEGER ($1)->val & CB_CONV_COBOL) !* {
            call_conv &= ~CB_CONV_STDCALL;
        } *! else !* {
            call_conv &= ~CB_CONV_COBOL;
        } *!
    } *!    !* For CALL ... RETURNING NOTHING, set the call convention bit *!
    if (call_nothing) !* {
        call_conv |= CB_CONV_NO_RET_UPD;
    } *!
    cb_emit_call ($2, $4, $5, CB_PAIR_X ($6), CB_PAIR_Y ($6),
              cb_int (call_conv));
  } *!


<_mnemonic_conv>
::=  !* empty *!    !* {
    $$ = NULL;
    cobc_cs_check = 0;
  } *!
| STATIC    !* not active for ENTRY-CONVENTION via PROCEDURE DIVISION *!    !* {
    if (current_call_convention & CB_CONV_COBOL) !* {
        $$ = cb_int (CB_CONV_STATIC_LINK | CB_CONV_COBOL);
    } *! else !* {
        $$ = cb_int (CB_CONV_STATIC_LINK);
    } *!
    cobc_cs_check = 0;
  } *!
| STDCALL   !* not active for ENTRY-CONVENTION via PROCEDURE DIVISION *!    !* {
    $$ = cb_int (CB_CONV_STDCALL);
    cobc_cs_check = 0;
  } *!
| TOK_EXTERN    !* not active for ENTRY-CONVENTION via PROCEDURE DIVISION *!    !* {
    $$ = cb_int (0);
    cobc_cs_check = 0;
  } *!
| <MNEMONIC_NAME_TOK> !* {
    cb_tree     x;

    x = cb_ref ($1);
    if (CB_VALID_TREE (x)) !* {
        if (CB_SYSTEM_NAME(x)->token <> CB_FEATURE_CONVENTION) !* {
            cb_error_x ($1, _("invalid mnemonic name"));
            $$ = NULL;
        } *! else !* {
            $$ = CB_SYSTEM_NAME(x)->value;
        } *!
    } *! else !* {
        $$ = NULL;
    } *!
    cobc_cs_check = 0;
  } *!


<program_or_prototype>
::=  <id_or_lit_or_func>    !* {
    if (CB_LITERAL_P ($1)) !* {
        cb_trim_program_id ($1);
    } *!
  } *!
| <id_or_lit_or_func_as> <PROGRAM_NAME> !* !NOTE: not optional in GOLD-Grammar as <WORD> in <id_or_lit_or_func> is identical to <PROGRAM_NAME> {
    cb_verify (cb_program_prototypes, _("CALL/CANCEL with program-prototype-name"));    !* hack to push the prototype name *!
    if ($1) !* {
        cb_warning_x ($1, _("id/literal ignored, using prototype name"));
    } *!
    $$ = $2;
  } *!
| <LITERAL_TOK> AS NESTED !* {
    CB_PENDING ("NESTED phrase for CALL statement");
    $$ = $1;
  } *!


<id_or_lit_or_func_as>
::=  <id_or_lit_or_func> AS   !* {
    if (CB_LITERAL_P ($1)) !* {
        cb_trim_program_id ($1);
    } *!
    $$ = $1;
  } *!


<call_using>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| USING !* {
    call_mode = CB_CALL_BY_REFERENCE;
    size_mode = CB_SIZE_4;
  } *!  <call_param_list>   !* {
    if (cb_list_length ($3) > MAX_CALL_FIELD_PARAMS) !* {
        cb_error_x (CB_TREE (current_statement),
                _("number of parameters exceeds maximum %d"),
                MAX_CALL_FIELD_PARAMS);
    } *!
    $$ = $3;
  } *!


<call_param_list>
::=  <call_param>           !* { $$ = $1; } *!
| <call_param_list>  <call_param>           !* { $$ = cb_list_append ($1, $2); } *!


<call_param>
::=  <call_type> OMITTED    !* {
    if (call_mode <> CB_CALL_BY_REFERENCE) !* {
        cb_error_x (CB_TREE (current_statement),
                _("OMITTED only allowed when parameters are passed BY REFERENCE"));
    } *!
    $$ = CB_BUILD_PAIR (cb_int (call_mode), cb_null);
  } *!
| <call_type> <_size_optional> <call_x> !* {
    int save_mode;

    save_mode = call_mode;
    if (call_mode <> CB_CALL_BY_REFERENCE) !* {
        if (CB_FILE_P ($3) || (CB_REFERENCE_P ($3) &&
            CB_FILE_P (CB_REFERENCE ($3)->value))) !* {
            cb_error_x (CB_TREE (current_statement),
                    _("invalid file name reference"));
        } *! else if (call_mode == CB_CALL_BY_VALUE) !* {
            if (cb_category_is_alpha ($3)) !* {
                cb_warning_x ($3,
                          _("BY CONTENT assumed for alphanumeric item"));
                save_mode = CB_CALL_BY_CONTENT;
            } *!
        } *!
    } *!
    $$ = CB_BUILD_PAIR (cb_int (save_mode), $3);
    CB_SIZES ($$) = size_mode;
    call_mode = save_mode;
  } *!
| COMMA_DELIM !* HACK, should not reach parser *!


<call_type>
::=  !* empty *!
| <_by> REFERENCE   !* {
    call_mode = CB_CALL_BY_REFERENCE;
  } *!
| <_by> CONTENT !* {
    if (current_program->flag_chained) !* {
        cb_error_x (CB_TREE (current_statement),
                _("%s not allowed in CHAINED programs"), "BY CONTENT");
    } *! else !* {
        call_mode = CB_CALL_BY_CONTENT;
    } *!
  } *!
| <_by> VALUE   !* {
    if (current_program->flag_chained) !* {
        cb_error_x (CB_TREE (current_statement),
                _("%s not allowed in CHAINED programs"), "BY VALUE");
    } *! else !* {
        call_mode = CB_CALL_BY_VALUE;
    } *!
  } *!


<call_returning>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <return_give> <_into> <identifier>    !* {
    $$ = $3;
  } *!
| <return_give> <null_or_omitted>   !* {
    $$ = cb_null;
  } *!
| <return_give> NOTHING !* {
    call_nothing = CB_CONV_NO_RET_UPD;
    $$ = cb_null;
  } *!
| <return_give> ADDRESS <_of> <identifier>  !* {
    struct cb_field *f;

    if (cb_ref ($4) <> cb_error_node) !* {
        f = CB_FIELD_PTR ($4);
        if (f->level <> 1 && f->level <> 77) !* {
            cb_error (_("RETURNING item must have level 01 or 77"));
            $$ = NULL;
        } *! else if (f->storage <> CB_STORAGE_LINKAGE &&
               C_NOT f->flag_item_based) !* {
            cb_error (_("RETURNING item must be a LINKAGE SECTION item or have BASED clause"));
            $$ = NULL;
        } *! else !* {
            $$ = cb_build_address ($4);
        } *!
    } *! else !* {
        $$ = NULL;
    } *!
  } *!


<return_give>
::=  RETURNING
| GIVING


<null_or_omitted>
::=  TOK_NULL
| OMITTED


<call_exception_phrases>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = CB_BUILD_PAIR (NULL, NULL);
  } *!
| <call_on_exception> <_call_not_on_exception>  !* {
    $$ = CB_BUILD_PAIR ($1, $2);
  } *!
| <call_not_on_exception> <_call_on_exception>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT EXCEPTION before EXCEPTION"));
    } *!
    $$ = CB_BUILD_PAIR ($2, $1);
  } *!


<_call_on_exception>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <call_on_exception>   !* {
    $$ = $1;
  } *!


<call_on_exception>
::=  EXCEPTION <statement_list> !* {
    $$ = $2;
  } *!
| TOK_OVERFLOW <statement_list> !* {
    cb_verify (cb_call_overflow, "ON OVERFLOW");
    $$ = $2;
  } *!


<_call_not_on_exception>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <call_not_on_exception>   !* {
    $$ = $1;
  } *!


<call_not_on_exception>
::=  NOT_EXCEPTION <statement_list> !* {
    $$ = $2;
  } *!


<end_call>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, CALL);
  } *!
| END_CALL  !* {
    TERMINATOR_CLEAR ($-2, CALL);
  } *!


    !* CANCEL statement *!

<cancel_statement>
::=  CANCEL !* {
    begin_statement ("CANCEL", 0);
    cobc_allow_program_name = 1;
  } *!  <cancel_body>   !* {
    cobc_allow_program_name = 0;
  } *!


<cancel_body>
::=  <id_or_lit_or_program_name>    !* {
    cb_emit_cancel ($1);
  } *!
| <cancel_body> <id_or_lit_or_program_name> !* {
    cb_emit_cancel ($2);
  } *!


<id_or_lit_or_program_name>
::=  <id_or_lit>
! FIXME: removed as the general rules are identical for <WORD> (part of <id_or_lit>) and <PROGRAM_NAME>
!        the only option to fix this is to preprocess the context and return an internal token <PROGRAM_NAME>
!        instead of the actual COBOLWord
!| <PROGRAM_NAME>
!* {
    cb_verify (cb_program_prototypes, _("CALL/CANCEL with program-prototype-name"));
  }
*!

    !* CLOSE statement *!

<close_statement>
::=  CLOSE  !* {
    begin_statement ("CLOSE", 0);
  } *!  <close_body>


<close_body>
::=  <file_name> <close_option> !* {
    begin_implicit_statement ();
    cb_emit_close ($1, $2);
  } *!
| <close_body> <file_name> <close_option>   !* {
    begin_implicit_statement ();
    cb_emit_close ($2, $3);
  } *!


<close_option>
::=  !* empty *!            !* { $$ = cb_int (COB_CLOSE_NORMAL); } *!
| <reel_or_unit>            !* { $$ = cb_int (COB_CLOSE_UNIT); } *!
| <reel_or_unit> <_for> REMOVAL !* { $$ = cb_int (COB_CLOSE_UNIT_REMOVAL); } *!
| <_with> NO REWIND     !* { $$ = cb_int (COB_CLOSE_NO_REWIND); } *!
| <_with> LOCK          !* { $$ = cb_int (COB_CLOSE_LOCK); } *!


    !* COMPUTE statement *!

<compute_statement>
::=  COMPUTE    !* {
    begin_statement ("COMPUTE", TERM_COMPUTE);
  } *!  <compute_body>  <end_compute>


<compute_body>
::=  <arithmetic_x_list> <comp_equal> <exp> <on_size_error_phrases> !* {
    cb_emit_arithmetic ($1, 0, $3);
  } *!


<end_compute>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, COMPUTE);
  } *!
| END_COMPUTE   !* {
    TERMINATOR_CLEAR ($-2, COMPUTE);
  } *!


    !* COMMIT statement *!

<commit_statement>
::=  COMMIT !* {
    begin_statement ("COMMIT", 0);
    cb_emit_commit ();
  } *!


    !* CONTINUE statement *!

<continue_statement>
::=  CONTINUE   !* {
    size_t  save_unreached;
    !* Do not check unreached for CONTINUE *!
    save_unreached = check_unreached;
    check_unreached = 0;
    begin_statement ("CONTINUE", 0);
    cb_emit_continue ();
    check_unreached = (unsigned int) save_unreached;
  } *!


    !* DELETE statement *!

<delete_statement>
::=  DELETE !* {
    begin_statement ("DELETE", TERM_DELETE);
  } *!  <delete_body>  <end_delete>


<delete_body>
::=  <file_name> <_record> <_retry_phrase> <_invalid_key_phrases>   !* {
    cb_emit_delete ($1);
  } *!
| TOK_FILE <delete_file_list>


<delete_file_list>
::=  <file_name>    !* {
    begin_implicit_statement ();
    cb_emit_delete_file ($1);
  } *!
| <delete_file_list> <file_name>    !* {
    begin_implicit_statement ();
    cb_emit_delete_file ($2);
  } *!


<end_delete>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, DELETE);
  } *!
| END_DELETE    !* {
    TERMINATOR_CLEAR ($-2, DELETE);
  } *!


    !* DISABLE statement (COMMUNICATION) *!

<disable_statement>
::=  DISABLE    !* {
    begin_statement ("DISABLE", 0);
  } *!  <enable_disable_handling>



<enable_disable_handling>
::=  <communication_mode> <cd_name> <_enable_disable_key>


<_enable_disable_key>
::=  !* empty *!
| <_with> KEY <id_or_lit>   !* {    !* Add cb_verify for <= COBOL-85 *!
  } *!


<communication_mode>
::=   !* empty *! !* RM-COBOL extension *!
| INPUT <_terminal>
| OUTPUT
| I_O TERMINAL
| TERMINAL !* RM-COBOL extension *!


    !* DISPLAY statement *!

<display_statement>
::=  DISPLAY    !* {
    begin_statement ("DISPLAY", TERM_DISPLAY);
    cobc_cs_check = CB_CS_DISPLAY;
    display_type = UNKNOWN_DISPLAY;
    is_first_display_item = 1;
  } *!  <display_body>  <end_display>


<display_body>
::=  <id_or_lit> UPON_ENVIRONMENT_NAME <_display_exception_phrases> !* {
    cb_emit_env_name ($1);
  } *!
| <id_or_lit> UPON_ENVIRONMENT_VALUE <_display_exception_phrases>   !* {
    cb_emit_env_value ($1);
  } *!
| <id_or_lit> UPON_ARGUMENT_NUMBER <_display_exception_phrases> !* {
    cb_emit_arg_number ($1);
  } *!
| <id_or_lit> UPON_COMMAND_LINE <_display_exception_phrases>    !* {
    cb_emit_command_line ($1);
  } *!
| <screen_or_device_display> <_display_exception_phrases>


<screen_or_device_display>
::=  <display_list> <_x_list>   !* {
    if ($2 <> NULL) !* {
        error_if_different_display_type ($2, NULL, NULL, NULL);
        cb_emit_display ($2, NULL, cb_int1, NULL, NULL, 0,
                 display_type);
    } *!
  } *!
| <x_list>  !* {
    set_display_type ($1, NULL, NULL, NULL);
    cb_emit_display ($1, NULL, cb_int1, NULL, NULL, 1,
             display_type);
  } *!


<display_list>
::=  <display_atom>
| <display_list> <display_atom>


<display_atom>
::=  <disp_list>    !* {
    check_duplicate = 0;
    check_line_col_duplicate = 0;
    advancing_value = cb_int1;
    upon_value = NULL;
    line_column = NULL;
  } *!  <display_clauses>   !* {
    if ($1 == cb_null) !* { !* Emit DISPLAY OMITTED. *!
        CB_UNFINISHED ("DISPLAY OMITTED");
        error_if_no_advancing_in_screen_display (advancing_value);
        $1 = cb_low;
    } *!
    !* Emit device or screen DISPLAY. *!
    !*
      Check that disp_list does not contain an invalid mix of fields.
    *!
    if (display_type == UNKNOWN_DISPLAY) !* {
        set_display_type ($1, upon_value, line_column,
                  current_statement->attr_ptr);
    } *! else !* {
        error_if_different_display_type ($1, upon_value,
                         line_column,
                         current_statement->attr_ptr);
    } *!

    if (display_type == SCREEN_DISPLAY
        || display_type == FIELD_ON_SCREEN_DISPLAY) !* {
        error_if_no_advancing_in_screen_display (advancing_value);
    } *!

    cb_emit_display ($1, upon_value, advancing_value, line_column,
             current_statement->attr_ptr,
             is_first_display_item, display_type);

    is_first_display_item = 0;
  } *!


<disp_list>
::=  <x_list>   !* {
    $$ = $1;
  } *!
| OMITTED   !* {
    CB_PENDING ("DISPLAY OMITTED");
    $$ = cb_null;
  } *!


<display_clauses>
::=  <display_clause>
| <display_clauses> <display_clause>


<display_clause>
::=  <display_upon> !* {
    check_repeated ("UPON", SYN_CLAUSE_1, &check_duplicate);
  } *!
| <_with> NO_ADVANCING  !* {
    check_repeated ("NO ADVANCING", SYN_CLAUSE_2, &check_duplicate);
    advancing_value = cb_int0;
  } *!
| <mode_is_block>   !* {
    check_repeated ("MODE IS BLOCK", SYN_CLAUSE_3, &check_duplicate);
  } *!
| <at_line_column>
| <_with> <disp_attr>


<display_upon>
::=  UPON <mnemonic_name>   !* {
    upon_value = cb_build_display_mnemonic ($2);
  } *!
| UPON <WORD> !* {
    upon_value = cb_build_display_name ($2);
  } *!
| UPON PRINTER  !* {
    upon_value = cb_int0;
  } *!
| UPON <crt_under>  !* {
    upon_value = cb_null;
  } *!


<crt_under>
::=  CRT
| CRT_UNDER


<disp_attr>
::=  BELL   !* {
    check_repeated ("BELL", SYN_CLAUSE_4, &check_duplicate);
    set_dispattr (COB_SCREEN_BELL);
  } *!
| BLANK LINE    !* {
    check_repeated ("BLANK LINE", SYN_CLAUSE_5, &check_duplicate);
    set_dispattr_with_conflict ("BLANK LINE", COB_SCREEN_BLANK_LINE,
                    "BLANK SCREEN", COB_SCREEN_BLANK_SCREEN);
  } *!
| BLANK SCREEN  !* {
    check_repeated ("BLANK SCREEN", SYN_CLAUSE_6, &check_duplicate);
    set_dispattr_with_conflict ("BLANK SCREEN", COB_SCREEN_BLANK_SCREEN,
                    "BLANK LINE", COB_SCREEN_BLANK_LINE);
  } *!
| BLINK !* {
    check_repeated ("BLINK", SYN_CLAUSE_7, &check_duplicate);
    set_dispattr (COB_SCREEN_BLINK);
  } *!
| CONVERSION    !* {
    check_repeated ("CONVERSION", SYN_CLAUSE_8, &check_duplicate);
    cb_warning (_("ignoring CONVERSION"));
  } *!
| ERASE <eol>   !* {
    check_repeated ("ERASE EOL", SYN_CLAUSE_9, &check_duplicate);
    set_dispattr_with_conflict ("ERASE EOL", COB_SCREEN_ERASE_EOL,
                    "ERASE EOS", COB_SCREEN_ERASE_EOS);
  } *!
| ERASE <eos>   !* {
    check_repeated ("ERASE EOS", SYN_CLAUSE_10, &check_duplicate);
    set_dispattr_with_conflict ("ERASE EOS", COB_SCREEN_ERASE_EOS,
                    "ERASE EOL", COB_SCREEN_ERASE_EOL);
  } *!
| HIGHLIGHT !* {
    check_repeated ("HIGHLIGHT", SYN_CLAUSE_11, &check_duplicate);
    set_dispattr_with_conflict ("HIGHLIGHT", COB_SCREEN_HIGHLIGHT,
                    "LOWLIGHT", COB_SCREEN_LOWLIGHT);
  } *!
| LOWLIGHT  !* {
    check_repeated ("LOWLIGHT", SYN_CLAUSE_12, &check_duplicate);
    set_dispattr_with_conflict ("LOWLIGHT", COB_SCREEN_LOWLIGHT,
                    "HIGHLIGHT", COB_SCREEN_HIGHLIGHT);
  } *!
| OVERLINE  !* {
    check_repeated ("OVERLINE", SYN_CLAUSE_13, &check_duplicate);
    set_dispattr (COB_SCREEN_OVERLINE);
  } *!
| <reverse_video>   !* {
    check_repeated ("REVERSE-VIDEO", SYN_CLAUSE_14, &check_duplicate);
    set_dispattr (COB_SCREEN_REVERSE);
  } *!
| SIZE <_is> <num_id_or_lit>    !* {
    check_repeated ("SIZE", SYN_CLAUSE_15, &check_duplicate);
    set_attribs (NULL, NULL, NULL, NULL, NULL, $3, 0);
  } *!
| UNDERLINE !* {
    check_repeated ("UNDERLINE", SYN_CLAUSE_16, &check_duplicate);
    set_dispattr (COB_SCREEN_UNDERLINE);
  } *!
| FOREGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("FOREGROUND-COLOR", SYN_CLAUSE_17, &check_duplicate);
    set_attribs ($3, NULL, NULL, NULL, NULL, NULL, 0);
  } *!
| BACKGROUND_COLOR <_is> <num_id_or_lit>    !* {
    check_repeated ("BACKGROUND-COLOR", SYN_CLAUSE_18, &check_duplicate);
    set_attribs (NULL, $3, NULL, NULL, NULL, NULL, 0);
  } *!
| SCROLL UP <_scroll_lines> !* {
    check_repeated ("SCROLL UP", SYN_CLAUSE_19, &check_duplicate);
    set_attribs_with_conflict (NULL, NULL, $3, NULL, NULL, NULL,
                   "SCROLL UP", COB_SCREEN_SCROLL_UP,
                   "SCROLL DOWN", COB_SCREEN_SCROLL_DOWN);
  } *!
| SCROLL DOWN <_scroll_lines>   !* {
    check_repeated ("SCROLL DOWN", SYN_CLAUSE_20, &check_duplicate);
    set_attribs_with_conflict (NULL, NULL, $3, NULL, NULL, NULL,
                   "SCROLL DOWN", COB_SCREEN_SCROLL_DOWN,
                   "SCROLL UP", COB_SCREEN_SCROLL_UP);
  } *!


<end_display>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, DISPLAY);
  } *!
| END_DISPLAY   !* {
    TERMINATOR_CLEAR ($-2, DISPLAY);
  } *!


    !* DIVIDE statement *!

<divide_statement>
::=  DIVIDE !* {
    begin_statement ("DIVIDE", TERM_DIVIDE);
  } *!  <divide_body>  <end_divide>


<divide_body>
::=  <x> INTO <arithmetic_x_list> <on_size_error_phrases>   !* {
    cb_emit_arithmetic ($3, '/', $1);
  } *!
| <x> INTO <x> GIVING <arithmetic_x_list> <on_size_error_phrases>   !* {
    cb_emit_arithmetic ($5, 0, cb_build_binary_op ($3, '/', $1));
  } *!
| <x> BY <x> GIVING <arithmetic_x_list> <on_size_error_phrases> !* {
    cb_emit_arithmetic ($5, 0, cb_build_binary_op ($1, '/', $3));
  } *!
| <x> INTO <x> GIVING <arithmetic_x> REMAINDER <arithmetic_x> <on_size_error_phrases>   !* {
    cb_emit_divide ($3, $1, $5, $7);
  } *!
| <x> BY <x> GIVING <arithmetic_x> REMAINDER <arithmetic_x> <on_size_error_phrases> !* {
    cb_emit_divide ($1, $3, $5, $7);
  } *!


<end_divide>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, DIVIDE);
  } *!
| END_DIVIDE    !* {
    TERMINATOR_CLEAR ($-2, DIVIDE);
  } *!


    !* ENABLE statement (COMMUNICATION) *!

<enable_statement>
::=  ENABLE !* {
    begin_statement ("ENABLE", 0);
  } *!  <enable_disable_handling>


    !* ENTRY statement *!

<entry_statement>
::=  ENTRY  !* {
    check_unreached = 0;
    begin_statement ("ENTRY", 0);
  } *!  <entry_body>


<entry_body>
::=  <_mnemonic_conv> <LITERAL_TOK> <call_using>  !* {
    if (current_program->nested_level) !* {
        cb_error (_("%s is invalid in nested program"), "ENTRY");
    } *! else if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("%s is invalid in a user FUNCTION"), "ENTRY");
    } *! else if (cb_verify (cb_entry_statement, "ENTRY")) !* {
        if (C_NOT cobc_check_valid_name ((char *)(CB_LITERAL ($2)->data), ENTRY_NAME)) !* {
            emit_entry ((char *)(CB_LITERAL ($2)->data), 1, $3, $1);
        } *!
    } *!
  } *!


    !* EVALUATE statement *!

<evaluate_statement>
::=  EVALUATE   !* {
    begin_statement ("EVALUATE", TERM_EVALUATE);
    eval_level++;
    if (eval_level >= EVAL_DEPTH) !* {
        cb_error (_("maximum evaluate depth exceeded (%d)"),
              EVAL_DEPTH);
        eval_level = 0;
        eval_inc = 0;
        eval_inc2 = 0;
        YYERROR;
    } *! else !* {
        for (eval_inc = 0; eval_inc < EVAL_DEPTH; ++eval_inc) !* {
            eval_check[eval_level][eval_inc] = NULL;
        } *!
        eval_inc = 0;
        eval_inc2 = 0;
    } *!
  } *!  <evaluate_body>  <end_evaluate>


<evaluate_body>
::=  <evaluate_subject_list> <evaluate_condition_list>  !* {
    cb_emit_evaluate ($1, $2);
    eval_level--;
  } *!


<evaluate_subject_list>
::=  <evaluate_subject>     !* { $$ = CB_LIST_INIT ($1); } *!
| <evaluate_subject_list> ALSO  <evaluate_subject>      !* { $$ = cb_list_add ($1, $3); } *!


<evaluate_subject>
::=  <expr> !* {
    $$ = $1;
    eval_check[eval_level][eval_inc++] = $1;
    if (eval_inc >= EVAL_DEPTH) !* {
        cb_error (_("maximum evaluate depth exceeded (%d)"),
              EVAL_DEPTH);
        eval_inc = 0;
        YYERROR;
    } *!
  } *!
| TOK_TRUE  !* {
    $$ = cb_true;
    eval_check[eval_level][eval_inc++] = NULL;
    if (eval_inc >= EVAL_DEPTH) !* {
        cb_error (_("maximum evaluate depth exceeded (%d)"),
              EVAL_DEPTH);
        eval_inc = 0;
        YYERROR;
    } *!
  } *!
| TOK_FALSE !* {
    $$ = cb_false;
    eval_check[eval_level][eval_inc++] = NULL;
    if (eval_inc >= EVAL_DEPTH) !* {
        cb_error (_("maximum evaluate depth exceeded (%d)"),
              EVAL_DEPTH);
        eval_inc = 0;
        YYERROR;
    } *!
  } *!


<evaluate_condition_list>
::=  <evaluate_case_list> <evaluate_other>  !* {
    $$ = cb_list_add ($1, $2);
  } *!
| <evaluate_case_list>  !* %prec SHIFT_PREFER *!    !* {
    $$ = $1;
  } *!


<evaluate_case_list>
::=  <evaluate_case>            !* { $$ = CB_LIST_INIT ($1); } *!
| <evaluate_case_list>  <evaluate_case>         !* { $$ = cb_list_add ($1, $2); } *!


<evaluate_case>
::=  <evaluate_when_list>  <statement_list> !* {
    $$ = CB_BUILD_CHAIN ($2, $1);
    eval_inc2 = 0;
  } *!


<evaluate_other>
::=  WHEN OTHER  <statement_list>   !* {
    $$ = CB_BUILD_CHAIN ($3, NULL);
    eval_inc2 = 0;
  } *!


<evaluate_when_list>
::=  WHEN <evaluate_object_list>    !* {
    $$ = CB_LIST_INIT ($2);
    eval_inc2 = 0;
  } *!
| <evaluate_when_list>  WHEN <evaluate_object_list> !* {
    $$ = cb_list_add ($1, $3);
    eval_inc2 = 0;
  } *!


<evaluate_object_list>
::=  <evaluate_object>      !* { $$ = CB_LIST_INIT ($1); } *!
| <evaluate_object_list> ALSO  <evaluate_object>        !* { $$ = cb_list_add ($1, $3); } *!


<evaluate_object>
::=  <partial_expr> <_evaluate_thru_expr>   !* {
    cb_tree not0;
    cb_tree e1;
    cb_tree e2;
    cb_tree x;
    cb_tree parm1;

    not0 = cb_int0;
    e2 = $2;
    x = NULL;
    parm1 = $1;
    if (eval_check[eval_level][eval_inc2]) !* { !* Check if the first token is NOT *!   !* It may belong to the EVALUATE, however see *!    !* below when it may be part of a partial expression *!
        if (CB_PURPOSE_INT (parm1) == C_EXCL_LIT) !* {  !* Pop stack if subject not TRUE / FALSE *!
            not0 = cb_int1;
            x = parm1;
            parm1 = CB_CHAIN (parm1);
        } *!    !* Partial expression handling *!
        switch (CB_PURPOSE_INT (parm1)) !* {    !* Relational conditions *!
        case '<':
        case '>':
        case '[':
        case ']':
        case '~':
        case '=':   !* Class conditions *!
        case '9':
        case 'A':
        case 'L':
        case 'U':
        case 'P':
        case 'N':
        case 'O':
        case 'C':
            if (e2) !* {
                cb_error_x (e2, _("invalid THROUGH usage"));
                e2 = NULL;
            } *!
            not0 = CB_PURPOSE (parm1);
            if (x) !* { !* Rebind the NOT to the partial expression *!
                parm1 = cb_build_list (cb_int (C_EXCL_LIT), NULL, parm1);
            } *!    !* Insert subject at head of list *!
            parm1 = cb_build_list (cb_int ('x'),
                        eval_check[eval_level][eval_inc2], parm1);
            break;
        } *!
    } *!
    !* Build expr now *!
    e1 = cb_build_expr (parm1);

    eval_inc2++;
    $$ = CB_BUILD_PAIR (not0, CB_BUILD_PAIR (e1, e2));
  } *!
| ANY               !* { $$ = cb_any; eval_inc2++; } *!
| TOK_TRUE          !* { $$ = cb_true; eval_inc2++; } *!
| TOK_FALSE         !* { $$ = cb_false; eval_inc2++; } *!


<_evaluate_thru_expr>
::=  !* empty *!            !* { $$ = NULL; } *!
| THRU <expr>           !* { $$ = $2; } *!


<end_evaluate>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, EVALUATE);
  } *!
| END_EVALUATE  !* {
    TERMINATOR_CLEAR ($-2, EVALUATE);
  } *!


    !* EXIT statement *!

<exit_statement>
::=  EXIT   !* {
    begin_statement ("EXIT", 0);
    cobc_cs_check = CB_CS_EXIT;
  } *!  <exit_body> !* {
    cobc_cs_check = 0;
  } *!


<exit_body>
::=  !* empty *!    !* %prec SHIFT_PREFER *!
| PROGRAM <exit_program_returning>  !* {
    if (in_declaratives && use_global_ind) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT PROGRAM is not allowed within a USE GLOBAL procedure"));
    } *!
    if (current_program->prog_type <> CB_PROGRAM_TYPE) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT PROGRAM not allowed within a FUNCTION"));
    } *!
    if (current_program->flag_main) !* {
        check_unreached = 0;
    } *! else !* {
        check_unreached = 1;
    } *!
    if ($2 <> NULL) !* {
        cb_emit_move ($2, CB_LIST_INIT (current_program->cb_return_code));
    } *!
    current_statement->name = (const char *)"EXIT PROGRAM";
    cb_emit_exit (0);
  } *!
| FUNCTION  !* {
    if (in_declaratives && use_global_ind) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT FUNCTION is not allowed within a USE GLOBAL procedure"));
    } *!
    if (current_program->prog_type <> CB_FUNCTION_TYPE) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT FUNCTION only allowed within a FUNCTION"));
    } *!
    check_unreached = 1;
    current_statement->name = (const char *)"EXIT FUNCTION";
    cb_emit_exit (0);
  } *!
| PERFORM CYCLE !* {
    struct cb_perform   *p;
    cb_tree         plabel;
    char            name[64];

    if (C_NOT perform_stack) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT PERFORM is only valid with inline PERFORM"));
    } *! else if (CB_VALUE (perform_stack) <> cb_error_node) !* {
        p = CB_PERFORM (CB_VALUE (perform_stack));
        if (C_NOT p->cycle_label) !* {
            sprintf (name, "EXIT PERFORM CYCLE %d", cb_id);
            p->cycle_label = cb_build_reference (name);
            plabel = cb_build_label (p->cycle_label, NULL);
            CB_LABEL (plabel)->flag_begin = 1;
            CB_LABEL (plabel)->flag_dummy_exit = 1;
        } *!
        current_statement->name = (const char *)"EXIT PERFORM CYCLE";
        cb_emit_goto (CB_LIST_INIT (p->cycle_label), NULL);
    } *!
  } *!
| PERFORM   !* {
    struct cb_perform   *p;
    cb_tree         plabel;
    char            name[64];

    if (C_NOT perform_stack) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT PERFORM is only valid with inline PERFORM"));
    } *! else if (CB_VALUE (perform_stack) <> cb_error_node) !* {
        p = CB_PERFORM (CB_VALUE (perform_stack));
        if (C_NOT p->exit_label) !* {
            sprintf (name, "EXIT PERFORM %d", cb_id);
            p->exit_label = cb_build_reference (name);
            plabel = cb_build_label (p->exit_label, NULL);
            CB_LABEL (plabel)->flag_begin = 1;
            CB_LABEL (plabel)->flag_dummy_exit = 1;
        } *!
        current_statement->name = (const char *)"EXIT PERFORM";
        cb_emit_goto (CB_LIST_INIT (p->exit_label), NULL);
    } *!
  } *!
| SECTION   !* {
    cb_tree plabel;
    char    name[64];

    if (C_NOT current_section) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT SECTION is only valid with an active SECTION"));
    } *! else !* {
        if (C_NOT current_section->exit_label) !* {
            sprintf (name, "EXIT SECTION %d", cb_id);
            current_section->exit_label = cb_build_reference (name);
            plabel = cb_build_label (current_section->exit_label, NULL);
            CB_LABEL (plabel)->flag_begin = 1;
            CB_LABEL (plabel)->flag_dummy_exit = 1;
        } *!
        current_statement->name = (const char *)"EXIT SECTION";
        cb_emit_goto (CB_LIST_INIT (current_section->exit_label), NULL);
    } *!
  } *!
| PARAGRAPH !* {
    cb_tree plabel;
    char    name[64];

    if (C_NOT current_paragraph) !* {
        cb_error_x (CB_TREE (current_statement),
                _("EXIT PARAGRAPH is only valid with an active PARAGRAPH"));
    } *! else !* {
        if (C_NOT current_paragraph->exit_label) !* {
            sprintf (name, "EXIT PARAGRAPH %d", cb_id);
            current_paragraph->exit_label = cb_build_reference (name);
            plabel = cb_build_label (current_paragraph->exit_label, NULL);
            CB_LABEL (plabel)->flag_begin = 1;
            CB_LABEL (plabel)->flag_dummy_exit = 1;
        } *!
        current_statement->name = (const char *)"EXIT PARAGRAPH";
        cb_emit_goto (CB_LIST_INIT (current_paragraph->exit_label), NULL);
    } *!
  } *!


<exit_program_returning>
::=  !* empty *!            !* { $$ = NULL; } *!
| <return_give> <x>     !* { $$ = $2; } *!


    !* FREE statement *!

<free_statement>
::=  FREE   !* {
    begin_statement ("FREE", 0);
    current_statement->flag_no_based = 1;
  } *!  <free_body>


<free_body>
::=  <target_x_list>    !* {
    cb_emit_free ($1);
  } *!


    !* GENERATE statement *!

<generate_statement>
::=  GENERATE   !* {
    begin_statement ("GENERATE", 0);
    CB_PENDING("GENERATE");
  } *!  <generate_body>



<generate_body>
::=  <qualified_word>

    !* GO TO statement *!

<goto_statement>
::=  GO !* {
    if (C_NOT current_paragraph->flag_statement) !* {
        current_paragraph->flag_first_is_goto = 1;
    } *!
    begin_statement ("GO TO", 0);
    save_debug = start_debug;
    start_debug = 0;
  } *!  <go_body>


<go_body>
::=  <_to> <procedure_name_list> <goto_depending>   !* {
    cb_emit_goto ($2, $3);
    start_debug = save_debug;
  } *!


<goto_depending>
::=  !* empty *!    !* {
    check_unreached = 1;
    $$ = NULL;
  } *!
| DEPENDING <_on> <identifier>  !* {
    check_unreached = 0;
    $$ = $3;
  } *!


    !* GOBACK statement *!

<goback_statement>
::=  GOBACK <exit_program_returning>    !* {
    begin_statement ("GOBACK", 0);
    check_unreached = 1;
    if ($2 <> NULL) !* {
        cb_emit_move ($2, CB_LIST_INIT (current_program->cb_return_code));
    } *!
    cb_emit_exit (1U);
  } *!


    !* IF statement *!

<if_statement>
::=  IF !* {
    begin_statement ("IF", TERM_IF);
  } *!  <condition> <_then> <if_else_statements>  <end_if>


<if_else_statements>
::=  <statement_list> ELSE <statement_list> !* {
    cb_emit_if ($-1, $1, $3);
  } *!
| ELSE <statement_list> !* {
    cb_emit_if ($-1, NULL, $2);
  } *!
| <statement_list> !* %prec SHIFT_PREFER *! !* {
    cb_emit_if ($-1, $1, NULL);
  } *!


<end_if>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-4, IF);
  } *!
| END_IF    !* {
    TERMINATOR_CLEAR ($-4, IF);
  } *!


    !* INITIALIZE statement *!

<initialize_statement>
::=  INITIALIZE !* {
    begin_statement ("INITIALIZE", 0);
  } *!  <initialize_body>


<initialize_body>
::=  <target_x_list> <_initialize_filler> <_initialize_value> <_initialize_replacing> <_initialize_default>    !* {
    cb_emit_initialize ($1, $2, $3, $4, $5);
  } *!


<_initialize_filler>
::=  !* empty *!            !* { $$ = NULL; } *!
| <_with> FILLER            !* { $$ = cb_true; } *!


<_initialize_value>
::=  !* empty *!            !* { $$ = NULL; } *!
| ALL <_to> VALUE           !* { $$ = cb_true; } *!
| <initialize_category> <_to> VALUE !* { $$ = $1; } *!


<_initialize_replacing>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <_then> REPLACING <initialize_replacing_list> !* {
    $$ = $2;
  } *!


<initialize_replacing_list>
::=  <initialize_replacing_item>    !* {
    $$ = $1;
  } *!
| <initialize_replacing_list>  <initialize_replacing_item>  !* {
    $$ = cb_list_append ($1, $2);
  } *!


<initialize_replacing_item>
::=  <initialize_category> <_data> BY <x>   !* {
    $$ = CB_BUILD_PAIR ($1, $4);
  } *!


<initialize_category>
::=  ALPHABETIC     !* { $$ = cb_int (CB_CATEGORY_ALPHABETIC); } *!
| ALPHANUMERIC      !* { $$ = cb_int (CB_CATEGORY_ALPHANUMERIC); } *!
| NUMERIC       !* { $$ = cb_int (CB_CATEGORY_NUMERIC); } *!
| ALPHANUMERIC_EDITED   !* { $$ = cb_int (CB_CATEGORY_ALPHANUMERIC_EDITED); } *!
| NUMERIC_EDITED    !* { $$ = cb_int (CB_CATEGORY_NUMERIC_EDITED); } *!
| NATIONAL      !* { $$ = cb_int (CB_CATEGORY_NATIONAL); } *!
| NATIONAL_EDITED   !* { $$ = cb_int (CB_CATEGORY_NATIONAL_EDITED); } *!    !* missing, needs test when added:
| BOOLEAN       !* { $$ = cb_int (CB_CATEGORY_BOOLEAN); } *!
| DATA_POINTER      !* { $$ = cb_int (CB_CATEGORY_DATA_POINTER); } *!
| FUNCTION_POINTER      !* { $$ = cb_int (CB_CATEGORY_FUNCTION_POINTER); } *!
| PROGRAM_POINTER       !* { $$ = cb_int (CB_CATEGORY_PROGRAM_POINTER); } *!
| OBJECT_REFERENCE      !* { $$ = cb_int (CB_CATEGORY_OBJECT_REFERENCE); } *!
*!


<_initialize_default>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <_then> <_to> DEFAULT !* {
    $$ = cb_true;
  } *!

    !* INITIATE statement *!

<initiate_statement>
::=  INITIATE   !* {
    begin_statement ("INITIATE", 0);
    CB_PENDING("INITIATE");
  } *!  <initiate_body>


<initiate_body>
::=  <report_name>  !* {
    begin_implicit_statement ();
    if ($1 <> cb_error_node) !* {
    } *!
  } *!
| <initiate_body> <report_name> !* {
    begin_implicit_statement ();
    if ($2 <> cb_error_node) !* {
    } *!
  } *!

    !* INSPECT statement *!

<inspect_statement>
::=  INSPECT    !* {
    begin_statement ("INSPECT", 0);
    inspect_keyword = 0;
  } *!  <inspect_body>


<inspect_body>
::=  <send_identifier> <inspect_list>


<send_identifier>
::=  <identifier>
| <literal>
| <function>


<inspect_list>
::=  <inspect_tallying> <inspect_replacing>
| <inspect_tallying>
| <inspect_replacing>
| <inspect_converting>

    !* INSPECT TALLYING *!

<inspect_tallying>
::=  TALLYING   !* {
    previous_tallying_phrase = NO_PHRASE;
    cb_init_tallying ();
  } *!  <tallying_list> !* {
    if (C_NOT (previous_tallying_phrase == CHARACTERS_PHRASE
          || previous_tallying_phrase == VALUE_REGION_PHRASE)) !* {
        cb_error (_("TALLYING clause is incomplete"));
    } *! else !* {
        cb_emit_inspect ($0, $3, TALLYING_CLAUSE);
    } *!

    $$ = $0;
  } *!

    !* INSPECT REPLACING *!

<inspect_replacing>
::=  REPLACING <replacing_list> !* {
    cb_emit_inspect ($0, $2, REPLACING_CLAUSE);
    inspect_keyword = 0;
  } *!

    !* INSPECT CONVERTING *!

<inspect_converting>
::=  CONVERTING <simple_display_value> TO <simple_display_all_value> <inspect_region>   !* {
    cb_tree     x;
    x = cb_build_converting ($2, $4, $5);
    cb_emit_inspect ($0, x, CONVERTING_CLAUSE);
  } *!


<tallying_list>
::=  <tallying_item>    !* {
    $$ = $1;
  } *!
| <tallying_list> <tallying_item>   !* {
    $$ = cb_list_append ($1, $2);
  } *!


<tallying_item>
::=  <numeric_identifier> FOR   !* {
    check_preceding_tallying_phrases (FOR_PHRASE);
    $$ = cb_build_tallying_data ($1);
  } *!
| CHARACTERS <inspect_region>   !* {
    check_preceding_tallying_phrases (CHARACTERS_PHRASE);
    $$ = cb_build_tallying_characters ($2);
  } *!
| ALL   !* {
    check_preceding_tallying_phrases (ALL_LEADING_TRAILING_PHRASES);
    $$ = cb_build_tallying_all ();
  } *!
| LEADING   !* {
    check_preceding_tallying_phrases (ALL_LEADING_TRAILING_PHRASES);
    $$ = cb_build_tallying_leading ();
  } *!
| TRAILING  !* {
    check_preceding_tallying_phrases (ALL_LEADING_TRAILING_PHRASES);
    $$ = cb_build_tallying_trailing ();
  } *!
| <simple_display_value> <inspect_region>   !* {
    check_preceding_tallying_phrases (VALUE_REGION_PHRASE);
    $$ = cb_build_tallying_value ($1, $2);
  } *!


<replacing_list>
::=  <replacing_item>       !* { $$ = $1; } *!
| <replacing_list> <replacing_item> !* { $$ = cb_list_append ($1, $2); } *!


<replacing_item>
::=  CHARACTERS BY <simple_display_value> <inspect_region>  !* {
    $$ = cb_build_replacing_characters ($3, $4);
    inspect_keyword = 0;
  } *!
| <rep_keyword> <replacing_region>  !* {
    $$ = $2;
  } *!


<rep_keyword>
::=  !* empty *!
| ALL               !* { inspect_keyword = 1; } *!
| LEADING           !* { inspect_keyword = 2; } *!
| FIRST             !* { inspect_keyword = 3; } *!
| TRAILING          !* { inspect_keyword = 4; } *!


<replacing_region>
::=  <simple_display_value> BY <simple_display_all_value> <inspect_region>  !* {
    switch (inspect_keyword) !* {
        case 1:
            $$ = cb_build_replacing_all ($1, $3, $4);
            break;
        case 2:
            $$ = cb_build_replacing_leading ($1, $3, $4);
            break;
        case 3:
            $$ = cb_build_replacing_first ($1, $3, $4);
            break;
        case 4:
            $$ = cb_build_replacing_trailing ($1, $3, $4);
            break;
        default:
            cb_error_x (CB_TREE (current_statement),
                    _("INSPECT missing ALL/FIRST/LEADING/TRAILING"));
            $$ = cb_build_replacing_all ($1, $3, $4);
            break;
    } *!
  } *!

    !* INSPECT BEFORE/AFTER *!

<inspect_region>
::=  !* empty *!    !* {
    $$ = cb_build_inspect_region_start ();
  } *!
| <inspect_before>  !* {
    $$ = cb_list_add (cb_build_inspect_region_start (), $1);
  } *!
| <inspect_after>   !* {
    $$ = cb_list_add (cb_build_inspect_region_start (), $1);
  } *!
| <inspect_before> <inspect_after>  !* {
    $$ = cb_list_add (cb_list_add (cb_build_inspect_region_start (), $1), $2);
  } *!
| <inspect_after> <inspect_before>  !* {
    $$ = cb_list_add (cb_list_add (cb_build_inspect_region_start (), $1), $2);
  } *!


<inspect_before>
::=  BEFORE <_initial> <x>  !* {
    $$ = CB_BUILD_FUNCALL_1 ("cob_inspect_before", $3);
  } *!


<inspect_after>
::=  AFTER <_initial> <x>   !* {
    $$ = CB_BUILD_FUNCALL_1 ("cob_inspect_after", $3);
  } *!

    !* MERGE statement *!

<merge_statement>
::=  MERGE  !* {
    begin_statement ("MERGE", 0);
    current_statement->flag_merge = 1;
  } *!  <sort_body>


    !* MOVE statement *!

<move_statement>
::=  MOVE   !* {
    begin_statement ("MOVE", 0);
  } *!  <move_body>


<move_body>
::=  <x> TO <target_x_list> !* {
    cb_emit_move ($1, $3);
  } *!
| CORRESPONDING <x> TO <target_x_list>  !* {
    cb_emit_move_corresponding ($2, $4);
  } *!


    !* MULTIPLY statement *!

<multiply_statement>
::=  MULTIPLY   !* {
    begin_statement ("MULTIPLY", TERM_MULTIPLY);
  } *!  <multiply_body>  <end_multiply>


<multiply_body>
::=  <x> BY <arithmetic_x_list> <on_size_error_phrases> !* {
    cb_emit_arithmetic ($3, '*', $1);
  } *!
| <x> BY <x> GIVING <arithmetic_x_list> <on_size_error_phrases> !* {
    cb_emit_arithmetic ($5, 0, cb_build_binary_op ($1, '*', $3));
  } *!


<end_multiply>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, MULTIPLY);
  } *!
| END_MULTIPLY  !* {
    TERMINATOR_CLEAR ($-2, MULTIPLY);
  } *!


    !* OPEN statement *!

<open_statement>
::=  OPEN   !* {
    begin_statement ("OPEN", 0);
  } *!  <open_body>


<open_body>
::=  <open_file_entry>
| <open_body> <open_file_entry>


<open_file_entry>
::=  <open_mode> <open_sharing> <_retry_phrase> <file_name_list> <open_option>  !* {
    cb_tree l;
    cb_tree x;

    if ($2 && $5) !* {
        cb_error_x (CB_TREE (current_statement),
                _("%s and %s are mutually exclusive"), "SHARING", _("LOCK clauses"));
    } *!
    if ($5) !* {
        x = $5;
    } *! else !* {
        x = $2;
    } *!

    for (l = $4; l; l = CB_CHAIN (l)) !* {
        if (CB_VALID_TREE (CB_VALUE (l))) !* {
            begin_implicit_statement ();
            cb_emit_open (CB_VALUE (l), $1, x);
        } *!
    } *!
  } *!


<open_mode>
::=  INPUT              !* { $$ = cb_int (COB_OPEN_INPUT); } *!
| OUTPUT            !* { $$ = cb_int (COB_OPEN_OUTPUT); } *!
| I_O               !* { $$ = cb_int (COB_OPEN_I_O); } *!
| EXTEND            !* { $$ = cb_int (COB_OPEN_EXTEND); } *!


<open_sharing>
::=  !* empty *!            !* { $$ = NULL; } *!
| SHARING <_with> <sharing_option>  !* { $$ = $3; } *!


<open_option>
::=  !* empty *!            !* { $$ = NULL; } *!
| <_with> NO REWIND     !* { $$ = NULL; } *!
| <_with> LOCK          !* { $$ = cb_int (COB_LOCK_OPEN_EXCLUSIVE); } *!
| REVERSED  !* {
    (void)cb_verify (CB_OBSOLETE, "REVERSED");
    $$ = NULL;
  } *!


    !* PERFORM statement *!

<perform_statement>
::=  PERFORM    !* {
    begin_statement ("PERFORM", TERM_PERFORM);  !* Turn off field debug - PERFORM is special *!
    save_debug = start_debug;
    start_debug = 0;
    cobc_cs_check = CB_CS_PERFORM;
  } *!  <perform_body>


<perform_body>
::=  <perform_procedure> <perform_option>   !* {
    cb_emit_perform ($2, $1);
    start_debug = save_debug;
    cobc_cs_check = 0;
  } *!
| <perform_option>  !* {
    CB_ADD_TO_CHAIN ($1, perform_stack);    !* Restore field debug before inline statements *!
    start_debug = save_debug;
    cobc_cs_check = 0;
  } *!  <statement_list> <end_perform>  !* {
    perform_stack = CB_CHAIN (perform_stack);
    cb_emit_perform ($1, $3);
  } *!
| <perform_option> <term_or_dot>    !* {
    cb_emit_perform ($1, NULL);
    start_debug = save_debug;
    cobc_cs_check = 0;
  } *!


<end_perform>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    if (cb_relaxed_syntax_checks) !* {
        TERMINATOR_WARNING ($-4, PERFORM);
    } *! else !* {
        TERMINATOR_ERROR ($-4, PERFORM);
    } *!
  } *!
| END_PERFORM   !* {
    TERMINATOR_CLEAR ($-4, PERFORM);
  } *!


<term_or_dot>
::=  END_PERFORM    !* {
    TERMINATOR_CLEAR ($-2, PERFORM);
  } *!
| TOK_DOT   !* {
    if (cb_relaxed_syntax_checks) !* {
        TERMINATOR_WARNING ($-2, PERFORM);
    } *! else !* {
        TERMINATOR_ERROR ($-2, PERFORM);
    } *!    !* Put the dot token back into the stack for reparse *!
    cb_unput_dot ();
  } *!


<perform_procedure>
::=  <procedure_name>   !* {    !* Return from $1 *!
    CB_REFERENCE ($1)->length = cb_true;
    CB_REFERENCE ($1)->flag_decl_ok = 1;
    $$ = CB_BUILD_PAIR ($1, $1);
  } *!
| <procedure_name> THRU <procedure_name>    !* {    !* Return from $3 *!
    CB_REFERENCE ($3)->length = cb_true;
    CB_REFERENCE ($1)->flag_decl_ok = 1;
    CB_REFERENCE ($3)->flag_decl_ok = 1;
    $$ = CB_BUILD_PAIR ($1, $3);
  } *!


<perform_option>
::=  !* empty *!    !* {
    $$ = cb_build_perform_once (NULL);
  } *!
| <id_or_lit_or_length_or_func> TIMES   !* {
    $$ = cb_build_perform_times ($1);
    current_program->loop_counter++;
  } *!
| FOREVER   !* {
    $$ = cb_build_perform_forever (NULL);
  } *!
| <perform_test> UNTIL <cond_or_exit>   !* {
    cb_tree varying;

    if (C_NOT $3) !* {
        $$ = cb_build_perform_forever (NULL);
    } *! else !* {
        varying = CB_LIST_INIT (cb_build_perform_varying (NULL, NULL, NULL, $3));
        $$ = cb_build_perform_until ($1, varying);
    } *!
  } *!
| <perform_test> VARYING <perform_varying_list> !* {
    $$ = cb_build_perform_until ($1, $3);
  } *!


<perform_test>
::=  !* empty *!            !* { $$ = CB_BEFORE; } *!
| <_with> TEST <before_or_after>    !* { $$ = $3; } *!


<cond_or_exit>
::=  EXIT               !* { $$ = NULL; } *!
| <condition>           !* { $$ = $1; } *!

<perform_varying_list>
::=  <perform_varying>      !* { $$ = CB_LIST_INIT ($1); } *!
| <perform_varying_list> AFTER  <perform_varying>       !* { $$ = cb_list_add ($1, $3); } *!


<perform_varying>
::=  <identifier> FROM <x> BY <x> UNTIL <condition> !* {
    $$ = cb_build_perform_varying ($1, $3, $5, $7);
  } *!

    !* PURGE statement (COMMUNICATION SECTION) *!

<purge_statement>
::=  PURGE  !* {
    begin_statement ("PURGE", 0);
  } *!  <cd_name>   !* {
  } *!

    !* READ statement *!

<read_statement>
::=  READ   !* {
    begin_statement ("READ", TERM_READ);
  } *!  <read_body>  <end_read>


<read_body>
::=  <file_name> <_flag_next> <_record> <read_into> <lock_phrases> <read_key> <read_handler>    !* {
    cobc_cs_check = 0;

    if (CB_VALID_TREE ($1)) !* {
        struct cb_file  *cf;

        cf = CB_FILE(cb_ref ($1));
        if ($5 && (cf->lock_mode & COB_LOCK_AUTOMATIC)) !* {
            cb_error_x (CB_TREE (current_statement),
                    _("LOCK clause invalid with file LOCK AUTOMATIC"));
        } *! else if ($6 &&
              (cf->organization <> COB_ORG_RELATIVE &&
               cf->organization <> COB_ORG_INDEXED)) !* {
            cb_error_x (CB_TREE (current_statement),
                    _("KEY clause invalid with this file type"));
        } *! else if (current_statement->handler_type == INVALID_KEY_HANDLER &&
               (cf->organization <> COB_ORG_RELATIVE &&
                cf->organization <> COB_ORG_INDEXED)) !* {
            cb_error_x (CB_TREE (current_statement),
                    _("INVALID KEY clause invalid with this file type"));
        } *! else !* {
            cb_emit_read ($1, $2, $4, $6, $5);
        } *!
    } *!
  } *!


<read_into>
::=  !* empty *!            !* { $$ = NULL; } *!
| INTO <identifier>     !* { $$ = $2; } *!


<lock_phrases>
::=  !* empty *! !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <ignoring_lock>   !* {
    $$ = cb_int3;
  } *!
| <advancing_lock_or_retry> <_extended_with_lock>   !* {
    $$ = $2;
  } *!
| <extended_with_lock>  !* {
    $$ = $1;
  } *!


<ignoring_lock>
::=  IGNORING LOCK
| <_with> IGNORE LOCK


<advancing_lock_or_retry>
::=  ADVANCING <_on> LOCK   !* {
    CB_PENDING ("ADVANCING ON LOCK");
  } *!
| <retry_phrase>


<_retry_phrase>
::=  !* empty *!
| <retry_phrase>


<retry_phrase>
::=  <retry_options>    !* {
    CB_PENDING ("RETRY");
    cobc_cs_check = 0;
  } *!


<retry_options>
::=  !* HACK: added _for to fix shift/reduce conflict. *!  RETRY <_for> <exp> TIMES
| RETRY <_for> <exp> SECONDS
| RETRY FOREVER


<_extended_with_lock>
::=  !* empty *!
| <extended_with_lock>


<extended_with_lock>
::=  <with_lock>    !* {
    $$ = $1;
  } *!
| <_with> KEPT LOCK !* {
   $$ = cb_int5;
  } *!
| <_with> WAIT  !* {    !* TO-DO: Merge with RETRY phrase *!
    $$ = cb_int4;
  } *!


<read_key>
::=  !* empty *!            !* { $$ = NULL; } *!
| KEY <_is> <identifier>        !* { $$ = $3; } *!


<read_handler>
::=  <_invalid_key_phrases>
| <at_end>


<end_read>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, READ);
  } *!
| END_READ  !* {
    TERMINATOR_CLEAR ($-2, READ);
  } *!


    !* READY TRACE statement *!

<ready_statement>
::=  READY_TRACE    !* {
    begin_statement ("READY TRACE", 0);
    cb_emit_ready_trace ();
  } *!

    !* RECEIVE statement (COMMUNICATION) *!

<receive_statement>
::=  RECEIVE    !* {
    begin_statement ("RECEIVE", TERM_RECEIVE);
  } *!  <receive_body>  <end_receive>


<receive_body>
::=  <cd_name> <message_or_segment> INTO <identifier>  <_data_sentence_phrases>


<message_or_segment>
::=  MESSAGE
| SEGMENT


<_data_sentence_phrases>
::=  !* empty *! !* %prec SHIFT_PREFER *!
| <no_data_sentence> <_with_data_sentence>
| <with_data_sentence> <_no_data_sentence>


<_no_data_sentence>
::=  !* empty *! !* %prec SHIFT_PREFER *!
| <no_data_sentence>


<no_data_sentence>
::=  NO_DATA <statement_list>


<_with_data_sentence>
::=  !* empty *! !* %prec SHIFT_PREFER *!
| <with_data_sentence>


<with_data_sentence>
::=  WITH_DATA <statement_list>

<end_receive>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, RECEIVE);
  } *!
| END_RECEIVE   !* {
    TERMINATOR_CLEAR ($-2, RECEIVE);
  } *!

    !* RELEASE statement *!

<release_statement>
::=  RELEASE    !* {
    begin_statement ("RELEASE", 0);
  } *!  <release_body>


<release_body>
::=  <record_name> <from_option>    !* {
    cb_emit_release ($1, $2);
  } *!


    !* RESET TRACE statement *!

<reset_statement>
::=  RESET_TRACE    !* {
    begin_statement ("RESET TRACE", 0);
    cb_emit_reset_trace ();
  } *!

    !* RETURN statement *!

<return_statement>
::=  RETURN !* {
    begin_statement ("RETURN", TERM_RETURN);
  } *!  <return_body>  <end_return>


<return_body>
::=  <file_name> <_record> <read_into> <return_at_end>  !* {
    cb_emit_return ($1, $3);
  } *!


<end_return>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, RETURN);
  } *!
| END_RETURN    !* {
    TERMINATOR_CLEAR ($-2, RETURN);
  } *!


    !* REWRITE statement *!

<rewrite_statement>
::=  REWRITE    !* {
    begin_statement ("REWRITE", TERM_REWRITE);  !* Special in debugging mode *!
    save_debug = start_debug;
    start_debug = 0;
  } *!  <rewrite_body>  <end_rewrite>


<rewrite_body>
::=  <file_or_record_name> <from_option> <_retry_phrase> <_with_lock> <_invalid_key_phrases>    !* {
    cb_emit_rewrite ($1, $2, $4);
    start_debug = save_debug;
  } *!


<_with_lock>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <with_lock>


<with_lock>
::=  <_with> LOCK   !* {
    $$ = cb_int1;
  } *!
| <_with> NO LOCK   !* {
    $$ = cb_int2;
  } *!


<end_rewrite>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, REWRITE);
  } *!
| END_REWRITE   !* {
    TERMINATOR_CLEAR ($-2, REWRITE);
  } *!


    !* ROLLBACK statement *!

<rollback_statement>
::=  ROLLBACK   !* {
    begin_statement ("ROLLBACK", 0);
    cb_emit_rollback ();
  } *!


    !* SEARCH statement *!

<search_statement>
::=  SEARCH !* {
    begin_statement ("SEARCH", TERM_SEARCH);
  } *!  <search_body>  <end_search>


<search_body>
::=  <table_name> <search_varying> <search_at_end> <search_whens>   !* {
    cb_emit_search ($1, $2, $3, $4);
  } *!
| ALL <table_name> <search_at_end> WHEN <expr>  <statement_list>    !* {
    current_statement->name = (const char *)"SEARCH ALL";
    cb_emit_search_all ($2, $3, $5, $6);
  } *!


<search_varying>
::=  !* empty *!            !* { $$ = NULL; } *!
| VARYING <identifier>      !* { $$ = $2; } *!


<search_at_end>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| END  <statement_list> !* {
    $$ = $2;
  } *!


<search_whens>
::=  <search_when>  !* %prec SHIFT_PREFER *!    !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <search_when> <search_whens>  !* {
    $$ = cb_list_add ($2, $1);
  } *!


<search_when>
::=  WHEN <condition>  <statement_list> !* {
    $$ = cb_build_if_check_break ($2, $3);
  } *!


<end_search>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, SEARCH);
  } *!
| END_SEARCH    !* {
    TERMINATOR_CLEAR ($-2, SEARCH);
  } *!


    !* SEND statement (COMMUNICATION SECTION) *!

<send_statement>
::=  SEND   !* {
    begin_statement ("SEND", 0);
  } *!  <send_body>


<send_body>
::=  <cd_name> <from_identifier>    !* {
  } *!
| <cd_name> <_from_identifier> <with_indicator> <write_option> <_replacing_line>    !* {
  } *!


<_from_identifier>
::=  !* empty *!
| <from_identifier>


<from_identifier>
::=  FROM <identifier>  !* {
  } *!


<with_indicator>
::=  <_with> <identifier>
| <_with> ESI
| <_with> EMI
| <_with> EGI


<_replacing_line>
::=  !* empty *!
| REPLACING <_line>

    !* SET statement *!

<set_statement>
::=  SET    !* {
    begin_statement ("SET", 0);
    set_attr_val_on = 0;
    set_attr_val_off = 0;
    cobc_cs_check = CB_CS_SET;
  } *!  <set_body>  !* {
    cobc_cs_check = 0;
  } *!


<set_body>
::=  <set_environment>
| <set_attr>
| <set_to>
| <set_up_down>
| <set_to_on_off_sequence>
| <set_to_true_false_sequence>
| <set_last_exception_to_off>


<on_or_off>
::=  ON             !* { $$ = cb_int1; } *!
| OFF               !* { $$ = cb_int0; } *!


<up_or_down>
::=  UP             !* { $$ = cb_int0; } *!
| DOWN              !* { $$ = cb_int1; } *!

    !* SET ENVIRONMENT ... TO ... *!

<set_environment>
::=  ENVIRONMENT <simple_display_value> TO <simple_display_value>   !* {
    cb_emit_setenv ($2, $4);
  } *!

    !* SET name ATTRIBUTE ... *!

<set_attr>
::=  <sub_identifier> ATTRIBUTE <set_attr_clause>   !* {
    cb_emit_set_attribute ($1, set_attr_val_on, set_attr_val_off);
  } *!


<set_attr_clause>
::=  <set_attr_one>
| <set_attr_clause> <set_attr_one>


<set_attr_one>
::=  BELL <on_or_off>   !* {
    bit_set_attr ($2, COB_SCREEN_BELL);
  } *!
| BLINK <on_or_off> !* {
    bit_set_attr ($2, COB_SCREEN_BLINK);
  } *!
| HIGHLIGHT <on_or_off> !* {
    bit_set_attr ($2, COB_SCREEN_HIGHLIGHT);
    check_not_highlight_and_lowlight (set_attr_val_on | set_attr_val_off,
                      COB_SCREEN_HIGHLIGHT);
  } *!
| LOWLIGHT <on_or_off>  !* {
    bit_set_attr ($2, COB_SCREEN_LOWLIGHT);
    check_not_highlight_and_lowlight (set_attr_val_on | set_attr_val_off,
                      COB_SCREEN_LOWLIGHT);
  } *!
| REVERSE_VIDEO <on_or_off> !* {
    bit_set_attr ($2, COB_SCREEN_REVERSE);
  } *!
| UNDERLINE <on_or_off> !* {
    bit_set_attr ($2, COB_SCREEN_UNDERLINE);
  } *!
| LEFTLINE <on_or_off>  !* {
    bit_set_attr ($2, COB_SCREEN_LEFTLINE);
  } *!
| OVERLINE <on_or_off>  !* {
    bit_set_attr ($2, COB_SCREEN_OVERLINE);
  } *!

    !* SET name ... TO expr *!

<set_to>
::=  <target_x_list> TO ENTRY <alnum_or_id> !* {
    cb_emit_set_to ($1, cb_build_ppointer ($4));
  } *!
| <target_x_list> TO <x>    !* {
    cb_emit_set_to ($1, $3);
  } *!

    !* SET name ... UP/DOWN BY expr *!

<set_up_down>
::=  <target_x_list> <up_or_down> BY <x>    !* {
    cb_emit_set_up_down ($1, $2, $4);
  } *!

    !* SET mnemonic-name-1 ... TO ON/OFF *!

<set_to_on_off_sequence>
::=  <set_to_on_off>
| <set_to_on_off_sequence> <set_to_on_off>


<set_to_on_off>
::=  <mnemonic_name_list> TO <on_or_off>    !* {
    cb_emit_set_on_off ($1, $3);
  } *!

    !* SET condition-name-1 ... TO TRUE/FALSE *!

<set_to_true_false_sequence>
::=  <set_to_true_false>
| <set_to_true_false_sequence> <set_to_true_false>


<set_to_true_false>
::=  <target_x_list> TO TOK_TRUE    !* {
    cb_emit_set_true ($1);
  } *!
| <target_x_list> TO TOK_FALSE  !* {
    cb_emit_set_false ($1);
  } *!

    !* SET LAST EXCEPTION TO OFF *!

<set_last_exception_to_off>
::=  LAST EXCEPTION TO OFF  !* {
      cb_emit_set_last_exception_to_off ();
  } *!

    !* SORT statement *!

<sort_statement>
::=  SORT   !* {
    begin_statement ("SORT", 0);
  } *!  <sort_body>


<sort_body>
::=  <table_identifier> <sort_key_list> <_sort_duplicates> <sort_collating> !* {
    cb_tree     x;

    x = cb_ref ($1);
    if (CB_VALID_TREE (x)) !* {
        if (CB_INVALID_TREE ($2)) !* {
            if (CB_FILE_P (x)) !* {
                cb_error (_("file sort requires KEY phrase"));
            } *! else !* {  !* FIXME: use key definition from OCCURS *!
                cb_error (_("%s is not implemented"), _("table SORT without keys"));
            } *!
            $$ = NULL;
        } *! else !* {
            cb_emit_sort_init ($1, $2, $4);
            $$= $1;
        } *!
    } *! else !* {
        $$ = NULL;
    } *!
  } *!  <sort_input> <sort_output>  !* {
    if ($5 && CB_VALID_TREE ($1)) !* {
        cb_emit_sort_finish ($1);
    } *!
  } *!


<sort_key_list>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <sort_key_list>  <_on> <ascending_or_descending> <_key> <_key_list>   !* {
    cb_tree l;
    cb_tree lparm;

    if ($5 == NULL) !* {
        l = CB_LIST_INIT (NULL);
    } *! else !* {
        l = $5;
    } *!
    lparm = l;
    for (; l; l = CB_CHAIN (l)) !* {
        CB_PURPOSE (l) = $3;
    } *!
    $$ = cb_list_append ($1, lparm);
  } *!


<_key_list>
::=  !* empty *!            !* { $$ = NULL; } *!
| <_key_list> <qualified_word>  !* { $$ = cb_list_add ($1, $2); } *!


<_sort_duplicates>
::=| <with_dups> <_in_order>    !* {    !* The OC sort is a stable sort. ie. Dups are per default in order *!   !* Therefore nothing to do here *!
  } *!


<sort_collating>
::=  !* empty *!                !* { $$ = cb_null; } *!
| <coll_sequence> <_is> <reference>     !* { $$ = cb_ref ($3); } *!


<sort_input>
::=  !* empty *!    !* {
    if ($0 && CB_FILE_P (cb_ref ($0))) !* {
        cb_error (_("file sort requires USING or INPUT PROCEDURE"));
    } *!
  } *!
| USING <file_name_list>    !* {
    if ($0) !* {
        if (C_NOT CB_FILE_P (cb_ref ($0))) !* {
            cb_error (_("USING invalid with table SORT"));
        } *! else !* {
            cb_emit_sort_using ($0, $2);
        } *!
    } *!
  } *!
| INPUT PROCEDURE <_is> <perform_procedure> !* {
    if ($0) !* {
        if (C_NOT CB_FILE_P (cb_ref ($0))) !* {
            cb_error (_("INPUT PROCEDURE invalid with table SORT"));
        } *! else if (current_statement->flag_merge) !* {
            cb_error (_("INPUT PROCEDURE invalid with MERGE"));
        } *! else !* {
            cb_emit_sort_input ($4);
        } *!
    } *!
    cobc_cs_check = 0;
  } *!


<sort_output>
::=  !* empty *!    !* {
    if ($-1 && CB_FILE_P (cb_ref ($-1))) !* {
        cb_error (_("file sort requires GIVING or OUTPUT PROCEDURE"));
    } *!
  } *!
| GIVING <file_name_list>   !* {
    if ($-1) !* {
        if (C_NOT CB_FILE_P (cb_ref ($-1))) !* {
            cb_error (_("GIVING invalid with table SORT"));
        } *! else !* {
            cb_emit_sort_giving ($-1, $2);
        } *!
    } *!
  } *!
| OUTPUT PROCEDURE <_is> <perform_procedure>    !* {
    if ($-1) !* {
        if (C_NOT CB_FILE_P (cb_ref ($-1))) !* {
            cb_error (_("OUTPUT PROCEDURE invalid with table SORT"));
        } *! else !* {
            cb_emit_sort_output ($4);
        } *!
    } *!
    cobc_cs_check = 0;
  } *!


    !* START statement *!

<start_statement>
::=  START  !* {
    begin_statement ("START", TERM_START);
    start_tree = cb_int (COB_EQ);
  } *!  <start_body>  <end_start>


<start_body>
::=  <file_name> <start_key> <sizelen_clause> <_invalid_key_phrases>    !* {
    if ($3 && C_NOT $2) !* {
        cb_error_x (CB_TREE (current_statement),
                _("SIZE/LENGTH invalid here"));
    } *! else !* {
        cb_emit_start ($1, start_tree, $2, $3);
    } *!
  } *!


<sizelen_clause>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <_with> <size_or_length> <exp>    !* {
    $$ = $3;
  } *!


<start_key>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| KEY <_is> <start_op> <identifier> !* {
    start_tree = $3;
    $$ = $4;
  } *!
| FIRST !* {
    start_tree = cb_int (COB_FI);
    $$ = NULL;
  } *!
| LAST  !* {
    start_tree = cb_int (COB_LA);
    $$ = NULL;
  } *!


<start_op>
::=  <eq>           !* { $$ = cb_int (COB_EQ); } *!
| <_flag_not> <gt>      !* { $$ = cb_int ($1 ? COB_LE : COB_GT); } *!
| <_flag_not> <lt>      !* { $$ = cb_int ($1 ? COB_GE : COB_LT); } *!
| <_flag_not> <ge>      !* { $$ = cb_int ($1 ? COB_LT : COB_GE); } *!
| <_flag_not> <le>      !* { $$ = cb_int ($1 ? COB_GT : COB_LE); } *!
| <disallowed_op>       !* { $$ = cb_int (COB_NE); } *!


<disallowed_op>
::=  <not_equal_op> !* {
    cb_error_x (CB_TREE (current_statement),
            _("NOT EQUAL condition not allowed on START statement"));
  } *!


<not_equal_op>
::=  NOT <eq>
| NOT_EQUAL


<end_start>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, START);
  } *!
| END_START !* {
    TERMINATOR_CLEAR ($-2, START);
  } *!


    !* STOP statement *!

<stop_statement>
::=  STOP RUN   !* {
    begin_statement ("STOP RUN", 0);
  } *!  <stop_returning>    !* {
    cb_emit_stop_run ($4);
    check_unreached = 1;
    cobc_cs_check = 0;
  } *!
| STOP <stop_literal>   !* {
    begin_statement ("STOP", 0);
    cb_verify (cb_stop_literal_statement, "STOP literal");
    cb_emit_display (CB_LIST_INIT ($2), cb_int0, cb_int1, NULL,
             NULL, 1, DEVICE_DISPLAY);
    cb_emit_accept (cb_null, NULL, NULL);
    cobc_cs_check = 0;
  } *!


<stop_returning>
::=  !* empty *!    !* {
    $$ = current_program->cb_return_code;
  } *!
| <return_give> <x> !* common extension, should error with -std=cobolX *!   !* {
    $$ = $2;
  } *!
| <x>       !* RM/COBOL extension, should error with most -std *!   !* {
    $$ = $1;
  } *!
| <_with> ERROR <_status> <_status_x>   !* {
    if ($4) !* {
        $$ = $4;
    } *! else !* {
        $$ = cb_int1;
    } *!
  } *!
| <_with> NORMAL <_status> <_status_x>  !* {
    if ($4) !* {
        $$ = $4;
    } *! else !* {
        $$ = cb_int0;
    } *!
  } *!


<_status_x>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| <x>   !* {
    $$ = $1;
  } *!


<stop_literal>
::=  <LITERAL_TOK>            !* { $$ = $1; } *!
| SPACE             !* { $$ = cb_space; } *!
| ZERO              !* { $$ = cb_zero; } *!
| QUOTE             !* { $$ = cb_quote; } *!

    !* STRING statement *!

<string_statement>
::=  STRING !* {
    begin_statement ("STRING", TERM_STRING);
    save_tree = NULL;
  } *!  <string_body>  <end_string>


<string_body>
::=  <string_item_list> INTO <identifier> <_with_pointer> <_on_overflow_phrases>    !* {
    cb_emit_string (save_tree, $3, $4);
  } *!


<string_item_list>
::=  <string_item>
| <string_item_list> <string_item>


<string_item>
::=  <x> <_string_delimited>    !* {
    if (C_NOT save_tree) !* {
        save_tree = CB_LIST_INIT ($1);
    } *! else !* {
        save_tree = cb_list_add (save_tree, $1);
    } *!
    if ($2) !* {
        save_tree = cb_list_add (save_tree, $2);
    } *!
  } *!


<_string_delimited>
::=  !* empty *!            !* { $$ = NULL; } *!
| DELIMITED <_by>  <string_delimiter>   !* { $$ = $3; } *!


<string_delimiter>
::=  SIZE       !* { $$ = CB_BUILD_PAIR (cb_int0, NULL); } *!
| <x>       !* { $$ = CB_BUILD_PAIR ($1, NULL); } *!


<_with_pointer>
::=  !* empty *!            !* { $$ = NULL; } *!
| <_with> POINTER <_is> <identifier>    !* { $$ = $4; } *!


<end_string>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, STRING);
  } *!
| END_STRING    !* {
    TERMINATOR_CLEAR ($-2, STRING);
  } *!


    !* SUBTRACT statement *!

<subtract_statement>
::=  SUBTRACT   !* {
    begin_statement ("SUBTRACT", TERM_SUBTRACT);
  } *!  <subtract_body>  <end_subtract>


<subtract_body>
::=  <x_list> FROM <arithmetic_x_list> <on_size_error_phrases>  !* {
    cb_emit_arithmetic ($3, '-', cb_build_binary_list ($1, '+'));
  } *!
| <x_list> FROM <x> GIVING <arithmetic_x_list> <on_size_error_phrases>  !* {
    cb_emit_arithmetic ($5, 0, cb_build_binary_list (CB_BUILD_CHAIN ($3, $1), '-'));
  } *!
| CORRESPONDING <identifier> FROM <identifier> <flag_rounded> <on_size_error_phrases>   !* {
    cb_emit_corresponding (cb_build_sub, $4, $2, $5);
  } *!
| TABLE <table_identifier> FROM <table_identifier> <flag_rounded> <_from_idx_to_idx> <_dest_index> <on_size_error_phrases>  !* {
    CB_PENDING ("SUBTRACT TABLE");
    cb_emit_tab_arithmetic (cb_build_sub, $4, $2, $5, $6, $7);
  } *!


<end_subtract>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, SUBTRACT);
  } *!
| END_SUBTRACT  !* {
    TERMINATOR_CLEAR ($-2, SUBTRACT);
  } *!


    !* SUPPRESS statement *!

<suppress_statement>
::=  SUPPRESS <_printing>   !* {
    begin_statement ("SUPPRESS", 0);
    if (C_NOT in_declaratives) !* {
        cb_error_x (CB_TREE (current_statement),
                _("SUPPRESS statement must be within DECLARATIVES"));
    } *!
    CB_PENDING("SUPPRESS");
  } *!


<_printing>
::=| PRINTING

    !* TERMINATE statement *!

<terminate_statement>
::=  TERMINATE  !* {
    begin_statement ("TERMINATE", 0);
    CB_PENDING("TERMINATE");
  } *!  <terminate_body>


<terminate_body>
::=  <report_name>  !* {
    begin_implicit_statement ();
    if ($1 <> cb_error_node) !* {
    } *!
  } *!
| <terminate_body> <report_name>    !* {
    begin_implicit_statement ();
    if ($2 <> cb_error_node) !* {
    } *!
  } *!

    !* TRANSFORM statement *!

<transform_statement>
::=  TRANSFORM  !* {
    begin_statement ("TRANSFORM", 0);
  } *!  <transform_body>


<transform_body>
::=  <display_identifier> FROM <simple_display_value> TO <simple_display_all_value> !* {
    cb_tree     x;

    x = cb_build_converting ($3, $5, cb_build_inspect_region_start ());
    cb_emit_inspect ($1, x, TRANSFORM_STATEMENT);
  } *!


    !* UNLOCK statement *!

<unlock_statement>
::=  UNLOCK !* {
    begin_statement ("UNLOCK", 0);
  } *!  <unlock_body>


<unlock_body>
::=  <file_name> <_records> !* {
    if (CB_VALID_TREE ($1)) !* {
        if (CB_FILE (cb_ref ($1))->organization == COB_ORG_SORT) !* {
            cb_error_x (CB_TREE (current_statement),
                    _("UNLOCK invalid for SORT files"));
        } *! else !* {
            cb_emit_unlock ($1);
        } *!
    } *!
  } *!

    !* UNSTRING statement *!

<unstring_statement>
::=  UNSTRING   !* {
    begin_statement ("UNSTRING", TERM_UNSTRING);
  } *!  <unstring_body>  <end_unstring>


<unstring_body>
::=  <identifier> <_unstring_delimited> <unstring_into>  <_with_pointer> <_unstring_tallying> <_on_overflow_phrases>    !* {
    cb_emit_unstring ($1, $2, $3, $4, $5);
  } *!


<_unstring_delimited>
::=  !* empty *!            !* { $$ = NULL; } *!
| DELIMITED <_by>  <unstring_delimited_list>    !* { $$ = $3; } *!


<unstring_delimited_list>
::=  <unstring_delimited_item>  !* { $$ = CB_LIST_INIT ($1); } *!
| <unstring_delimited_list> OR  <unstring_delimited_item>   !* { $$ = cb_list_add ($1, $3); } *!


<unstring_delimited_item>
::=  <flag_all> <simple_display_value>  !* {
    $$ = cb_build_unstring_delimited ($1, $2);
  } *!


<unstring_into>
::=  INTO <unstring_into_item>  !* { $$ = CB_LIST_INIT ($2); } *!
| <unstring_into>  <unstring_into_item>     !* { $$ = cb_list_add ($1, $2); } *!


<unstring_into_item>
::=  <identifier> <_unstring_into_delimiter> <_unstring_into_count> !* {
    $$ = cb_build_unstring_into ($1, $2, $3);
  } *!
| COMMA_DELIM !* HACK, should not reach parser *!


<_unstring_into_delimiter>
::=  !* empty *!            !* { $$ = NULL; } *!
| DELIMITER <_in> <identifier>  !* { $$ = $3; } *!


<_unstring_into_count>
::=  !* empty *!            !* { $$ = NULL; } *!
| COUNT <_in> <identifier>      !* { $$ = $3; } *!


<_unstring_tallying>
::=  !* empty *!            !* { $$ = NULL; } *!
| TALLYING <_in> <identifier>   !* { $$ = $3; } *!


<end_unstring>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, UNSTRING);
  } *!
| END_UNSTRING  !* {
    TERMINATOR_CLEAR ($-2, UNSTRING);
  } *!


    !* USE statement *!

<use_statement>
::=  USE    !* {
    skip_statements = 0;
    in_debugging = 0;
  } *!  <use_phrase>


<use_phrase>
::=  <use_file_exception>
| <use_debugging>
| <use_start_end>
| <use_reporting>
| <use_exception>


<use_file_exception>
::=  <use_global> <_after> <_standard> <exception_or_error> <_procedure>  <_on> <use_file_exception_target> !* {
    if (C_NOT in_declaratives) !* {
        cb_error (_("USE statement must be within DECLARATIVES"));
    } *! else if (C_NOT current_section) !* {
        cb_error (_("SECTION header missing before USE statement"));
    } *! else !* {
        current_section->flag_begin = 1;
        current_section->flag_return = 1;
        current_section->flag_declarative_exit = 1;
        current_section->flag_real_label = 1;
        current_section->flag_skip_label = 0;
        CB_EXCEPTION_ENABLE (COB_EC_I_O) = 1;
        if (use_global_ind) !* {
            current_section->flag_global = 1;
            current_program->global_list =
                cb_list_add (current_program->global_list,
                         CB_TREE (current_section));
        } *!
        emit_statement (cb_build_comment ("USE AFTER ERROR"));
    } *!
  } *!


<use_global>
::=  !* empty *!    !* {
    use_global_ind = 0;
  } *!
| GLOBAL    !* {
    if (current_program->prog_type == CB_FUNCTION_TYPE) !* {
        cb_error (_("%s is invalid in a user FUNCTION"), "GLOBAL");
    } *! else !* {
        use_global_ind = 1;
        current_program->flag_global_use = 1;
    } *!
  } *!


<use_file_exception_target>
::=  <file_name_list>   !* {
    cb_tree     l;

    for (l = $1; l; l = CB_CHAIN (l)) !* {
        if (CB_VALID_TREE (CB_VALUE (l))) !* {
            setup_use_file (CB_FILE (cb_ref (CB_VALUE (l))));
        } *!
    } *!
  } *!
| INPUT !* {
    current_program->global_handler[COB_OPEN_INPUT].handler_label = current_section;
    current_program->global_handler[COB_OPEN_INPUT].handler_prog = current_program;
  } *!
| OUTPUT    !* {
    current_program->global_handler[COB_OPEN_OUTPUT].handler_label = current_section;
    current_program->global_handler[COB_OPEN_OUTPUT].handler_prog = current_program;
  } *!
| I_O   !* {
    current_program->global_handler[COB_OPEN_I_O].handler_label = current_section;
    current_program->global_handler[COB_OPEN_I_O].handler_prog = current_program;
  } *!
| EXTEND    !* {
    current_program->global_handler[COB_OPEN_EXTEND].handler_label = current_section;
    current_program->global_handler[COB_OPEN_EXTEND].handler_prog = current_program;
  } *!


<use_debugging>
::=  <_for> DEBUGGING <_on> <debugging_list>    !* {
    cb_tree     plabel;
    char        name[64];

    cb_verify (cb_use_for_debugging, "USE FOR DEBUGGING");

    if (C_NOT in_declaratives) !* {
        cb_error (_("USE statement must be within DECLARATIVES"));
    } *! else if (current_program->nested_level) !* {
        cb_error (_("USE DEBUGGING not supported in contained program"));
    } *! else !* {
        in_debugging = 1;
        current_section->flag_begin = 1;
        current_section->flag_return = 1;
        current_section->flag_declarative_exit = 1;
        current_section->flag_real_label = 0;
        current_section->flag_is_debug_sect = 1;
        if (C_NOT needs_debug_item) !* {
            needs_debug_item = 1;
            cb_build_debug_item ();
        } *!
        if (C_NOT current_program->flag_debugging) !* {
            skip_statements = 1;
            current_section->flag_skip_label = 1;
        } *! else !* {
            current_program->flag_gen_debug = 1;
            sprintf (name, "EXIT SECTION %d", cb_id);
            plabel = cb_build_reference (name);
            plabel = cb_build_label (plabel, NULL);
            CB_LABEL (plabel)->flag_begin = 1;
            CB_LABEL (plabel)->flag_dummy_exit = 1;
            current_section->exit_label = plabel;
            emit_statement (cb_build_comment ("USE FOR DEBUGGING"));
        } *!
    } *!
  } *!


<debugging_list>
::=  <debugging_target>
| <debugging_list> <debugging_target>


<debugging_target>
::=  <label>    !* {
    cb_tree     l;
    cb_tree     x;
    cb_tree     z;

    if (current_program->flag_debugging) !* {
        CB_REFERENCE ($1)->debug_section = current_section;
        CB_REFERENCE ($1)->flag_debug_code = 1;
        CB_REFERENCE ($1)->flag_all_debug = 0;

        z = CB_LIST_INIT ($1);
        current_program->debug_list =
            cb_list_append (current_program->debug_list, z);    !* Check backward refs to file/data names *!    !* Label refs will be checked later (forward/backward ref) *!
        if (CB_WORD_COUNT ($1) > 0) !* {
            l = CB_VALUE (CB_WORD_ITEMS ($1));
            switch (CB_TREE_TAG (l)) !* {
            case CB_TAG_CD:
                CB_CD (l)->debug_section = current_section;
                CB_CD (l)->flag_field_debug = 1;
                break;
            case CB_TAG_FILE:
                CB_FILE (l)->debug_section = current_section;
                CB_FILE (l)->flag_fl_debug = 1;
                break;
            case CB_TAG_FIELD:
                x = cb_ref ($1);
                if (CB_INVALID_TREE (x)) !* {
                    break;
                } *!
                needs_field_debug = 1;
                CB_FIELD (x)->debug_section = current_section;
                CB_FIELD (x)->flag_field_debug = 1;
                CB_PURPOSE (z) = x;
                break;
            default:
                break;
            } *!
        } *!
    } *!
  } *!
| ALL PROCEDURES    !* {
    if (current_program->flag_debugging) !* {
        if (current_program->all_procedure) !* {
            cb_error (_("duplicate USE DEBUGGING ON ALL PROCEDURES"));
        } *! else !* {
            current_program->all_procedure = current_section;
        } *!
    } *!
  } *!
| ALL <_all_refs> <qualified_word>  !* {
    cb_tree     x;

    if (current_program->flag_debugging) !* {   !* Reference must be a data item *!
        x = cb_ref ($3);
        if (CB_INVALID_TREE (x) || C_NOT CB_FIELD_P (x)) !* {
            cb_error (_("invalid target for DEBUGGING ALL"));
        } *! else !* {
            needs_field_debug = 1;
            CB_FIELD (x)->debug_section = current_section;
            CB_FIELD (x)->flag_field_debug = 1;
            CB_FIELD (x)->flag_all_debug = 1;
            CB_REFERENCE ($3)->debug_section = current_section;
            CB_REFERENCE ($3)->flag_debug_code = 1;
            CB_REFERENCE ($3)->flag_all_debug = 1;
            CB_CHAIN_PAIR (current_program->debug_list, x, $3);
        } *!
    } *!
  } *!


<_all_refs>
::=| REFERENCES
| REFERENCES OF
| OF


<use_start_end>
::=  <_at> PROGRAM <program_start_end>  !* {
    if (current_program->nested_level) !* {
        cb_error (_("%s is invalid in nested program"), "USE AT");
    } *!
  } *!


<program_start_end>
::=  START  !* {
    emit_statement (cb_build_comment ("USE AT PROGRAM START")); !* emit_entry ("_START", 0, NULL, NULL); *!
    CB_PENDING ("USE AT PROGRAM START");
  } *!
| END   !* {
    emit_statement (cb_build_comment ("USE AT PROGRAM END"));   !* emit_entry ("_END", 0, NULL, NULL); *!
    CB_PENDING ("USE AT PROGRAM END");
  } *!



<use_reporting>
::=  <use_global> BEFORE REPORTING <identifier> !* {
    current_section->flag_real_label = 1;
    emit_statement (cb_build_comment ("USE BEFORE REPORTING"));
    CB_PENDING ("USE BEFORE REPORTING");
  } *!


<use_exception>
::=  <use_ex_keyw>  !* {
    current_section->flag_real_label = 1;
    emit_statement (cb_build_comment ("USE AFTER EXCEPTION CONDITION"));
    CB_PENDING ("USE AFTER EXCEPTION CONDITION");
  } *!


<use_ex_keyw>
::=  EXCEPTION_CONDITION
| EC

    !* WRITE statement *!

<write_statement>
::=  WRITE  !* {
    begin_statement ("WRITE", TERM_WRITE);  !* Special in debugging mode *!
    save_debug = start_debug;
    start_debug = 0;
  } *!  <write_body>  <end_write>


<write_body>
::=  <file_or_record_name> <from_option> <write_option> <_retry_phrase> <_with_lock> <write_handler>    !* {
    if (CB_VALID_TREE ($1)) !* {
        cb_emit_write ($1, $2, $3, $5);
    } *!
    start_debug = save_debug;
  } *!


<from_option>
::=  !* empty *!            !* { $$ = NULL; } *!
| FROM <from_parameter>     !* { $$ = $2; } *!


<write_option>
::=  !* empty *!    !* {
    $$ = cb_int0;
  } *!
| <before_or_after> <_advancing> <num_id_or_lit> <_line_or_lines>   !* {
    $$ = cb_build_write_advancing_lines ($1, $3);
  } *!
| <before_or_after> <_advancing> <mnemonic_name>    !* {
    $$ = cb_build_write_advancing_mnemonic ($1, $3);
  } *!
| <before_or_after> <_advancing> PAGE   !* {
    $$ = cb_build_write_advancing_page ($1);
  } *!


<before_or_after>
::=  BEFORE         !* { $$ = CB_BEFORE; } *!
| AFTER             !* { $$ = CB_AFTER; } *!


<write_handler>
::=  !* %prec SHIFT_PREFER *!
| <invalid_key_phrases>
| <at_eop_clauses>


<end_write>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    TERMINATOR_WARNING ($-2, WRITE);
  } *!
| END_WRITE !* {
    TERMINATOR_CLEAR ($-2, WRITE);
  } *!


    !* Status handlers *!
    !* ON EXCEPTION *!

<_accept_exception_phrases>
::=  !* %prec SHIFT_PREFER *!
| <accp_on_exception> <_accp_not_on_exception>
| <accp_not_on_exception> <_accp_on_exception>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT EXCEPTION before EXCEPTION"));
    } *!
  } *!


<_accp_on_exception>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <accp_on_exception>   !* {
    $$ = cb_int1;
  } *!


<accp_on_exception>
::=  <escape_or_exception> <statement_list> !* {
    current_statement->handler_type = ACCEPT_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<escape_or_exception>
::=  ESCAPE
| EXCEPTION


<_accp_not_on_exception>
::=  !* %prec SHIFT_PREFER *!
| <accp_not_on_exception>


<accp_not_on_exception>
::=  <not_escape_or_not_exception> <statement_list> !* {
    current_statement->handler_type = ACCEPT_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!


<not_escape_or_not_exception>
::=  NOT_ESCAPE
| NOT_EXCEPTION



<_display_exception_phrases>
::=  !* %prec SHIFT_PREFER *!
| <disp_on_exception> <_disp_not_on_exception>
| <disp_not_on_exception> <_disp_on_exception>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT EXCEPTION before EXCEPTION"));
    } *!
  } *!


<_disp_on_exception>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <disp_on_exception>   !* {
    $$ = cb_int1;
  } *!


<disp_on_exception>
::=  EXCEPTION <statement_list> !* {
    current_statement->handler_type = DISPLAY_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_disp_not_on_exception>
::=  !* %prec SHIFT_PREFER *!
| <disp_not_on_exception>


<disp_not_on_exception>
::=  NOT_EXCEPTION <statement_list> !* {
    current_statement->handler_type = DISPLAY_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!

    !* ON SIZE ERROR *!

<on_size_error_phrases>
::=  !* %prec SHIFT_PREFER *!
| <on_size_error> <_not_on_size_error>
| <not_on_size_error> <_on_size_error>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT SIZE ERROR before SIZE ERROR"));
    } *!
  } *!


<_on_size_error>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <on_size_error>   !* {
    $$ = cb_int1;
  } *!


<on_size_error>
::=  SIZE_ERROR <statement_list>    !* {
    current_statement->handler_type = SIZE_ERROR_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_not_on_size_error>
::=  !* %prec SHIFT_PREFER *!
| <not_on_size_error>


<not_on_size_error>
::=  NOT_SIZE_ERROR <statement_list>    !* {
    current_statement->handler_type = SIZE_ERROR_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!

    !* ON OVERFLOW *!

<_on_overflow_phrases>
::=  !* %prec SHIFT_PREFER *!
| <on_overflow> <_not_on_overflow>
| <not_on_overflow> <_on_overflow>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT OVERFLOW before OVERFLOW"));
    } *!
  } *!


<_on_overflow>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <on_overflow> !* {
    $$ = cb_int1;
  } *!


<on_overflow>
::=  TOK_OVERFLOW <statement_list>  !* {
    current_statement->handler_type = OVERFLOW_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_not_on_overflow>
::=  !* %prec SHIFT_PREFER *!
| <not_on_overflow>


<not_on_overflow>
::=  NOT_OVERFLOW <statement_list>  !* {
    current_statement->handler_type = OVERFLOW_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!


    !* AT END *!

<return_at_end>
::=  <at_end_clause> <_not_at_end_clause>
| <not_at_end_clause> <at_end_clause>   !* {
    cb_verify (cb_not_exception_before_exception, "NOT AT END before AT END");
  } *!


<at_end>
::=  !* %prec SHIFT_PREFER *!  <at_end_clause> <_not_at_end_clause>
| <not_at_end_clause> <_at_end_clause>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception, "NOT AT END before AT END");
    } *!
  } *!


<_at_end_clause>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <at_end_clause>   !* {
    $$ = cb_int1;
  } *!


<at_end_clause>
::=  END <statement_list>   !* {
    current_statement->handler_type = AT_END_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_not_at_end_clause>
::=  !* %prec SHIFT_PREFER *!
| <not_at_end_clause>


<not_at_end_clause>
::=  NOT_END <statement_list>   !* {
    current_statement->handler_type = AT_END_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!

    !* AT EOP *!

<at_eop_clauses>
::=  <at_eop_clause> <_not_at_eop_clause>
| <not_at_eop_clause> <_at_eop_clause>  !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT AT END-OF-PAGE before AT END-OF-PAGE"));
    } *!
  } *!


<_at_eop_clause>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <at_eop_clause>   !* {
    $$ = cb_int1;
  } *!


<at_eop_clause>
::=  EOP <statement_list>   !* {
    current_statement->handler_type = EOP_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_not_at_eop_clause>
::=  !* %prec SHIFT_PREFER *!
| <not_at_eop_clause>


<not_at_eop_clause>
::=  NOT_EOP <statement_list>   !* {
    current_statement->handler_type = EOP_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!

    !* INVALID KEY *!

<_invalid_key_phrases>
::=  !* %prec SHIFT_PREFER *!
| <invalid_key_phrases>


<invalid_key_phrases>
::=  <invalid_key_sentence> <_not_invalid_key_sentence>
| <not_invalid_key_sentence> <_invalid_key_sentence>    !* {
    if ($2) !* {
        cb_verify (cb_not_exception_before_exception,
            _("NOT INVALID KEY before INVALID KEY"));
    } *!
  } *!


<_invalid_key_sentence>
::=  !* %prec SHIFT_PREFER *!   !* {
    $$ = NULL;
  } *!
| <invalid_key_sentence>    !* {
    $$ = cb_int1;
  } *!


<invalid_key_sentence>
::=  INVALID_KEY <statement_list>   !* {
    current_statement->handler_type = INVALID_KEY_HANDLER;
    current_statement->ex_handler = $2;
  } *!


<_not_invalid_key_sentence>
::=  !* %prec SHIFT_PREFER *!
| <not_invalid_key_sentence>


<not_invalid_key_sentence>
::=  NOT_INVALID_KEY <statement_list>   !* {
    current_statement->handler_type = INVALID_KEY_HANDLER;
    current_statement->not_ex_handler = $2;
  } *!

    !* Common Constructs *!

<_scroll_lines>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    $$ = cb_one;
  } *!
| <pos_num_id_or_lit> <scroll_line_or_lines>    !* {
    $$ = $1;
  } *!


    !* Expressions *!

<condition>
::=  <expr> !* {
    $$ = cb_build_cond ($1);
  } *!


<expr>
::=  <partial_expr> !* {
    $$ = cb_build_expr ($1);
  } *!


<partial_expr>
::=  !* {
    current_expr = NULL;
    cb_exp_line = cb_source_line;
  } *!  <expr_tokens>   !* {
    $$ = cb_list_reverse (current_expr);
  } *!


<expr_tokens>
::=  <expr_token>
| <expr_tokens> <expr_token>


<expr_token>
::=  <x>                !* { push_expr ('x', $1); } *!
! splitted into two cases for GOLDParser as <condition_or_class> can contain COBOLWord --> <x>
| IS <CLASS_NAME>       
| <_is> <condition_op>       
  !* This case is separate because <_is> <_not> causes a shift/reduce error. *!
| IS <not> <condition_or_class>
  !* This case is not in condition_or_class as x contains ZERO. *!
| IS <_not> ZERO        !* { push_expr ('x', cb_zero); } *!
  !* Parentheses *!
| TOK_OPEN_PAREN        !* { push_expr ('(', NULL); } *!
| TOK_CLOSE_PAREN       !* { push_expr (')', NULL); } *!
  !* Arithmetic operators *!
| TOK_PLUS              !* { push_expr ('+', NULL); } *!
| TOK_MINUS             !* { push_expr ('-', NULL); } *!
| TOK_MUL               !* { push_expr ('*', NULL); } *!
| TOK_DIV               !* { push_expr ('/', NULL); } *!
| EXPONENTIATION        !* { push_expr ('^', NULL); } *!
  !* Logical operators *!
| <not>
| AND                   !* { push_expr ('&', NULL); } *!
| OR                    !* { push_expr ('|', NULL); } *!


<_not>
::=  !* empty *!
| <not>


<not>
::=  NOT                !* { push_expr (C_EXCL_LIT, NULL); } *!

<condition_or_class>
::=  <CLASS_NAME>         !* { push_expr ('C', $1); } *!
  | <condition_op>

<condition_op>
  !* Conditional operators *!
::= <eq>              !* { push_expr ('=', NULL); } *!
  | <gt>              !* { push_expr ('>', NULL); } *!
  | <lt>              !* { push_expr ('<', NULL); } *!
  | <ge>              !* { push_expr (']', NULL); } *!
  | <le>              !* { push_expr ('[', NULL); } *!
  | NOT_EQUAL         !* { push_expr ('~', NULL); } *!
  !* Class condition: *!
  | OMITTED           !* { push_expr ('O', NULL); } *!
  | NUMERIC           !* { push_expr ('9', NULL); } *!
  | ALPHABETIC            !* { push_expr ('A', NULL); } *!
  | ALPHABETIC_LOWER      !* { push_expr ('L', NULL); } *!
  | ALPHABETIC_UPPER      !* { push_expr ('U', NULL); } *!
  !* Sign condition: *!    !* Note: ZERO is defined in 'x' *!
  | POSITIVE          !* { push_expr ('P', NULL); } *!
  | NEGATIVE          !* { push_expr ('N', NULL); } *!


<eq>
::=  TOK_EQUAL
| EQUAL <_to>


<gt>
::=  TOK_GREATER
| GREATER


<lt>
::=  TOK_LESS
| LESS


<ge>
::=  GREATER_OR_EQUAL


<le>
::=  LESS_OR_EQUAL

    !* Arithmetic expression *!

<exp_list>
::=  <exp> !* %prec SHIFT_PREFER *! !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <exp_list> <_e_sep> <exp> !* %prec SHIFT_PREFER *!    !* {
    $$ = cb_list_add ($1, $3);
  } *!


<_e_sep>
::=| COMMA_DELIM
| SEMI_COLON


<exp>
::=  <exp> TOK_PLUS <exp_term>      !* { $$ = cb_build_binary_op ($1, '+', $3); } *!
| <exp> TOK_MINUS <exp_term>    !* { $$ = cb_build_binary_op ($1, '-', $3); } *!
| <exp_term>            !* { $$ = $1; } *!


<exp_term>
::=  <exp_term> TOK_MUL <exp_factor>    !* { $$ = cb_build_binary_op ($1, '*', $3); } *!
| <exp_term> TOK_DIV <exp_factor>   !* { $$ = cb_build_binary_op ($1, '/', $3); } *!
| <exp_factor>          !* { $$ = $1; } *!


<exp_factor>
::=  <exp_unary> EXPONENTIATION <exp_factor>    !* {
    $$ = cb_build_binary_op ($1, '^', $3);
  } *!
| <exp_unary>           !* { $$ = $1; } *!


<exp_unary>
::=  TOK_PLUS <exp_atom>        !* { $$ = $2; } *!
| TOK_MINUS <exp_atom>      !* { $$ = cb_build_binary_op (cb_zero, '-', $2); } *!
| <exp_atom>            !* { $$ = $1; } *!

<exp_atom>
::=  TOK_OPEN_PAREN <exp> TOK_CLOSE_PAREN   !* { $$ = $2; } *!
| <arith_x>             !* { $$ = $1; } *!



    !* Names *!
    !* LINAGE-COUNTER LINE-COUNTER PAGE-COUNTER *!

<line_linage_page_counter>
::=  LINAGE_COUNTER !* {
    if (current_linage > 1) !* {
        cb_error (_("LINAGE-COUNTER must be qualified here"));
        $$ = cb_error_node;
    } *! else if (current_linage == 0) !* {
        cb_error (_("invalid LINAGE-COUNTER usage"));
        $$ = cb_error_node;
    } *! else !* {
        $$ = linage_file->linage_ctr;
    } *!
  } *!
| LINAGE_COUNTER <in_of> <WORD>   !* {
    if (CB_FILE_P (cb_ref ($3))) !* {
        $$ = CB_FILE (cb_ref ($3))->linage_ctr;
    } *! else !* {
        cb_error_x ($3, _("'%s' is not a file name"), CB_NAME ($3));
        $$ = cb_error_node;
    } *!
  } *!
| LINE_COUNTER  !* {
    if (report_count > 1) !* {
        cb_error (_("LINE-COUNTER must be qualified here"));
        $$ = cb_error_node;
    } *! else if (report_count == 0) !* {
        cb_error (_("invalid LINE-COUNTER usage"));
        $$ = cb_error_node;
    } *! else !* {
        $$ = report_instance->line_counter;
    } *!
  } *!
| LINE_COUNTER <in_of> <WORD> !* {
    if (CB_REPORT_P (cb_ref ($3))) !* {
        $$ = CB_REPORT (cb_ref ($3))->line_counter;
    } *! else !* {
        cb_error_x ($3, _("'%s' is not a report name"), CB_NAME ($3));
        $$ = cb_error_node;
    } *!
  } *!
| PAGE_COUNTER  !* {
    if (report_count > 1) !* {
        cb_error (_("PAGE-COUNTER must be qualified here"));
        $$ = cb_error_node;
    } *! else if (report_count == 0) !* {
        cb_error (_("invalid PAGE-COUNTER usage"));
        $$ = cb_error_node;
    } *! else !* {
        $$ = report_instance->page_counter;
    } *!
  } *!
| PAGE_COUNTER <in_of> <WORD> !* {
    if (CB_REPORT_P (cb_ref ($3))) !* {
        $$ = CB_REPORT (cb_ref ($3))->page_counter;
    } *! else !* {
        cb_error_x ($3, _("'%s' is not a report name"), CB_NAME ($3));
        $$ = cb_error_node;
    } *!
  } *!


    !* Data name *!

<arithmetic_x_list>
::=  <arithmetic_x>         !* { $$ = $1; } *!
| <arithmetic_x_list>  <arithmetic_x>           !* { $$ = cb_list_append ($1, $2); } *!


<arithmetic_x>
::=  <target_x> <flag_rounded>  !* {
    $$ = CB_BUILD_PAIR ($2, $1);
  } *!

    !* Record name *!

<record_name>
::=  <qualified_word>       !* { cb_build_identifier ($1, 0); } *!

    !* FILE name -or- Record-name *!

<file_or_record_name>
::=  <record_name>  !* {
    if (C_NOT CB_FILE_P (cb_ref ($1))) !* {
        $$ = $1;
    } *! else !* {
        cb_error_x ($1, _("%s requires a record name as subject"),
            current_statement->name);
        $$ = cb_error_node;
    } *!
  } *!
| TOK_FILE <WORD> !* {
    if (CB_FILE_P (cb_ref ($2))) !* {
        $$ = $2;
    } *! else !* {
        cb_error_x ($2, _("'%s' is not a file name"), CB_NAME ($2));
        $$ = cb_error_node;
    } *!
  } *!

    !* Table name *!

<table_name>
::=  <qualified_word>   !* {
    cb_tree x;

    x = cb_ref ($1);
    if (C_NOT CB_FIELD_P (x)) !* {
        $$ = cb_error_node;
    } *! else if (C_NOT CB_FIELD (x)->index_list) !* {
        cb_error_x ($1, _("'%s' not indexed"), cb_name ($1));
        listprint_suppress ();
        cb_error_x (x, _("'%s' defined here"), cb_name (x));
        listprint_restore ();
        $$ = cb_error_node;
    } *! else !* {
        $$ = $1;
    } *!
  } *!

    !* File name *!

<file_name_list>
::=  <file_name>    !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <file_name_list> <file_name>  !* {
    cb_tree     l;

    if (CB_VALID_TREE ($2)) !* {
        for (l = $1; l; l = CB_CHAIN (l)) !* {
            if (CB_VALID_TREE (CB_VALUE (l)) &&
                C_NOT strcasecmp (CB_NAME ($2), CB_NAME (CB_VALUE (l)))) !* {
                cb_error_x ($2, _("multiple reference to '%s' "),
                        CB_NAME ($2));
                break;
            } *!
        } *!
        if (C_NOT l) !* {
            $$ = cb_list_add ($1, $2);
        } *!
    } *!
  } *!


<file_name>
::=  <WORD>   !* {
    if (CB_FILE_P (cb_ref ($1))) !* {
        $$ = $1;
    } *! else !* {
        cb_error_x ($1, _("'%s' is not a file name"), CB_NAME ($1));
        $$ = cb_error_node;
    } *!
  } *!


<cd_name>
::=  <WORD>   !* {
    if (CB_CD_P (cb_ref ($1))) !* {
        $$ = $1;
    } *! else !* {
        cb_error_x ($1, _("'%s' is not a CD name"), CB_NAME ($1));
        $$ = cb_error_node;
    } *!
  } *!

    !* Report name *!
    !* RXWRXW - Report list
<report_name_list>
::=  <report_name>  !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <report_name_list> <report_name>  !* {
    cb_tree     l;

    if (CB_VALID_TREE ($2)) !* {
        for (l = $1; l; l = CB_CHAIN (l)) !* {
            if (CB_VALID_TREE (CB_VALUE (l)) &&
                C_NOT strcasecmp (CB_NAME ($2), CB_NAME (CB_VALUE (l)))) !* {
                cb_error_x ($2, _("multiple reference to '%s' "),
                        CB_NAME ($2));
                break;
            } *!
        } *!
        if (C_NOT l) !* {
            $$ = cb_list_add ($1, $2);
        } *!
    } *!
  } *!

*!

<report_name>
::=  <WORD>   !* {
    if (CB_REPORT_P (cb_ref ($1))) !* {
        $$ = $1;
    } *! else !* {
        cb_error_x ($1, _("'%s' is not a report name"), CB_NAME ($1));
        $$ = cb_error_node;
    } *!
  } *!

    !* Mnemonic name *!

<mnemonic_name_list>
::=  <mnemonic_name>            !* { $$ = CB_LIST_INIT ($1); } *!
| <mnemonic_name_list>  <mnemonic_name>         !* { $$ = cb_list_add ($1, $2); } *!


<mnemonic_name>
::=  <MNEMONIC_NAME_TOK>          !* { $$ = $1; } *!

    !* Procedure name *!

<procedure_name_list>
::=  !* empty *!            !* { $$ = NULL; } *!
| <procedure_name_list>  <procedure_name>       !* { $$ = cb_list_add ($1, $2); } *!


<procedure_name>
::=  <label>    !* {
    $$ = $1;
    CB_REFERENCE ($$)->offset = CB_TREE (current_section);
    CB_REFERENCE ($$)->flag_in_decl = C_MAKE_BOOL in_declaratives;
    CB_REFERENCE ($$)->section = current_section;
    CB_REFERENCE ($$)->paragraph = current_paragraph;
    CB_ADD_TO_CHAIN ($$, current_program->label_list);
  } *!


<label>
::=  <qualified_word>
| <integer_label>
| <integer_label> <in_of> <integer_label>   !* {
    CB_REFERENCE ($1)->chain = $3;
  } *!


<integer_label>
::=  <LITERAL_TOK>    !* {
    $$ = cb_build_reference ((char *)(CB_LITERAL ($1)->data));
    $$->source_file = $1->source_file;
    $$->source_line = $1->source_line;
  } *!

    !* Reference *!

<reference_list>
::=  <reference>            !* { $$ = CB_LIST_INIT ($1); } *!
| <reference_list> <reference>  !* { $$ = cb_list_add ($1, $2); } *!


<reference>
::=  <qualified_word>   !* {
    $$ = $1;
    CB_ADD_TO_CHAIN ($$, current_program->reference_list);
  } *!


<single_reference>
::=  <WORD>   !* {
    $$ = $1;
    CB_ADD_TO_CHAIN ($$, current_program->reference_list);
  } *!


<optional_reference_list>
::=  <optional_reference>   !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <optional_reference_list> <optional_reference>    !* {
    $$ = cb_list_add ($1, $2);
  } *!


<optional_reference>
::=  <WORD>   !* {
    $$ = $1;
    CB_REFERENCE($$)->flag_optional = 1;
    CB_ADD_TO_CHAIN ($$, current_program->reference_list);
  } *!


<reference_or_literal>
::=  <reference>
| <LITERAL_TOK>

    !* Undefined word *!

<undefined_word>
::=  <WORD>   !* {
    if (CB_WORD_COUNT ($1) > 0) !* {
        redefinition_error ($1);
        $$ = cb_error_node;
    } *! else !* {
        $$ = $1;
    } *!
  } *!
!bison error token | <error>   
!* {
    yyclearin;
    yyerrok;
    $$ = cb_error_node;
  } *!

    !* Unique word *!

<unique_word>
::=  <WORD>   !* {
    if (CB_REFERENCE ($1)->flag_duped || CB_WORD_COUNT ($1) > 0) !* {
        redefinition_error ($1);
        $$ = NULL;
    } *! else !* {
        CB_WORD_COUNT ($1)++;
        $$ = $1;
    } *!
  } *!

    !* Primitive elements *!
    !* Primitive value *!

<target_x_list>
::=  <target_x> !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <target_x_list> <target_x>    !* {
    $$ = cb_list_add ($1, $2);
  } *!


<target_x>
::=  <target_identifier>
| <basic_literal>
| ADDRESS <_of> <identifier_1>  !* {
    $$ = cb_build_address ($3);
  } *!
| COMMA_DELIM !* HACK, should not reach parser *!


<_x_list>
::=  !* empty *!    !* { $$ = NULL; } *!
| <x_list>  !* { $$ = $1; } *!


<x_list>
::=  <x>    !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <x_list> <x>  !* {
    $$ = cb_list_add ($1, $2);
  } *!


<x>
::=  <identifier>
| <x_common>
| COMMA_DELIM !* HACK, should not reach parser *!


<call_x>
::=  <identifier_or_file_name>
| <x_common>


<x_common>
::=  <literal>
| <function>
| <line_linage_page_counter>
| LENGTH_OF <identifier_1>  !* {
    $$ = cb_build_length ($2);
  } *!
| LENGTH_OF <basic_literal> !* {
    $$ = cb_build_length ($2);
  } *!
| LENGTH_OF <function>  !* {
    $$ = cb_build_length ($2);
  } *!
| ADDRESS <_of> <prog_or_entry> <alnum_or_id>   !* {
    $$ = cb_build_ppointer ($4);
  } *!
| ADDRESS <_of> <identifier_1>  !* {
    $$ = cb_build_address ($3);
  } *!
| <MNEMONIC_NAME_TOK> !* {
    cb_tree     x;
    cb_tree     switch_id;

    x = cb_ref ($1);
    if (CB_VALID_TREE (x)) !* {
        if (CB_SYSTEM_NAME (x)->category <> CB_SWITCH_NAME) !* {
            cb_error_x ($1, _("invalid mnemonic identifier"));
            $$ = cb_error_node;
        } *! else !* {
            switch_id = cb_int (CB_SYSTEM_NAME (x)->token);
            $$ = CB_BUILD_FUNCALL_1 ("cob_switch_value", switch_id);
        } *!
    } *! else !* {
        $$ = cb_error_node;
    } *!
  } *!


<report_x_list>
::=  <arith_x>  !* {
    $$ = CB_LIST_INIT ($1);
  } *!
| <report_x_list> <arith_x> !* {
    $$ = cb_list_add ($1, $2);
  } *!


<expr_x>
::=  <identifier>
| <basic_literal>
| <function>


<arith_x>
::=  <identifier>
| <basic_literal>
| <function>
| <line_linage_page_counter>
| LENGTH_OF <identifier_1>  !* {
    $$ = cb_build_length ($2);
  } *!
| LENGTH_OF <basic_literal> !* {
    $$ = cb_build_length ($2);
  } *!
| LENGTH_OF <function>  !* {
    $$ = cb_build_length ($2);
  } *!


<prog_or_entry>
::=  PROGRAM
| ENTRY


<alnum_or_id>
::=  <identifier_1>
| <LITERAL_TOK>


<simple_display_value>
::=  <simple_value> !* {
    error_if_not_usage_display_or_nonnumeric_lit ($1);
  } *!


<simple_display_all_value>
::=  <simple_all_value> !* {
    error_if_not_usage_display_or_nonnumeric_lit ($1);
  } *!


<simple_value>
::=  <identifier>
| <basic_literal>
| <function>


<simple_all_value>
::=  <identifier>
| <literal>


<id_or_lit>
::=  <identifier>   !* {
    check_not_88_level ($1);
  } *!
| <LITERAL_TOK>


<id_or_lit_or_func>
::=  <identifier>   !* {
    check_not_88_level ($1);
  } *!
| <LITERAL_TOK>
| <function>


<id_or_lit_or_length_or_func>
::=  <identifier>   !* {
    check_not_88_level ($1);
  } *!
| <lit_or_length>
| <function>


<num_id_or_lit>
::=  <sub_identifier>   !* {
    check_not_88_level ($1);
  } *!
| <integer>
| ZERO  !* {
    $$ = cb_zero;
  } *!


<positive_id_or_lit>
::=  <sub_identifier>   !* {
    check_not_88_level ($1);
  } *!
| <report_integer>


<pos_num_id_or_lit>
::=  <sub_identifier>   !* {
    check_not_88_level ($1);
  } *!
| <integer>


<from_parameter>
::=  <identifier>   !* {
    check_not_88_level ($1);
  } *!
| <literal>
| <function>

    !* Identifier *!

<sub_identifier>
::=  <sub_identifier_1>     !* { $$ = cb_build_identifier ($1, 0); } *!


<table_identifier>
::=  <sub_identifier_1>     !* { $$ = cb_build_identifier ($1, 1); } *!


<sub_identifier_1>
::=  <qualified_word>       !* { $$ = $1; } *!
| <qualified_word> <subref>     !* { $$ = $1; } *!


<display_identifier>
::=  <identifier>   !* {
    error_if_not_usage_display_or_nonnumeric_lit ($1);
  } *!


<numeric_identifier>
::=  <identifier>   !* {
    if ($1 <> cb_error_node
        && cb_tree_category ($1) <> CB_CATEGORY_NUMERIC) !* {
        cb_error_x ($1, _("'%s' is not numeric"), cb_name ($1));
    } *!
  } *!


<identifier_or_file_name>
::=  <identifier_1> !* {
    int     reference_to_existing_object;

    if (CB_REFERENCE_P ($1) && (CB_FIELD_P (cb_ref ($1))
                    || CB_FILE_P (cb_ref ($1)))) !* {
        $$ = cb_build_identifier ($1, 0);
    } *! else !* {
        reference_to_existing_object =
            CB_REFERENCE_P ($1) && cb_ref ($1) <> cb_error_node;
        if (C_NOT CB_REFERENCE_P ($1) || reference_to_existing_object) !* {
            cb_error_x ($1, _("'%s' is not a field or file"), cb_name ($1));
        } *!
        $$ = cb_error_node;
    } *!
  } *!


<identifier>
::=  <identifier_1> !* {
    int     reference_to_existing_object;

    if (CB_REFERENCE_P ($1) && CB_FIELD_P (cb_ref ($1))) !* {
        $$ = cb_build_identifier ($1, 0);
    } *! else !* {
        reference_to_existing_object =
            CB_REFERENCE_P ($1) && cb_ref ($1) <> cb_error_node;
        if (C_NOT CB_REFERENCE_P ($1) || reference_to_existing_object) !* {
            cb_error_x ($1, _("'%s' is not a field"), cb_name ($1));
        } *!
        $$ = cb_error_node;
    } *!
  } *!


<identifier_1>
::=  <qualified_word> <subref> <refmod> !* {
    $$ = $1;
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> <subref> !* %prec SHIFT_PREFER *!    !* {
    $$ = $1;
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> <refmod> !* {
    $$ = $1;
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> !* %prec SHIFT_PREFER *! !* {
    $$ = $1;
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!


<target_identifier>
::=  <target_identifier_1>  !* {
    $$ = cb_build_identifier ($1, 0);
  } *!


<target_identifier_1>
::=  <qualified_word> <subref> <refmod> !* {
    $$ = $1;
    if (CB_REFERENCE_P ($1)) !* {
        CB_REFERENCE ($1)->flag_target = 1;
    } *!
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> <subref> !* %prec SHIFT_PREFER *!    !* {
    $$ = $1;
    if (CB_REFERENCE_P ($1)) !* {
        CB_REFERENCE ($1)->flag_target = 1;
    } *!
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> <refmod> !* {
    $$ = $1;
    if (CB_REFERENCE_P ($1)) !* {
        CB_REFERENCE ($1)->flag_target = 1;
    } *!
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!
| <qualified_word> !* %prec SHIFT_PREFER *! !* {
    $$ = $1;
    if (CB_REFERENCE_P ($1)) !* {
        CB_REFERENCE ($1)->flag_target = 1;
    } *!
    if (start_debug) !* {
        cb_check_field_debug ($1);
    } *!
  } *!


<qualified_word>
::=  <WORD>   !* {
    $$ = $1;
  } *!
| <WORD> <in_of> <qualified_word> !* {
    $$ = $1;
    CB_REFERENCE ($1)->chain = $3;
  } *!


<subref>
::=  TOK_OPEN_PAREN <exp_list> TOK_CLOSE_PAREN  !* {
    $$ = $0;
    CB_REFERENCE ($0)->subs = cb_list_reverse ($2);
  } *!


<refmod>
::=  TOK_OPEN_PAREN <exp> TOK_COLON TOK_CLOSE_PAREN !* {
    CB_REFERENCE ($0)->offset = $2;
  } *!
| TOK_OPEN_PAREN <exp> TOK_COLON <exp> TOK_CLOSE_PAREN  !* {
    CB_REFERENCE ($0)->offset = $2;
    CB_REFERENCE ($0)->length = $4;
  } *!

    !* Literal *!

<integer> ! changed for GOLD Parser:
::= IntLiteral
!|   COBOLWord ! because of CONSTANT / lvl-78 items, maybe moved to preparser [raises a reduce-reduce-conflict here]
! <LITERAL_TOK>
!* %prec SHIFT_PREFER *!   !* {
    if (cb_tree_category ($1) <> CB_CATEGORY_NUMERIC
        || CB_LITERAL ($1)->sign < 0
        || CB_LITERAL ($1)->scale) !* {
        cb_error (_("non-negative integer value expected"));
        $$ = cb_build_numeric_literal(-1, "1", 0);
    } *! else !* {
        $$ = $1;
    } *!
  } *!


<symbolic_integer> ! changed for GOLD Parser:
::= IntLiteral
!|   COBOLWord ! because of CONSTANT / lvl-78 items, maybe moved to preparser
! <LITERAL_TOK>
!* {
    int n;

    if (cb_tree_category ($1) <> CB_CATEGORY_NUMERIC) !* {
        cb_error (_("integer value expected"));
        $$ = cb_int1;
    } *! else if (CB_LITERAL ($1)->sign || CB_LITERAL ($1)->scale) !* {
        cb_error (_("integer value expected"));
        $$ = cb_int1;
    } *! else !* {
        n = cb_get_int ($1);
        if (n < 1 || n > 256) !* {
            cb_error (_("invalid symbolic integer"));
            $$ = cb_int1;
        } *! else !* {
            $$ = $1;
        } *!
    } *!
  } *!


<report_integer> ! changed for GOLD Parser:
::= IntLiteral
!|   COBOLWord ! because of CONSTANT / lvl-78 items, maybe moved to preparser
! <LITERAL_TOK>
!* {
    int n;

    if (cb_tree_category ($1) <> CB_CATEGORY_NUMERIC
        || CB_LITERAL ($1)->sign
        || CB_LITERAL ($1)->scale) !* {
        cb_error (_("unsigned positive integer value expected"));
        $$ = cb_int1;
    } *! else !* {
        n = cb_get_int ($1);
        if (n < 1) !* {
            cb_error (_("unsigned positive integer value expected"));
            $$ = cb_int1;
        } *! else !* {
            $$ = $1;
        } *!
    } *!
  } *!


<class_value>
::=  <LITERAL_TOK>
!* {
    int n;

    if (cb_tree_category ($1) == CB_CATEGORY_NUMERIC) !* {
        if (CB_LITERAL ($1)->sign || CB_LITERAL ($1)->scale) !* {
            cb_error (_("integer value expected"));
        } *! else !* {
            n = cb_get_int ($1);
            if (n < 1 || n > 256) !* {
                cb_error (_("invalid CLASS value"));
            } *!
        } *!
    } *!
    $$ = $1;
  } *!
| SPACE             !* { $$ = cb_space; } *!
| ZERO              !* { $$ = cb_zero; } *!
| QUOTE             !* { $$ = cb_quote; } *!
| HIGH_VALUE            !* { $$ = cb_high; } *!
| LOW_VALUE         !* { $$ = cb_low; } *!
| TOK_NULL          !* { $$ = cb_null; } *!


<literal>
::=  <basic_literal>
!* {
    $$ = $1;
  } *!
| ALL <basic_value>
!* {
    struct cb_literal   *l;

    if (CB_LITERAL_P ($2)) !* { !* We must not alter the original definition *!
        l = cobc_parse_malloc (sizeof(struct cb_literal));
        *l = *(CB_LITERAL($2));
        l->all = 1;
        $$ = CB_TREE (l);
    } *! else !* {
        $$ = $2;
    } *!
  } *!


<basic_literal>
::=  <basic_value>
!* {
    $$ = $1;
  } *!
| <basic_literal> TOK_AMPER <basic_value>
!* {
    $$ = cb_concat_literals ($1, $3);
  } *!


<basic_value>
::=  <LITERAL_TOK>            !* { $$ = $1; } *!
| SPACE             !* { $$ = cb_space; } *!
| ZERO              !* { $$ = cb_zero; } *!
| QUOTE             !* { $$ = cb_quote; } *!
| HIGH_VALUE            !* { $$ = cb_high; } *!
| LOW_VALUE         !* { $$ = cb_low; } *!
| TOK_NULL          !* { $$ = cb_null; } *!

    !* Function *!

<function>
::=  <func_no_parm> <func_refmod>   !* {
    $$ = cb_build_intrinsic ($1, NULL, $2, 0);
  } *!
| <func_one_parm> TOK_OPEN_PAREN <expr_x> TOK_CLOSE_PAREN <func_refmod> !* {
    $$ = cb_build_intrinsic ($1, CB_LIST_INIT ($3), $5, 0);
  } *!
| <func_multi_parm> TOK_OPEN_PAREN <exp_list> TOK_CLOSE_PAREN <func_refmod> !* {
    $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <TRIM_FUNC> TOK_OPEN_PAREN <trim_args> TOK_CLOSE_PAREN <func_refmod>    !* {
    $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <LENGTH_FUNC> TOK_OPEN_PAREN <length_arg> TOK_CLOSE_PAREN   !* {
    $$ = cb_build_intrinsic ($1, $3, NULL, 0);
  } *!
| <NUMVALC_FUNC> TOK_OPEN_PAREN <numvalc_args> TOK_CLOSE_PAREN    !* {
    $$ = cb_build_intrinsic ($1, $3, NULL, 0);
  } *!
| <LOCALE_DATE_FUNC> TOK_OPEN_PAREN <locale_dt_args> TOK_CLOSE_PAREN <func_refmod>    !* {
    $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <LOCALE_TIME_FUNC> TOK_OPEN_PAREN <locale_dt_args> TOK_CLOSE_PAREN <func_refmod>    !* {
    $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <LOCALE_TIME_FROM_FUNC> TOK_OPEN_PAREN <locale_dt_args> TOK_CLOSE_PAREN <func_refmod>   !* {
    $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <FORMATTED_DATETIME_FUNC> TOK_OPEN_PAREN <formatted_datetime_args> TOK_CLOSE_PAREN <func_refmod>    !* {
      $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <FORMATTED_TIME_FUNC> TOK_OPEN_PAREN <formatted_time_args> TOK_CLOSE_PAREN <func_refmod>    !* {
      $$ = cb_build_intrinsic ($1, $3, $5, 0);
  } *!
| <FUNCTION_NAME> <func_args> !* {
    $$ = cb_build_intrinsic ($1, $2, NULL, 0);
  } *!
| <USER_FUNCTION_NAME> <func_args>    !* {
    $$ = cb_build_intrinsic ($1, $2, NULL, 1);
  } *!
! not in GnuCOBOL parser.y as these aren't implemented, yet:
| <DISPLAY_OF_FUNC> <func_args>
| <NATIONAL_OF_FUNC> <func_args>

<func_no_parm>
::=  <CURRENT_DATE_FUNC>
| <WHEN_COMPILED_FUNC>


<func_one_parm>
::=  <UPPER_CASE_FUNC>
| <LOWER_CASE_FUNC>
| <REVERSE_FUNC>


<func_multi_parm>
::=  <CONCATENATE_FUNC>
| <FORMATTED_DATE_FUNC>
| <SUBSTITUTE_FUNC>
| <SUBSTITUTE_CASE_FUNC>


<func_refmod>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    $$ = NULL;
  } *!
| TOK_OPEN_PAREN <exp> TOK_COLON TOK_CLOSE_PAREN    !* {
    $$ = CB_BUILD_PAIR ($2, NULL);
  } *!
| TOK_OPEN_PAREN <exp> TOK_COLON <exp> TOK_CLOSE_PAREN  !* {
    $$ = CB_BUILD_PAIR ($2, $4);
  } *!


<func_args>
::=  !* empty *!    !* %prec SHIFT_PREFER *!    !* {
    $$ = NULL;
  } *!
| TOK_OPEN_PAREN <exp_list> TOK_CLOSE_PAREN !* {
    $$ = $2;
  } *!
| TOK_OPEN_PAREN TOK_CLOSE_PAREN    !* {
    $$ = NULL;
  } *!


<trim_args>
::=  <expr_x>   !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_int0);
  } *!
| <expr_x> <_e_sep> LEADING !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_int1);
  } *!
| <expr_x> <_e_sep> TRAILING    !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_int2);
  } *!


<length_arg>
::=  !* {
    suppress_data_exceptions = 1;
  } *!  <expr_x>    !* {
    suppress_data_exceptions = 0;
    $$ = CB_LIST_INIT ($2);
  } *!


<numvalc_args>
::=  <expr_x>   !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_null);
  } *!
| <expr_x> <_e_sep> <expr_x>    !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, $3);
  } *!


<locale_dt_args>
::=  <exp>  !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_null);
  } *!
| <exp> <_e_sep> <reference>    !* {
    cb_tree x;

    x = CB_LIST_INIT ($1);
    $$ = cb_list_add (x, cb_ref ($3));
  } *!


<formatted_datetime_args>
::=  <exp_list> !* {
    $$ = cb_list_add ($1, cb_int0);
  } *!
| <exp_list> <_e_sep> SYSTEM_OFFSET !* {
    const int   num_args = cb_list_length ($1);

    if (num_args == 4) !* {
        cb_error_x ($1, _("cannot specify offset and SYSTEM-OFFSET at the same time"));
    } *!

    $$ = cb_list_add ($1, cb_int1);
  } *!


<formatted_time_args>
::=  <exp_list> !* {
    $$ = cb_list_add ($1, cb_int0);
  } *!
| <exp_list> <_e_sep> SYSTEM_OFFSET !* {
    const int   num_args = cb_list_length ($1);

    if (num_args == 3) !* {
        cb_error_x ($1, _("cannot specify offset and SYSTEM-OFFSET at the same time"));
    } *!

    $$ = cb_list_add ($1, cb_int1);
  } *!

    !* Common rules *!

!* not relevant for GOLDParser grammar
<not_const_word>
::=  !* {
    non_const_word = 1;
  } *!
*!

    !* Common flags *!

<flag_all>
::=  !* empty *!            !* { $$ = cb_int0; } *!
| ALL               !* { $$ = cb_int1; } *!


<flag_duplicates>
::=  !* empty *!            !* { $$ = cb_int0; } *!
| <with_dups>           !* { $$ = cb_int1; } *!


<flag_initialized>
::=  !* empty *!            !* { $$ = NULL; } *!
| INITIALIZED           !* { $$ = cb_int1; } *!


<flag_initialized_to>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| INITIALIZED <to_init_val> !* {
    $$ = $2;
  } *!


<to_init_val>
::=  !* empty *!    !* {
    $$ = NULL;
  } *!
| TO <simple_all_value> !* {
    $$ = $2;
  } *!


<_flag_next>
::=  !* %prec SHIFT_PREFER *!   !* empty *!         !* { $$ = cb_int0; } *!
| NEXT              !* { $$ = cb_int1; } *!
| PREVIOUS          !* { $$ = cb_int2; } *!


<_flag_not>
::=  !* empty *!            !* { $$ = NULL; } *!
| NOT               !* { $$ = cb_true; } *!


<flag_optional>
::=  !* empty *!            !* { $$ = cb_int (cb_flag_optional_file); } *!
| OPTIONAL          !* { $$ = cb_int1; } *!
| NOT OPTIONAL          !* { $$ = cb_int0; } *!


<flag_rounded>
::=  !* empty *!    !* {
    $$ = cb_int0;
  } *!
| ROUNDED <round_mode>  !* {
    if ($2) !* {
        $$ = $2;
    } *! else !* {
        $$ = default_rounded_mode;
    } *!
    cobc_cs_check = 0;
  } *!


<round_mode>
::=  !* empty *!    !* {
    $$ = NULL;
    cobc_cs_check = 0;
  } *!
| MODE <_is> <round_choice> !* {
    $$ = $3;
    cobc_cs_check = 0;
  } *!


<round_choice>
::=  AWAY_FROM_ZERO !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_AWAY_FROM_ZERO);
  } *!
| NEAREST_AWAY_FROM_ZERO    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_NEAR_AWAY_FROM_ZERO);
  } *!
| NEAREST_EVEN  !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_NEAR_EVEN);
  } *!
| NEAREST_TOWARD_ZERO   !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_NEAR_TOWARD_ZERO);
  } *!
| PROHIBITED    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_PROHIBITED);
  } *!
| TOWARD_GREATER    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_TOWARD_GREATER);
  } *!
| TOWARD_LESSER !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_TOWARD_LESSER);
  } *!
| TRUNCATION    !* {
    $$ = cb_int (COB_STORE_ROUND | COB_STORE_TRUNCATION);
  } *!


<flag_separate>
::=  !* empty *!            !* { $$ = NULL; } *!
| SEPARATE <_character>     !* { $$ = cb_int1; } *!


<_from_idx_to_idx>
::=!* empty *!          !* { $$ = NULL; } *!
| FROM <_index> <pos_num_id_or_lit> TO <pos_num_id_or_lit>  !* {
    cb_tree x;

    x = CB_LIST_INIT ($2);
    $$ = cb_list_add (x, $4);
  } *!


<_dest_index>
::=!* empty *!          !* { $$ = NULL; } *!
| DESTINATION <_index> <pos_num_id_or_lit>  !* {
    $$ = $3;
  } *!

    !* Error recovery *!

<error_stmt_recover>
::=  TOK_DOT    !* {
    cobc_repeat_last_token = 1;
  } *!
| <verb>    !* {
    cobc_repeat_last_token = 1;
  } *!
| <scope_terminator>    !* {
    cobc_repeat_last_token = 0;
  } *!


<verb>
::=  ACCEPT
| ADD
| ALLOCATE
| ALTER
| CALL
| CANCEL
| CLOSE
| COMMIT
| COMPUTE
| CONTINUE
| DELETE
| DISPLAY
| DIVIDE
| ELSE
| ENTRY
| EVALUATE
| EXIT
| FREE
| GENERATE
| GO
| GOBACK
| IF
| INITIALIZE
| INITIATE
| INSPECT
| MERGE
| MOVE
| MULTIPLY
| NEXT
| OPEN
| PERFORM
| READ
| RELEASE
| RETURN
| REWRITE
| ROLLBACK
| SEARCH
| SET
| SORT
| START
| STOP
| STRING
| SUBTRACT
| SUPPRESS
| TERMINATE
| TRANSFORM
| UNLOCK
| UNSTRING
| WRITE


<scope_terminator>
::=  END_ACCEPT
| END_ADD
| END_CALL
| END_COMPUTE
| END_DELETE
| END_DISPLAY
| END_DIVIDE
| END_EVALUATE
| END_IF
| END_MULTIPLY
| END_PERFORM
| END_READ
| END_RECEIVE
| END_RETURN
| END_REWRITE
| END_SEARCH
| END_START
| END_STRING
| END_SUBTRACT
| END_UNSTRING
| END_WRITE

    !* Mandatory/Optional keyword selection without actions *!
    !* Optional selection *!

<_advancing> ::=    | ADVANCING
<_after> ::=        | AFTER
<_are> ::=      | ARE
<_area> ::=     | AREA
<_areas> ::=        | AREA | AREAS
<_as> ::=       | AS
<_at> ::=       | AT
<_before> ::=   | BEFORE
<_binary> ::=   | BINARY
<_by> ::=       | BY
<_character> ::=    | CHARACTER
<_characters> ::=   | CHARACTERS
<_contains> ::= | CONTAINS
<_data> ::=     | DATA
<_end_of> ::=   | END <_of>
<_file> ::=     | TOK_FILE
<_final> ::=        | FINAL
<_for> ::=      | FOR
<_from> ::=     | FROM
<_in> ::=       | IN
<_in_order> ::= | ORDER | IN ORDER
<_index> ::=        | INDEX
<_indicate> ::= | INDICATE
<_initial> ::=  | TOK_INITIAL
<_into> ::=     | INTO
<_is> ::=       | IS
<_is_are> ::=   | IS | ARE
<_key> ::=      | KEY
<_left_or_right> ::=    | LEFT | RIGHT
<_line> ::=     | LINE
<_line_or_lines> ::=    | LINE | LINES
<_limits> ::=   | LIMIT <_is> | LIMITS <_are>
<_lines> ::=        | LINES
<_message> ::=  | MESSAGE
<_mode> ::=     | MODE
<_number> ::=   | NUMBER
<_numbers> ::=  | NUMBER | NUMBERS
<_of> ::=       | OF
<_on> ::=       | ON
<_onoff_status> ::= | STATUS IS | STATUS | IS
<_other> ::=        | OTHER
<_procedure> ::=    | PROCEDURE
<_program> ::=  | PROGRAM
<_record> ::=   | RECORD
<_records> ::=  | RECORD | RECORDS
<_right> ::=        | RIGHT
<_sign> ::=     | SIGN
<_signed> ::=   | SIGNED
<_sign_is> ::=  | SIGN | SIGN IS
<_size> ::=     | SIZE
<_standard> ::= | STANDARD
<_status> ::=   | STATUS
<_symbolic> ::= | SYMBOLIC
<_tape> ::=     | TAPE
<_terminal> ::=     | TERMINAL
<_then> ::=     | THEN
<_times> ::=        | TIMES
<_to> ::=       | TO
<_to_using> ::= | TO | USING
<_when> ::=     | WHEN
<_when_set_to> ::=  | WHEN SET TO
<_with> ::=     | WITH
    !* Mandatory selection *!

<coll_sequence> ::=     COLLATING SEQUENCE | SEQUENCE
<column_or_col> ::=     COLUMN | COL
<columns_or_cols> ::=   COLUMNS | COLS
<comp_equal> ::=        TOK_EQUAL | EQUAL
<exception_or_error> ::=    EXCEPTION | ERROR
<in_of> ::=         IN | OF
<label_option> ::=      STANDARD | OMITTED
<line_or_lines> ::=     LINE | LINES
<lock_records> ::=      RECORD | RECORDS
<object_char_or_word> ::=   CHARACTERS | WORDS
<records> ::=       RECORD <_is> | RECORDS <_are>
<reel_or_unit> ::=      REEL | UNIT
<scroll_line_or_lines> ::=  LINE | LINES
<size_or_length> ::=        SIZE | LENGTH
<with_dups> ::=     WITH DUPLICATES | DUPLICATES

<prog_coll_sequence>
::=  PROGRAM COLLATING SEQUENCE
| COLLATING SEQUENCE
| SEQUENCE

    !* Mandatory R/W keywords *!
<detail_keyword> ::=        DETAIL | DE
<ch_keyword> ::=        CONTROL HEADING | CH
<cf_keyword> ::=        CONTROL FOOTING | CF
<ph_keyword> ::=        PAGE HEADING | PH
<pf_keyword> ::=        PAGE FOOTING | PF
<rh_keyword> ::=        REPORT HEADING | RH
<rf_keyword> ::=        REPORT FOOTING | RF
<control_keyword> ::=   CONTROL <_is> | CONTROLS <_are>

