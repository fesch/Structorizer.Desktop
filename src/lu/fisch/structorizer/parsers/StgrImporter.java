/*
    Structorizer
    A little tool which you can use to create Nassi-Shneiderman Diagrams (NSD)

    Copyright (C) 2009  Bob Fisch

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or any
    later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package lu.fisch.structorizer.parsers;

/******************************************************************************************************
 *
 *      Author:         Kay Gürtzig
 *
 *      Description:    Importer for NSD files generated by hus-Struktogrammer.
 *
 ******************************************************************************************************
 *
 *      Revision List
 *
 *      Author          Date            Description
 *      ------          ----            -----------
 *      Kay Gürtzig     2019-09-13      First Issue (for #746)
 *      Kay Gürtzig     2022-05-08      Issue #1034: default text prefixes eliminated or replaced,
 *                                      correct handling of default branches in CASE structures
 *      Kay Gürtzig     2022-05-30/31   Enh. #1035: Enabled to load project files as arrangements and
 *                                      to cope with code 01 .stgr files; function detection added.
 *      Kay Gürtzig     2022-06-01      Enh. #1035: Individually coloured diagrams in a project and
 *                                      projects without colour settings properly considered
 *
 ******************************************************************************************************
 *
 *      Comment:
 *      2022-05-30 / Kay Gürtzig
 *      - Initial version did not support stgp files (project files, potentially consisting of more than
 *        one diagram), this was now empirically added according to enhancement request #1035.
 *      2019-09-13 / Kay Gürtzig
 *      - Initial version does not support str files as generated by the Delphi-implemented hus-Struktogrammer
 *        version (Str32). This may be added later.
 *
 ******************************************************************************************************///

import java.awt.Color;
import java.awt.Point;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.filechooser.FileFilter;

import org.xml.sax.SAXException;

import lu.fisch.structorizer.archivar.Archivar;
import lu.fisch.structorizer.archivar.Archivar.ArchiveIndex;
import lu.fisch.structorizer.arranger.Arranger;
import lu.fisch.structorizer.elements.Alternative;
import lu.fisch.structorizer.elements.Call;
import lu.fisch.structorizer.elements.Case;
import lu.fisch.structorizer.elements.Element;
import lu.fisch.structorizer.elements.IElementVisitor;
import lu.fisch.structorizer.elements.Instruction;
import lu.fisch.structorizer.elements.Repeat;
import lu.fisch.structorizer.elements.Root;
import lu.fisch.structorizer.elements.Subqueue;
import lu.fisch.structorizer.elements.While;
import lu.fisch.structorizer.io.Ini;
import lu.fisch.utils.StringList;

/**
 * Importer for NSD files generated by hus-Struktogrammer.
 * @author Kay Gürtzig
 */
public class StgrImporter implements INSDImporter {

	// START KGU#1029 2022-05-08: Issue #1034
	private static final StringList DEFAULT_PREFIXES_INSTR = StringList.explode("Instruction:,Anweisung:", ",");
	private static final StringList DEFAULT_PREFIXES_ALT = StringList.explode("If ,Ist ", ",");
	private static final StringList DEFAULT_PREFIXES_CASE = StringList.explode("In the case of ,Im Fall von ", ",");
	private static final StringList DEFAULT_PREFIXES_WHILE = StringList.getNew("While ");
	private static final StringList DEFAULT_PREFIXES_REPEAT = StringList.getNew("Until ");
	private static final StringList STANDARD_DEFAULT_CASE_LABELS = StringList.explode("Else,Sonst", ",");
	private boolean insertPrefixes = false;
	private boolean removePrefixes = false;
	// END KGU#1029 2022-05-08
	
	// START KGU#1030 2022-05-30: Enh. #1035 Accept project files, too
	/**
	 * Classifying file format identifiers for stgr/stgp file contents
	 */
	private static enum FileFormat {
		/** Not usable file format */
		INCORRECT,
		/** Structogram without colour information (code 1) */
		STGR,
		/** Structogram with colour information (code 2) */
		STGRCOL,
		/** Project file (code 3) */
		STGP
		};
	/** The initial strings representing FileFormat codes STGR, STGRCOL, STGP, ...; the corresponding
	 * code byte that follow the strings are assumed to be equal to index + 2 */
	private static final String[] FORMAT_STRINGS = new String[]{
		"STGR",
		"STGR",
		"StgrPrj"
	};
	// END KGU#1030 2022-05-30
	
	private Color elementColor = Color.WHITE;
	public static final Logger logger = Logger.getLogger(NSDParser.class.getName());
	
	/**
	 * Just creates a new importer for hus-Struktogrammer files
	 */
	public StgrImporter() {
		// START KGU#1029 2022-05-08: Issue #1034
		removePrefixes = Ini.getInstance().getProperty("impRefactorOnLoading", "false").equals("true");
		insertPrefixes = Ini.getInstance().getProperty("impOptKeywords", "false").equals("true");
		// END KGU#1029 2022-05-08
	}

	@Override
	public String getDialogTitle() {
		return "hus-Struktogrammer";
	}

	@Override
	public String getFileDescription() {
		return "hus-Struktogrammer files";
	}

	@Override
	public String[] getFileExtensions() {
		// The import of stg files is planned for a later version
		// START KGU#1030 2022-05-31: Enh. #1035 now we import entire projects, too
		//final String[] exts = { "stgr" /*, "stg"*/ };
		final String[] exts = { "stgr", "stgp" /*, "stg"*/ };
		// END KGU#1030 2022-05-31
		return exts;
	}

	@Override
	public FileFilter getFileFilter() {
		return new javax.swing.filechooser.FileFilter() {

			/* (non-Javadoc)
			 * @see javax.swing.filechooser.FileFilter#getDescription()
			 */
			@Override
			public final String getDescription() 
			{
				return getFileDescription();
			}

			/* (non-Javadoc)
			 * @see javax.swing.filechooser.FileFilter#accept(java.io.File)
			 */
			@Override
			public final boolean accept(File f) 
			{
				if (f.isDirectory()) 
				{
					return true;
				}

				String extension = getExtension(f);
				if (extension != null) 
				{
					return isOK(f.getName());
				}

				return false;
			}

		};
	}

	@Override
	public Root parse(String _filename) throws SAXException, IOException {
		URL url = new URL(_filename);
		File file = new File(url.getPath());
		Root root = null;
		try (InputStream is = new FileInputStream(file);) {
			// START KGU#1030 2022-05-30: Enh. #1035
			//if (!checkFormat(is)) {
			//	throw new IOException("Wrong file format");
			//}
			switch (identifyFormat(is)) {
			case INCORRECT:
				throw new IOException("Wrong file format");
			case STGR:
				root = readDiagram(file, is, null, false);
				break;
			case STGRCOL:
				root = readDiagram(file, is, null, true);
				break;
			case STGP:
				root = readProject(file, is);
			}
			
			// END KGU#1030 2022-05-30
		}
		catch (Exception ex) {
			logger.log(Level.WARNING, getDialogTitle() + " import failed!", ex);
			throw ex;
		}
		return root;
	}

	// START KGU#1030 2022-05-31: Enh. #1035
	/**
	 * Reads a set of diagrams from the *.stgp file represented by the input stream
	 * {@code is}.
	 * 
	 * @param file - {@link File} object providing the source file path.
	 * @param is - the opened (and partially read binary) {@link InputStream} from the given
	 *     {@code file}.
	 * @return one of the extracted {@link Root}s, preferably a Program Root.
	 * 
	 * @throws IOException
	 */
	private Root readProject(File file, InputStream is) throws IOException
	{
		// Register all diagrams without individual element colour (for project colour)
		ArrayList<Root> rootsToDye = new ArrayList<Root>();
		Root top = null;
		byte[] diagrCnt = new byte[] {0};
		is.read(diagrCnt);
		int nDiagrs = uByteToInt(diagrCnt[0]);
		ArchiveIndex index = (new Archivar()).makeEmptyIndex();
		for (int i = 0; i < nDiagrs; i++) {
			elementColor = Color.WHITE;
			Point pt = readCoords(is);	// top left position in the arrangement
			FileFormat format = identifyFormat(is);
			boolean isColoured = format == FileFormat.STGRCOL;
			if (format != FileFormat.STGR && !isColoured) {
				throw new IOException("Wrong file format - STGR entry expected");
			}
			Root rt = readDiagram(file, is, index, isColoured);
			if (rt != null) {
				index.addEntryFor(rt, pt);
				if (top == null || !top.isProgram() && rt.isProgram()) {
					top = rt;
				}
				if (!isColoured) {
					rootsToDye.add(rt);
				}
			}
		}
		readText(is);	// Project font (ignored)
		// A 01 byte signals project colour settings
		if (is.read() == 1) {
			elementColor = readColor(is);	// Element background
			readColor(is);	// Frame colour (not used)
			readColor(is);	// Line colour (not used)
			readColor(is);	// Text colour (not used)
			is.skip(1);		// Skip a 00 byte
			if (elementColor != Color.WHITE) {
				// Now we have to dye all elements of all Roots without specific colour
				for (Root root: rootsToDye) {
					root.traverse(new IElementVisitor() {
						@Override
						public boolean visitPreOrder(Element _ele) {
							_ele.setColor(elementColor);
							return true;
						}
						@Override
						public boolean visitPostOrder(Element _ele) {
							return true;
						}});
				}
			}
		}
		// Build an arrangement group if the project has more than one diagram
		if (nDiagrs > 1) {
			is.skip(14);	// width, height, margins, scale, 00 (all ignored)
			// Use the project title (by default the file name) as group name
			String groupName = file.getName();
			StringList projName = readText(is);
			if (projName != null && !projName.isEmpty() || !projName.get(0).isBlank()) {
				groupName = projName.get(0);
			}
			Arranger.getInstance().addToPool(index, groupName);
		}
		return top;
	}
	
	/**
	 * Reads a single diagram from the *.stgr or *stgp file represented by the input stream
	 * {@code is}.
	 * 
	 * @param file - {@link File} object providing the source file path.
	 * @param is - the opened (and partially read binary) {@link InputStream} from the given
	 *     {@code file}.
	 * @param index - an {@link ArchiveIndex} object if we are reading a project file, or
	 *     {@code null}.
	 * @param withColInfo - whether colour information is to be expected after the font name
	 * @return the extracted {@link Root} object.
	 * 
	 * @throws IOException if something went wrong (defective format, unexpected eof or the like)
	 */
	private Root readDiagram(File file, InputStream is, ArchiveIndex index, boolean withColInfo) throws IOException {
		Root root;
		// Diagram header text
		StringList header = readText(is);
		root = new Root(header);
		is.skip(8);		// Ignore width and height
		readText(is);	// Skip font
		// START KGU#1030 2022-05-30: Bugfix #1035
		if (withColInfo) {
		// END KGU#1030 2022-05-30
			is.skip(1);	// Skip a 01 byte
			elementColor = readColor(is);	// Element background
			readColor(is);	// Frame colour (not used)
			readColor(is);	// Line colour (not used)
			readColor(is);	// Text colour (not used)
			is.skip(1);	// Skip a 00 byte
		// START KGU#1030 2022-05-30: Bugfix #1035
		}
		// Attempt to decide whether it is a routine diagram (pair of parentheses)
		String rootText = root.getText().getLongString();
		int posPar1 = rootText.indexOf("(");
		if (posPar1 >= 0 && rootText.indexOf(")", posPar1+1) >= 0) {
			root.setProgram(false);
		}
		// END KGU#1030 2022-05-30
		importSubqueue(is, root.children);
		root.origin += " / " + this.getClass().getSimpleName() + ": \"" + file + "\"";
		if (!root.isEmpty()) {
			root.setChanged(false);
		}
		return root;
	}
	// END KGU#1030 2022-05-31

	private void importSubqueue(InputStream is, Subqueue sq) throws IOException {
		byte[] elCnt = new byte[1];
		if (is.read(elCnt) > 0) {
			for (int i = 0; i < elCnt[0]; i++) {
				readElement(is, sq);
			}
		}
	}

	private void readElement(InputStream is, Subqueue sq) throws IOException {
		byte code[] = new byte[]{0};
		is.read(code);
		if (code[0] > 0) {
			Element el = null;
			StringList text = readText(is);
			switch (code[0]) {
			case 0x10:
				// START KGU#1029 2022-05-08: Issue #1034
				refactorText(text, DEFAULT_PREFIXES_INSTR, null);
				// END KGU#1029 2022-05-08
				el = new Instruction(text);
				break;
			case 0x11:
				el = new Call(text);
				break;
			case 0x20:
				// START KGU#1029 2022-05-08: Issue #1034
				refactorText(text, DEFAULT_PREFIXES_ALT, "preAlt");
				if (removePrefixes) {
					String lastLine = text.get(text.count()-1);
					if (lastLine.endsWith("?")) {
						text.set(text.count()-1, lastLine.substring(0, lastLine.length()-1));
					}
				}
				// END KGU#1029 2022-05-08
				el = readAlternative(is, text);
				break;
			case 0x21:
				// START KGU#1029 2022-05-08: Issue #1034
				refactorText(text, DEFAULT_PREFIXES_CASE, "preCase");
				// END KGU#1029 2022-05-08
				el = readCase(is, text);
				break;
			case 0x30:
				// START KGU#1029 2022-05-08: Issue #1034
				refactorText(text, DEFAULT_PREFIXES_REPEAT, "preRepeat");
				// END KGU#1029 2022-05-08
				el = readRepeat(is, text);
				break;
			case 0x31:
				// START KGU#1029 2022-05-08: Issue #1034
				refactorText(text, DEFAULT_PREFIXES_WHILE, "preWhile");
				// END KGU#1029 2022-05-08
				el = readWhile(is, text);
				break;
			}
			if (el != null) {
				el.setColor(elementColor);
				sq.addElement(el);
			}
		}
	}

	private Element readAlternative(InputStream is, StringList text) throws IOException {
		Alternative alt = new Alternative(text);
		readText(is);	// Skip TRUE label
		readText(is);	// Skip FALSE label
		importSubqueue(is, alt.qTrue);
		importSubqueue(is, alt.qFalse);
		return alt;
	}

	private Element readCase(InputStream is, StringList text) throws IOException {
		Case cas = null;
		StringList content = StringList.explode(text.concatenate("\\\n"), "\n");
		byte[] brCnt = new byte[] {0};
		is.read(brCnt);
		if (brCnt[0] > 0) {
			int ixCase = content.count();	// Index of the current case selector
			for (int i = 0; i < brCnt[0]; i++) {
				content.add("???");
			}
			content.add("%");
			cas = new Case(content);
			for (int i = 0; i < brCnt[0]; i++) {
				String sel = importBranch(is, cas.qs.get(i));
				if (sel != null) {
					cas.getText().set(ixCase + i, sel);
					// START KGU#1029 2022-05-08: Issue #1034 Detect else branch
					if (i + 1 == brCnt[0] && STANDARD_DEFAULT_CASE_LABELS.contains(sel)) {
						// The last branch seams to mean a default branch, so drop the "%" line
						content = cas.getText();
						content.remove(content.count()-1);
						// To save it back cares for the correct number of branches.
						cas.setText(content);
					}
					// END KGU#1029 2022-05-08
				}
			}
		}
		return cas;
	}

	private String importBranch(InputStream is, Subqueue subqueue) throws IOException {
		byte[] code = new byte[1];
		if (is.read(code) < 1 || code[0] != 0x22) {
			return null;
		}
		String selector = readText(is).getLongString();
		importSubqueue(is, subqueue);
		return selector;
	}

	private Element readRepeat(InputStream is, StringList text) throws IOException {
		Repeat loop = new Repeat(StringList.explode(text.concatenate("\\\n"), "\n"));
		importSubqueue(is, loop.getBody());
		return loop;
	}

	private Element readWhile(InputStream is, StringList text) throws IOException {
		While loop = new While(StringList.explode(text.concatenate("\\\n"), "\n"));
		importSubqueue(is, loop.getBody());
		return loop;
	}

	// START KGU#1029 2022-05-08: Issue #1034
	/**
	 * @param text - the multi-line element text to be refactored - will be modified
	 *     in place!
	 * @param defaultPrefixes - a StringList of possible default prefixes in
	 *     hus-Struktogrammer for this element kind
	 * @param key - a parser preference key for this kind of element (if {@code null}
	 *     then no insertion will take place but all lines will be processed, otherwise
	 *     only the first line of {@code text} will be processed and a parser prefix
	 *     (re)placement may be done if {@link #insertPrefixes} is {@code true} and a
	 *     non-empty parser preference keyword is configured)
	 */
	private void refactorText(StringList text, StringList defaultPrefixes, String key) {
		if (removePrefixes) {
			String subst = "";
			if (insertPrefixes && key != null) {
				subst = CodeParser.getKeywordOrDefault(key, "");
				if (!subst.isEmpty() && !subst.substring(subst.length()-1).isBlank()) {
					subst += " ";
				}
			}
			int jEnd = key == null ? 1 : text.count();
			for (int j = 0; j < jEnd; j++) {
				String line = text.get(j);
				for (int i = 0; i < defaultPrefixes.count(); i++) {
					String prefix = defaultPrefixes.get(i);
					if (line.startsWith(prefix)) {
						// prefix never contains special regex characters, so it's ok
						text.set(j, line.replaceFirst(prefix, subst));
						break;
					}
				}
			}
		}
	}
	// END KGU#1029 2022-05-08

	/**
	 * Reads a byte sequence consisting of a short value expressing the string
	 * length and the subsequent characters as string content, and splits it by
	 * newline characters into a {@link StringList}.
	 * 
	 * @param is - the binary {@link InputStream} to be read
	 * @return the string, split into lines
	 * 
	 * @throws IOException if e.g. the format is violated
	 */
	private StringList readText(InputStream is) throws IOException {
		StringList strl = null;
		byte[] txtLen = new byte[2];
		if (is.read(txtLen) == txtLen.length) {
			ByteBuffer wrapped = ByteBuffer.wrap(txtLen); // big-endian by default
			short len = wrapped.getShort();
			byte[] text = new byte[len];
			is.read(text);
			String str = new String(text, "UTF-8");
			strl = StringList.explode(str, "\n");
		}
		return strl;
	}
	
	/**
	 * Reads the next 4 bytes from input stream {@code is}, interpreting
	 * them as alpha, red, green, and blue components of a colour, which
	 * is then returned.
	 * 
	 * @param is - the binary {@link InputStream} to be read from
	 * @return the extracted {@link Color} object.
	 * 
	 * @throws IOException e.g. if there are less than 4 bytes left
	 */
	private Color readColor(InputStream is) throws IOException
	{
		Color col = null;
		byte[] colBytes = new byte[4];
		if (is.read(colBytes) == colBytes.length) {
			col = new Color(uByteToInt(colBytes[1]), uByteToInt(colBytes[2]), uByteToInt(colBytes[3]), uByteToInt(colBytes[0]));
		}
		return col;
	}
	
	/**
	 * Reads two 4 byte (bigendian) integer values from the input stream,
	 * interpreting them as x and y position and forms the returned {@link Point}
	 * from them.
	 * 
	 * @param is - the binary {@link InputStream} to be read from from.
	 * @return the extracted {@link Point} or {@code null}
	 * 
	 * @throws IOException if the fileformat is corrupt
	 */
	private Point readCoords(InputStream is) throws IOException
	{
		Point pt = null;
		byte[] coordBytes = new byte[8];
		if (is.read(coordBytes) == coordBytes.length) {
			ByteBuffer wrapped = ByteBuffer.wrap(coordBytes); // big-endian by default
			int x = wrapped.getInt();
			int y = wrapped.getInt();
			pt = new Point(x, y);
		}
		return pt;
	}
	
	/**
	 * Auxiliary method to force an unsigned int value from the given byte
	 * 
	 * @param b - the source byte
	 * @return the value of b as an unsigned int
	 */
	private static int uByteToInt(byte b)
	{
		return (int)(b & 0xFF);
	}
	
	/**
	 * Checks the initial part of the stgr/stgp {@link InputStream} {@code str}
	 * for a known diagram format sequence and returns a format identifier from
	 * type {@link FileFormat}. Expects a string length / character sequence
	 * followed by a single byte code 0x01, 0x02, or 0x03.
	 */
	// START KGU#1030 2022-05-30: Enh. #1035 - Acceptance of strgp files
	//private boolean checkFormat(InputStream str) throws IOException {
	//	final byte[] format = new byte[]{0x00, 0x04, 'S', 'T', 'G', 'R', 0x02};
	//	byte[] header = new byte[format.length];
	//	if (str.read(header) < format.length) {
	//		return false;
	//	}
	//	for (int i = 0; i < format.length; i++) {
	//		if (header[i] != format[i]) {
	//			return false;
	//		}
	//	}
	//	return true;
	private FileFormat identifyFormat(InputStream str) throws IOException {
		FileFormat format = FileFormat.INCORRECT;
		FileFormat[] formats = FileFormat.values();
		StringList formatStrL = readText(str);
		if (formatStrL == null || formatStrL.count() != 1) {
			return format;
		}
		int code = str.read();
		format = formats[code];
		if (!formatStrL.get(0).equals(FORMAT_STRINGS[format.ordinal()-1])) {
			return FileFormat.INCORRECT;
		}
		return format;
	}
	// END KGU#1030 2022-05-30

	private static final String getExtension(File f) 
	{
		String ext = null;
		String s = f.getName();
		int i = s.lastIndexOf('.');
		
		if (i > 0 &&  i < s.length() - 1) 
		{
			ext = s.substring(i+1).toLowerCase();
		}
		
		return ext;
	}
	
	private static final String getExtension(String s) 
	{
		String ext = null;
		int i = s.lastIndexOf('.');
		
		if (i > 0 &&  i < s.length() - 1) 
		{
			ext = s.substring(i+1).toLowerCase();
		}
		return ext;
	}
	
	/**
	 * Internal check for acceptable input files. The default implementation just
	 * compares the filename extension with the extensions configured in and
	 * provided by {@link #getFileExtensions()}. Helper method for method 
	 * {@link #accept(File)}.
	 * 
	 * @param _filename
	 * @return true if the import file is formally welcome. 
	 */
	protected final boolean isOK(String _filename)
	{
		boolean res = false;
		String ext = getExtension(_filename); 
		if (ext != null)
		{
			for (int i = 0; i < getFileExtensions().length; i++)
			{
				res = res || (ext.equalsIgnoreCase(getFileExtensions()[i]));
			}
		}
		return res;
	}
	
}